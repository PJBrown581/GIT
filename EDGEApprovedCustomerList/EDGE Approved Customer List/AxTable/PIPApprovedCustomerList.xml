<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PIPApprovedCustomerList</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class PIPApprovedCustomerList extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkCustomerRelation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the combination of the fields <c>CustomerCode</c> and <c>CustomerRelation</c> is valid.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    public boolean checkCustomerRelation()
    {
        boolean  ok = true;
    
        switch(this.CustomerCode)
        {
            case TableGroupAll::Table:
                if (!CustTable::exist(this.CustomerRelation))
                {
                    ok = checkFailed("@PIP583");
    
                }
                break;
            case TableGroupAll::GroupId:
                if (!PIPApprovedCustomerGroup::exist(this.CustomerRelation))
                {
                    ok = checkFailed("@PIP583");
                }
                break;
            case TableGroupAll::All:
                if (this.CustomerRelation)
                {
                    ok = checkFailed("@PIP583");
                }
                break;
        }
    
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemRelation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the combination of the fields <c>ItemCode</c> and <c>ItemRelation</c> is valid.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    public boolean checkItemRelation()
    {
        boolean  ok = true;
    
        switch(this.ItemCode)
        {
            case TableGroupAll::Table:
                if (!InventTable::exist(this.ItemRelation))
                {
                    ok = checkFailed("@PIP584");
    
                }
                break;
            case TableGroupAll::GroupId:
                if (!PIPApprovedItemGroup::exist(this.ItemRelation))
                {
                    ok = checkFailed("@PIP584");
                }
                break;
            case TableGroupAll::All:
                if (this.ItemRelation)
                {
                    ok = checkFailed("@PIP584");
                }
                break;
        }
    
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();
    
        this.ValidFrom  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        this.ValidTo    = dateMax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);
    
        switch (_fieldId)
        {
            case fieldNum(PIPApprovedCustomerList, CustomerCode):
                if (this.CustomerCode == TableGroupAll::All)
                {
                    this.CustomerRelation = "";
                }
                break;
    
            case fieldNum(PIPApprovedCustomerList, ItemCode):
                if (this.ItemCode == TableGroupAll::All)
                {
                    this.ItemRelation = "";
                }
                break;

            case fieldNum(PIPApprovedCustomerList, CustomerRelation):
                this.checkCustomerRelation();
                break;

            case fieldNum(PIPApprovedCustomerList, ItemRelation):
                this.checkItemRelation();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;
    
        ret = super();
    
        ret = ret && this.checkItemRelation() && this.checkCustomerRelation();
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        this.clearRelationForCodeAll();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        this.clearRelationForCodeAll();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearRelationForCodeAll</Name>
				<Source><![CDATA[
    private void clearRelationForCodeAll()
    {
        if (this.ItemCode == TableGroupAll::All)
        {
            this.ItemRelation = '';
        }

        if (this.CustomerCode == TableGroupAll::All)
        {
            this.CustomerRelation = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildResolvedCustomers</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a list of customers aproved for an item.
    /// </summary>
    /// <param name="_inventTable">
    ///     Item record that potential customers are approved for.
    /// </param>
    /// <param name="_startDate">
    ///     Starting date. Optional.
    /// </param>
    /// <param name="_endDate">
    ///     Ending date. Optional.
    /// </param>
    /// <param name="_inventDim">
    ///     Record from the <c>InventDim</c> table containing the product dimension to restrict the results to. Optional.
    /// </param>
    /// <returns>
    ///     A <c>TmpPIPApprovedCustItemList</c> buffer containing a list of customers approved for the specified item.
    /// </returns>
    public static TmpPIPApprovedCustItemList buildResolvedCustomers(InventTable _inventTable, ValidFromDate _startDate = dateNull(), ValidToDate _endDate = dateMax(), InventDim _inventDim = null)
    {
        TmpPIPApprovedCustItemList  tmpPIPApprovedCustItemList;
        PIPApprovedCustomerListView pipApprovedCustomerListView;
        PIPApprovedCustomerList     pipApprovedCustomerListPriorityRecord;
        PIPApprovedCustomerList     pipApprovedCustomerList;
        CustTable                   customer;

        boolean checkInventDimMatches = _inventDim.anyProductDimensionSpecified();
    
        // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
        // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)

        // find all unique customers related to item through ACL
        while select AccountNum, PIPApprovedCustomerGroup from customer
            exists join pipApprovedCustomerListView
                where ((pipApprovedCustomerListView.CustomerCode        == TableGroupAll::Table     && pipApprovedCustomerListView.CustomerRelation == customer.AccountNum)
                        || (pipApprovedCustomerListView.CustomerCode    == TableGroupAll::GroupId   && pipApprovedCustomerListView.CustomerRelation == customer.PIPApprovedCustomerGroup)
                        || (pipApprovedCustomerListView.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerListView.CustomerRelation == ''))
                    && ((pipApprovedCustomerListView.ItemCode           == TableGroupAll::Table     && pipApprovedCustomerListView.ItemRelation     == _inventTable.ItemId)
                        || (pipApprovedCustomerListView.ItemCode        == TableGroupAll::GroupId   && pipApprovedCustomerListView.ItemRelation     == _inventTable.PIPApprovedItemGroup)
                        || (pipApprovedCustomerListView.ItemCode        == TableGroupAll::All       && pipApprovedCustomerListView.ItemRelation     == ''))
        {
            // find the applicable relationship in case multiple relationships exist through table/group/all combinations
            pipApprovedCustomerListPriorityRecord = PIPApprovedCustomerList::getPriorityRelation(
                                                        customer.AccountNum,
                                                        customer.PIPApprovedCustomerGroup,
                                                        _inventTable.ItemId,
                                                        _inventTable.PIPApprovedItemGroup,
                                                        _inventDim);
    
            boolean mayNeedVariantsAdded = pipApprovedCustomerListPriorityRecord.mayNeedVariantsAdded();
            Set inventDimIdAddedSet;
            if (mayNeedVariantsAdded)
            {
                inventDimIdAddedSet = new Set(Types::Container);
            }
    
            // include expired relationships as well for the record selected in above query
            while select validTimeState(_startDate, _endDate) pipApprovedCustomerList
                where pipApprovedCustomerList.ItemCode          == pipApprovedCustomerListPriorityRecord.ItemCode
                    && pipApprovedCustomerList.ItemRelation     == pipApprovedCustomerListPriorityRecord.ItemRelation
                    && (!checkInventDimMatches
                        || pipApprovedCustomerList.InventDimId == pipApprovedCustomerListPriorityRecord.InventDimId)
                    && pipApprovedCustomerList.CustomerCode     == pipApprovedCustomerListPriorityRecord.CustomerCode
                    && pipApprovedCustomerList.CustomerRelation == pipApprovedCustomerListPriorityRecord.CustomerRelation
            {
                tmpPIPApprovedCustItemList.ItemRelation = _inventTable.ItemId;
                tmpPIPApprovedCustItemList.CustRelation = customer.AccountNum;
                tmpPIPApprovedCustItemList.CustName     = CustTable::find(customer.AccountNum).name();
                tmpPIPApprovedCustItemList.ValidFrom    = pipApprovedCustomerList.ValidFrom;
                tmpPIPApprovedCustItemList.ValidTo      = pipApprovedCustomerList.ValidTo;
                tmpPIPApprovedCustItemList.InventDimId  = pipApprovedCustomerList.InventDimId;
                tmpPIPApprovedCustItemList.insert();

                if (mayNeedVariantsAdded)
                {
                    inventDimIdAddedSet.add([pipApprovedCustomerList.InventDimId, pipApprovedCustomerList.ValidFrom, pipApprovedCustomerList.ValidTo]);
                }
            }

            if (mayNeedVariantsAdded)
            {
                pipApprovedCustomerListPriorityRecord.addVariantsFromCustomerGroupAndAll(tmpPIPApprovedCustItemList, customer, _startDate, _endDate, inventDimIdAddedSet, _inventDim);
            }
        }
    
        return tmpPIPApprovedCustItemList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildResolvedItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a list of items approved for a customer.
    /// </summary>
    /// <param name="_custTable">
    ///     Customer record to build item list from.
    /// </param>
    /// <param name="_startDate">
    ///     Starting date. Optional.
    /// </param>
    /// <param name="_endDate">
    ///     Ending date. Optional.
    /// </param>
    /// <returns>
    ///     A <c>TmpPIPApprovedCustItemList</c> buffer containing a list of items approved for the specified customer.
    /// </returns>
    public static TmpPIPApprovedCustItemList buildResolvedItems(CustTable _custTable, ValidFromDate _startDate = dateNull(), ValidToDate _endDate = dateMax())
    {
        TmpPIPApprovedCustItemList  tmpPIPApprovedCustItemList;
        PIPApprovedCustomerListView pipApprovedCustomerListView;
        PIPApprovedCustomerList     pipApprovedCustomerListPriorityRecord;
        PIPApprovedCustomerList     pipApprovedCustomerList;
        InventTable                 itemsAll;
    
        // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
        // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)

        // find all unique items related to customer through ACL
        while select ItemId, PIPApprovedItemGroup from itemsAll
            exists join pipApprovedCustomerListView
                where ((pipApprovedCustomerListView.ItemCode            == TableGroupAll::Table     && pipApprovedCustomerListView.ItemRelation     == itemsAll.ItemId)
                        || (pipApprovedCustomerListView.ItemCode        == TableGroupAll::GroupId   && pipApprovedCustomerListView.ItemRelation     == itemsAll.PIPApprovedItemGroup)
                        || (pipApprovedCustomerListView.ItemCode        == TableGroupAll::All       && pipApprovedCustomerListView.ItemRelation     == ''))
                    && ((pipApprovedCustomerListView.CustomerCode       == TableGroupAll::Table     && pipApprovedCustomerListView.CustomerRelation == _custTable.AccountNum)
                        || (pipApprovedCustomerListView.CustomerCode    == TableGroupAll::GroupId   && pipApprovedCustomerListView.CustomerRelation == _custTable.PIPApprovedCustomerGroup)
                        || (pipApprovedCustomerListView.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerListView.CustomerRelation == ''))
        {
            // find the applicable relationship in case multiple relationships exist through table/group/all combinations
            pipApprovedCustomerListPriorityRecord = PIPApprovedCustomerList::getPriorityRelation(
                                                        _custTable.AccountNum,
                                                        _custTable.PIPApprovedCustomerGroup,
                                                        itemsAll.ItemId,
                                                        itemsAll.PIPApprovedItemGroup);

            if (pipApprovedCustomerListPriorityRecord.RecId)
            {
                boolean mayNeedVariantsAdded = pipApprovedCustomerListPriorityRecord.mayNeedVariantsAdded();
                Set inventDimIdAddedSet = null;
                if (mayNeedVariantsAdded)
                {
                    inventDimIdAddedSet = new Set(Types::Container);
                }
    
                // include expired relationships as well for the record selected in above query
                while select validTimeState(_startDate, _endDate) pipApprovedCustomerList
                    where pipApprovedCustomerList.ItemRelation      == pipApprovedCustomerListPriorityRecord.ItemRelation
                        && pipApprovedCustomerList.ItemCode         == pipApprovedCustomerListPriorityRecord.ItemCode
                        && pipApprovedCustomerList.CustomerRelation == pipApprovedCustomerListPriorityRecord.CustomerRelation
                        && pipApprovedCustomerList.CustomerCode     == pipApprovedCustomerListPriorityRecord.CustomerCode
                {
                    tmpPIPApprovedCustItemList.CustRelation = _custTable.AccountNum;
                    tmpPIPApprovedCustItemList.ItemRelation = itemsAll.ItemId;
                    tmpPIPApprovedCustItemList.ItemName     = InventTable::find(itemsAll.ItemId).defaultProductName();
                    tmpPIPApprovedCustItemList.ValidFrom    = pipApprovedCustomerList.ValidFrom;
                    tmpPIPApprovedCustItemList.ValidTo      = pipApprovedCustomerList.ValidTo;
                    tmpPIPApprovedCustItemList.InventDimId  = pipApprovedCustomerList.InventDimId;
                    tmpPIPApprovedCustItemList.insert();

                    if (mayNeedVariantsAdded)
                    {
                        inventDimIdAddedSet.add([pipApprovedCustomerList.InventDimId, pipApprovedCustomerList.ValidFrom, pipApprovedCustomerList.ValidTo]);
                    }
                }

                if (mayNeedVariantsAdded)
                {
                    pipApprovedCustomerListPriorityRecord.addVariantsFromCustomerGroupAndAll(tmpPIPApprovedCustItemList, _custTable, _startDate, _endDate, inventDimIdAddedSet);
                }
            }
        }
    
        return tmpPIPApprovedCustItemList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayNeedVariantsAdded</Name>
				<Source><![CDATA[
    private boolean mayNeedVariantsAdded()
    {
        return this.ItemCode == TableGroupAll::Table && this.InventDimId != InventDim::inventDimIdBlank();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addVariantsFromCustomerGroupAndAll</Name>
				<Source><![CDATA[
    private void addVariantsFromCustomerGroupAndAll(TmpPIPApprovedCustItemList _tmpPIPApprovedCustItemList, CustTable _custTable, FromDate _startDate, ToDate _endDate, Set _inventDimIdAddedSet, InventDim _inventDimCrit = null)
    {
        ItemName productName = InventTable::find(this.ItemRelation).defaultProductName();

        if (_inventDimCrit.anyProductDimensionSpecified())
        {
            InventDimParm prodDimParm = _inventDimCrit.toDimParm();
            prodDimParm.clearTrackingDimensions();
            prodDimParm.clearStorageDimensions();

            // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
            // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)
            PIPApprovedCustomerList pipApprovedCustomerList;
            InventDim inventDim;
            while select validTimeState(_startDate, _endDate) pipApprovedCustomerList
                where (pipApprovedCustomerList.ItemCode             == TableGroupAll::Table     && pipApprovedCustomerList.ItemRelation     == this.ItemRelation)
                    && ((pipApprovedCustomerList.CustomerCode       == TableGroupAll::GroupId   && PIPApprovedCustomerList.CustomerRelation == _custTable.PIPApprovedCustomerGroup)
                        || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''))
                    #InventDimExistsJoinAllowBlank(pipApprovedCustomerList.InventDimId, inventDim, _inventDimCrit, prodDimParm, prodDimParm)
            {
                container dimKey = [pipApprovedCustomerList.InventDimId, pipApprovedCustomerList.ValidFrom, pipApprovedCustomerList.ValidTo];
                if (_inventDimIdAddedSet.in(dimKey))
                {
                    continue;
                }

                _inventDimIdAddedSet.add(dimKey);

                _tmpPIPApprovedCustItemList.CustRelation = _custTable.AccountNum;
                _tmpPIPApprovedCustItemList.ItemRelation = this.ItemRelation;
                _tmpPIPApprovedCustItemList.ItemName     = productName;
                _tmpPIPApprovedCustItemList.ValidFrom    = pipApprovedCustomerList.ValidFrom;
                _tmpPIPApprovedCustItemList.ValidTo      = pipApprovedCustomerList.ValidTo;
                _tmpPIPApprovedCustItemList.InventDimId  = pipApprovedCustomerList.InventDimId;
                _tmpPIPApprovedCustItemList.insert();
            }
        }
        else
        {
            // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
            // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)
            PIPApprovedCustomerList pipApprovedCustomerList;
            while select validTimeState(_startDate, _endDate) pipApprovedCustomerList
                where (pipApprovedCustomerList.ItemCode          == TableGroupAll::Table    && pipApprovedCustomerList.ItemRelation     == this.ItemRelation)
                    && ((pipApprovedCustomerList.CustomerCode    == TableGroupAll::GroupId  && PIPApprovedCustomerList.CustomerRelation == _custTable.PIPApprovedCustomerGroup)
                        || (pipApprovedCustomerList.CustomerCode == TableGroupAll::All      && PIPApprovedCustomerList.CustomerRelation == ''))
            {
                container dimKey = [pipApprovedCustomerList.InventDimId, pipApprovedCustomerList.ValidFrom, pipApprovedCustomerList.ValidTo];
                if (_inventDimIdAddedSet.in(dimKey))
                {
                    continue;
                }

                _inventDimIdAddedSet.add(dimKey);

                _tmpPIPApprovedCustItemList.CustRelation = _custTable.AccountNum;
                _tmpPIPApprovedCustItemList.ItemRelation = this.ItemRelation;
                _tmpPIPApprovedCustItemList.ItemName     = productName;
                _tmpPIPApprovedCustItemList.ValidFrom    = pipApprovedCustomerList.ValidFrom;
                _tmpPIPApprovedCustItemList.ValidTo      = pipApprovedCustomerList.ValidTo;
                _tmpPIPApprovedCustItemList.InventDimId  = pipApprovedCustomerList.InventDimId;
                _tmpPIPApprovedCustItemList.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if an item and customer combination exists in the approved customer list.
    /// </summary>
    /// <param name="_inventTable">
    ///     The item to check.
    /// </param>
    /// <param name="_custTable">
    ///     The customer to check.
    /// </param>
    /// <param name="_startDate">
    ///     The start date for the validation check.
    /// </param>
    /// <param name="_endDate">
    ///     The end date for the validation check. If not specified, startDate is used as endDate as well.
    /// </param>
    /// <param name="_inventDim">
    ///     A record for the <c>InventDim</c> table containing the product dimension to include in the validation. Optional.
    /// </param>
    /// <returns>
    ///     true if an item and customer combination exists in the approved customer list; otherwise, false.
    /// </returns>
    public static boolean existValid(
        InventTable     _inventTable,
        CustTable       _custTable,
        ValidFromDate   _startDate,
        ValidToDate     _endDate = dateNull(),
        InventDim       _inventDim = null
        )
    {
        PIPApprovedCustomerList pipApprovedCustomerList;
        date                    fromDate;
        date                    toDate;
    
        if (_endDate != dateNull() && _endDate < _startDate)
        {
            throw error(strFmt("@SYS22828", funcName()));
        }
    
        if (_inventTable && _custTable)
        {
            fromDate = _startDate == dateNull() ? DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) : _startDate;
            toDate   = _endDate   == dateNull() ? fromDate        : _endDate;

            // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
            // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)
            if (_inventDim.anyProductDimensionSpecified())
            {
                InventDimParm prodDimParm = _inventDim.toDimParm();
                prodDimParm.clearTrackingDimensions();
                prodDimParm.clearStorageDimensions();

                InventDim inventDim;
                select firstOnly validTimeState(fromDate, toDate) RecId
                    from pipApprovedCustomerList
                    where (pipApprovedCustomerList.ItemCode                 == TableGroupAll::Table     && pipApprovedCustomerList.ItemRelation     == _inventTable.ItemId)
                        && ((pipApprovedCustomerList.CustomerCode           == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == _custTable.AccountNum)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == _custTable.PIPApprovedCustomerGroup)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''))
                    #InventDimExistsJoinAllowBlank(pipApprovedCustomerList.InventDimId, inventDim, _inventDim, prodDimParm, prodDimParm);

                if (!pipApprovedCustomerList.RecId)
                {
                    select firstOnly validTimeState(fromDate, toDate) RecId
                    from pipApprovedCustomerList
                    where ((pipApprovedCustomerList.ItemCode                == TableGroupAll::GroupId   && pipApprovedCustomerList.ItemRelation     == _inventTable.PIPApprovedItemGroup)
                            || (pipApprovedCustomerList.ItemCode            == TableGroupAll::All       && pipApprovedCustomerList.ItemRelation     == ''))
                        && ((pipApprovedCustomerList.CustomerCode           == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == _custTable.AccountNum)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == _custTable.PIPApprovedCustomerGroup)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''));
                }
            }
            else
            {
                select firstOnly validTimeState(fromDate, toDate) RecId
                    from pipApprovedCustomerList
                    where ((pipApprovedCustomerList.ItemCode                == TableGroupAll::Table     && pipApprovedCustomerList.ItemRelation     == _inventTable.ItemId)
                            || (pipApprovedCustomerList.ItemCode            == TableGroupAll::GroupId   && pipApprovedCustomerList.ItemRelation     == _inventTable.PIPApprovedItemGroup)
                            || (pipApprovedCustomerList.ItemCode            == TableGroupAll::All       && pipApprovedCustomerList.ItemRelation     == ''))
                        && ((pipApprovedCustomerList.CustomerCode           == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == _custTable.AccountNum)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == _custTable.PIPApprovedCustomerGroup)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''));
            }
        }
    
        return pipApprovedCustomerList.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existValidForCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether an approved cutomer exists in the list.
    /// </summary>
    /// <param name="_custAccount">
    ///     The customer account number.
    /// </param>
    /// <param name="_startDate">
    ///     Start date of when the customer was on the list. If the start date is null, then current date is used.
    /// </param>
    /// <param name="_endDate">
    ///     End date of when the customer was on the list. If the start date is null, then current date is used.
    /// </param>
    /// <returns>
    ///     true if an approved customer exists in the list; otherwise, false.
    /// </returns>
    public static boolean existValidForCustomer(
        CustAccount     _custAccount,
        ValidFromDate   _startDate  = dateNull(),
        ValidToDate     _endDate    = dateNull()
        )
    {
        PIPApprovedCustomerList pipApprovedCustomerList;
        CustTable               custTable;
        date                    fromDate;
        date                    toDate;
    
        if (isConfigurationkeyEnabled(configurationKeyNum(PIPACL)))
        {
            custTable = CustTable::find(_custAccount);
    
            fromDate = _startDate == dateNull() ? DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) : _startDate;
            toDate   = _endDate   == dateNull() ? fromDate : _endDate;
    
            // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
            // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)
            select firstOnly validTimeState(fromDate, toDate) RecId
                from pipApprovedCustomerList
                where (pipApprovedCustomerList.CustomerCode     == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == custTable.AccountNum)
                    || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == custTable.PIPApprovedCustomerGroup)
                    || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == '');
        }
    
        return pipApprovedCustomerList.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existValidItemForCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a value indicating if an approved item exists for a cutomer.
    /// </summary>
    /// <param name="_custAccount">
    ///     The customer account number.
    /// </param>
    /// <param name="_itemId">
    ///     The item ID.
    /// </param>
    /// <param name="_startDate">
    ///     Start date of when the customer was on the list. If the start date is null, then current date is used.
    /// </param>
    /// <param name="_endDate">
    ///     End date of when the customer was on the list. If the start date is null, then current date is used.
    /// </param>
    /// <returns>
    ///     true if an approved item variant for the customer in the list; otherwise, false.
    /// </returns>
    public static boolean existValidItemForCustomer(CustAccount _custAccount, ItemId _itemId, ValidFromDate _startDate = dateNull(), ValidToDate _endDate = dateNull())
    {
        PIPApprovedCustomerList pipApprovedCustomerList;

        if (_custAccount && _itemId && isConfigurationkeyEnabled(configurationKeyNum(PIPACL)))
        {
            InventTable inventTable = InventTable::find(_itemId);
            if (inventTable)
            {
                CustTable custTable = CustTable::find(_custAccount);
    
                date fromDate = _startDate == dateNull() ? DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) : _startDate;
                date toDate   = _endDate   == dateNull() ? fromDate : _endDate;
    
                // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
                // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)
                select firstOnly validTimeState(fromDate, toDate) RecId
                    from pipApprovedCustomerList
                    where ((pipApprovedCustomerList.CustomerCode        == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == custTable.AccountNum)
                            || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == custTable.PIPApprovedCustomerGroup)
                            || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''))
                        && ((pipApprovedCustomerList.ItemCode           == TableGroupAll::Table     && pipApprovedCustomerList.ItemRelation     == inventTable.ItemId)
                            || (pipApprovedCustomerList.ItemCode        == TableGroupAll::GroupId   && pipApprovedCustomerList.ItemRelation     == inventTable.PIPApprovedItemGroup)
                            || (PIPApprovedCustomerList.ItemCode        == TableGroupAll::All       && pipApprovedCustomerList.ItemRelation     == ''));
            }
        }
    
        return pipApprovedCustomerList.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existValidVariantForCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a value indicating if an approved item variant exists for a cutomer.
    /// </summary>
    /// <param name="_custAccount">
    ///     The customer account number.
    /// </param>
    /// <param name="_itemId">
    ///     The item ID.
    /// </param>
    /// <param name="_startDate">
    ///     Start date of when the customer was on the list. If the start date is null, then current date is used.
    /// </param>
    /// <param name="_endDate">
    ///     End date of when the customer was on the list. If the start date is null, then current date is used.
    /// </param>
    /// <returns>
    ///     true if an approved item variant exists for the customer in the list; otherwise, false.
    /// </returns>
    public static boolean existValidVariantForCustomer(CustAccount _custAccount, ItemId _itemId, ValidFromDate _startDate = dateNull(), ValidToDate _endDate = dateNull())
    {
        boolean variantApprovalExists = false;

        if (_custAccount && _itemId && isConfigurationkeyEnabled(configurationKeyNum(PIPACL)))
        {
            InventTable inventTable = InventTable::find(_itemId);
            if (inventTable.hasProductDimensions())
            {
                CustTable custTable = CustTable::find(_custAccount);
    
                date fromDate = _startDate == dateNull() ? DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) : _startDate;
                date toDate   = _endDate   == dateNull() ? fromDate : _endDate;
    
                // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
                // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)

                // First check if there is any variant specific approval enabled
                PIPApprovedCustomerList pipApprovedCustomerList;
                select firstOnly validTimeState(fromDate, toDate) RecId
                    from pipApprovedCustomerList
                    where ((pipApprovedCustomerList.CustomerCode        == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == custTable.AccountNum)
                            || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == custTable.PIPApprovedCustomerGroup)
                            || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''))
                        && (pipApprovedCustomerList.ItemCode            == TableGroupAll::Table     && pipApprovedCustomerList.ItemRelation     == inventTable.ItemId)
                        && pipApprovedCustomerList.InventDimId          != InventDim::inventDimIdBlank();

                variantApprovalExists = pipApprovedCustomerList.RecId != 0;

                if (variantApprovalExists)
                {
                    // If any matching item group or item 'All' exists for this customer and item then variant specific approval not actually required, so return false.
                    select firstOnly validTimeState(fromDate, toDate) RecId
                        from pipApprovedCustomerList
                        where ((pipApprovedCustomerList.CustomerCode        == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == custTable.AccountNum)
                                || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == custTable.PIPApprovedCustomerGroup)
                                || (pipApprovedCustomerList.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''))
                            && ((pipApprovedCustomerList.ItemCode           == TableGroupAll::GroupId   && pipApprovedCustomerList.ItemRelation     == inventTable.PIPApprovedItemGroup)
                                || (pipApprovedCustomerList.ItemCode        == TableGroupAll::All       && pipApprovedCustomerList.ItemRelation     == ''));

                    variantApprovalExists = pipApprovedCustomerList.RecId == 0;
                }
            }
        }
    
        return variantApprovalExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds a <c>PIPApprovedCustomerList</c> record based on its record ID.
    /// </summary>
    /// <param name="_pipApprovedCustomerListRecId">
    ///     The record ID to find.
    /// </param>
    /// <param name="_validFrom">
    ///     Effective starting date. Optional.
    /// </param>
    /// <param name="_validTo">
    ///     Effective end date. Optional.
    /// </param>
    /// <param name="_forUpdate">
    ///     Determines whether the found record should be selected for update. Optional.
    /// </param>
    /// <returns>
    ///     Returns a <c>PIPApprovedCustomerList</c> record.
    /// </returns>
    public static PIPApprovedCustomerList find(
        PIPApprovedCustomerListRecId    _pipApprovedCustomerListRecId,
        ValidFromDate                   _validFrom  = dateNull(),
        ValidToDate                     _validTo    = dateMax(),
        boolean                         _forUpdate  = false
        )
    {
        PIPApprovedCustomerList pipApprovedCustomerList;
    
        pipApprovedCustomerList.selectForUpdate(_forUpdate);
        select firstOnly validTimeState(_validFrom, _validTo) pipApprovedCustomerList
            where pipApprovedCustomerList.RecId == _pipApprovedCustomerListRecId;
    
        return pipApprovedCustomerList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getApprovedItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves all items approved for a customer.
    /// </summary>
    /// <param name="_custTable">
    ///     The customer to check.
    /// </param>
    /// <param name="_startDate">
    ///    The start date for the validation check.
    /// </param>
    /// <param name="_endDate">
    ///    The end date for the validation check; optional. If not specified, <paramref name="_startDate"/> is used as the end date.
    /// </param>
    /// <param name="_approvedItemsToPopulate">
    ///    A reference to a <c>TmpPIPApprovedItems</c> buffer to load the records into; optional.
    /// </param>
    /// <param name="_itemFilterStr">
    ///    A lookup filter string used to restrict the item Id for the items to include in the result; optional.
    /// </param>
    /// <returns>
    ///     A <c>TmpPIPApprovedItems</c> table with a list of the approved items.
    /// </returns>
    server static TmpPIPApprovedItems getApprovedItems(
        CustTable           _custTable,
        ValidFromDate       _startDate,
        ValidToDate         _endDate = dateNull(),
        TmpPIPApprovedItems _approvedItemsToPopulate = null,
        str                 _itemFilterStr = ''
        )
    {
        InventTable                 inventTable;
        InventTable                 inventTableTmp;
        TmpPIPApprovedItems         approvedItems;
        PIPApprovedCustomerListView pipApprovedCustomerListView;
        date                        fromDate;
        date                        toDate;

        approvedItems.linkPhysicalTableInstance(_approvedItemsToPopulate);
    
        fromDate = _startDate == dateNull() ? DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) : _startDate;
        toDate   = _endDate   == dateNull() ? fromDate : _endDate;
    
        // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
        // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)
        while select ItemId, PIPApprovedItemGroup, Product from inventTable
            exists join pipApprovedCustomerListView
                where ((pipApprovedCustomerListView.ItemCode            == TableGroupAll::Table     && pipApprovedCustomerListView.ItemRelation     == inventTable.ItemId)
                        || (pipApprovedCustomerListView.ItemCode        == TableGroupAll::GroupId   && pipApprovedCustomerListView.ItemRelation     == inventTable.PIPApprovedItemGroup)
                        || (pipApprovedCustomerListView.ItemCode        == TableGroupAll::All       && pipApprovedCustomerListView.ItemRelation     == ''))
                    && ((pipApprovedCustomerListView.CustomerCode       == TableGroupAll::Table     && pipApprovedCustomerListView.CustomerRelation == _custTable.AccountNum)
                        || (pipApprovedCustomerListView.CustomerCode    == TableGroupAll::GroupId   && pipApprovedCustomerListView.CustomerRelation == _custTable.PIPApprovedCustomerGroup)
                        || (pipApprovedCustomerListView.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerListView.CustomerRelation == ''))
                    && (_itemFilterStr == '' || inventTable.ItemId like _itemFilterStr + '*')
        {
            PIPApprovedCustomerList pipApprovedCustomerListPriorityRecord = PIPApprovedCustomerList::getPriorityRelation(
                                            _custTable.AccountNum,
                                            _custTable.PIPApprovedCustomerGroup,
                                            inventTable.ItemId,
                                            inventTable.PIPApprovedItemGroup);

            if (pipApprovedCustomerListPriorityRecord.RecId)
            {
                PIPApprovedCustomerList pipApprovedCustomerList = pipApprovedCustomerListPriorityRecord.getEffectiveAtSamePriorityLevel(fromDate, toDate);

                if (pipApprovedCustomerList.RecId)
                {
                    inventTableTmp                  = InventTable::find(inventTable.ItemId);
                    approvedItems.ItemId            = inventTable.ItemId;
                    approvedItems.ItemName          = inventTableTmp.defaultProductName();
                    approvedItems.NameAlias         = inventTable.NameAlias;
                    approvedItems.ItemType          = inventTable.ItemType;
                    approvedItems.ItemCode          = pipApprovedCustomerList.ItemCode;
                    approvedItems.ApprovedItemGroup = inventTable.PIPApprovedItemGroup;
                    approvedItems.ValidFrom         = pipApprovedCustomerList.ValidFrom;
                    approvedItems.ValidTo           = pipApprovedCustomerList.ValidTo;
                    approvedItems.insert();
                }
            }
        }
    
        return approvedItems;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getApprovedItemVariants</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves all item variants approved for a customer.
    /// </summary>
    /// <param name="_custTable">
    ///     The customer to check.
    /// </param>
    /// <param name="_inventTable">
    ///     The record from the <c>InventTable</c> table containing the released product master record.
    /// </param>
    /// <param name="_startDate">
    ///    The start date for the validation check.
    /// </param>
    /// <param name="_endDate">
    ///    The end date for the validation check; optional. If not specified, <paramref name="_startDate"/> is used as the end date.
    /// </param>
    /// <param name="_tmpInventDimCombination">
    ///    A reference to a <c>PIPTmpInventDimCombination</c> buffer to load the records into; optional.
    /// </param>
    /// <returns>
    ///     A TempDB instance of the <c>PIPTmpInventDimCombination</c> table with a list of the approved item variants.
    /// </returns>
    public static PIPTmpInventDimCombination getApprovedItemVariants(
        CustTable           _custTable,
        InventTable         _inventTable,
        ValidFromDate       _startDate,
        ValidToDate         _endDate = dateNull(),
        PIPTmpInventDimCombination _tmpInventDimCombination = null)
    {
        date fromDate = _startDate == dateNull() ? DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) : _startDate;
        date toDate   = _endDate   == dateNull() ? fromDate : _endDate;
    
        PIPTmpInventDimCombination tmpInventDimCombination;
        tmpInventDimCombination.linkPhysicalTableInstance(_tmpInventDimCombination);

        // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
        // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)
        InventDimCombination inventDimCombination;
        PIPApprovedCustomerListView pipApprovedCustomerListView;
        while select inventDimCombination
            where inventDimCombination.ItemId                           == _inventTable.ItemId
            exists join pipApprovedCustomerListView
                where ((pipApprovedCustomerListView.ItemCode            == TableGroupAll::Table     && pipApprovedCustomerListView.ItemRelation     == inventDimCombination.ItemId)
                        || (pipApprovedCustomerListView.ItemCode        == TableGroupAll::GroupId   && pipApprovedCustomerListView.ItemRelation     == _inventTable.PIPApprovedItemGroup)
                        || (pipApprovedCustomerListView.ItemCode        == TableGroupAll::All       && pipApprovedCustomerListView.ItemRelation     == ''))
                    && ((pipApprovedCustomerListView.CustomerCode       == TableGroupAll::Table     && pipApprovedCustomerListView.CustomerRelation == _custTable.AccountNum)
                        || (pipApprovedCustomerListView.CustomerCode    == TableGroupAll::GroupId   && pipApprovedCustomerListView.CustomerRelation == _custTable.PIPApprovedCustomerGroup)
                        || (pipApprovedCustomerListView.CustomerCode    == TableGroupAll::All       && pipApprovedCustomerListView.CustomerRelation == ''))
        {
            InventDim inventDimCriteria = inventDimCombination.inventDim();
            PIPApprovedCustomerList pipApprovedCustomerListPriorityRecord = PIPApprovedCustomerList::getPriorityRelation(
                                            _custTable.AccountNum,
                                            _custTable.PIPApprovedCustomerGroup,
                                            _inventTable.ItemId,
                                            _inventTable.PIPApprovedItemGroup,
                                            inventDimCriteria);
    
            if (pipApprovedCustomerListPriorityRecord.RecId)
            {
                PIPApprovedCustomerList pipApprovedCustomerList = pipApprovedCustomerListPriorityRecord.getEffectiveAtSamePriorityLevel(fromDate, toDate, inventDimCriteria);

                if (pipApprovedCustomerList.RecId)
                {
                    tmpInventDimCombination.ItemId                  = inventDimCombination.ItemId;
                    tmpInventDimCombination.DistinctProductVariant  = InventDimCombination.DistinctProductVariant;
                    tmpInventDimCombination.InventDimId             = inventDimCombination.InventDimId;
                    tmpInventDimCombination.RetailVariantId         = inventDimCombination.RetailVariantId;
                    tmpInventDimCombination.insert();
                }
            }
        }
    
        return tmpInventDimCombination;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEffectiveAtSamePriorityLevel</Name>
				<Source><![CDATA[
    private PIPApprovedCustomerList getEffectiveAtSamePriorityLevel(date _fromDate, date _toDate, InventDim _inventDimCriteria = null)
    {
        PIPApprovedCustomerList pipApprovedCustomerList;

        if (this.InventDimId != InventDim::inventDimIdBlank() && _inventDimCriteria)
        {
            InventDimParm inventDimCriteriaParm = _inventDimCriteria.toDimParm();
            InventDim inventDim;

            select firstonly validTimeState(_fromDate, _toDate) pipApprovedCustomerList
                where pipApprovedCustomerList.ItemRelation      == this.ItemRelation
                    && pipApprovedCustomerList.ItemCode         == this.ItemCode
                    && pipApprovedCustomerList.CustomerRelation == this.CustomerRelation
                    && pipApprovedCustomerList.CustomerCode     == this.CustomerCode
                #InventDimExistsJoinAllowBlank(pipApprovedCustomerList.InventDimId, inventDim, _inventDimCriteria, inventDimCriteriaParm, inventDimCriteriaParm);
        }
        else
        {
            select firstonly validTimeState(_fromDate, _toDate) pipApprovedCustomerList
                where pipApprovedCustomerList.ItemRelation      == this.ItemRelation
                    && pipApprovedCustomerList.ItemCode         == this.ItemCode
                    && pipApprovedCustomerList.CustomerRelation == this.CustomerRelation
                    && pipApprovedCustomerList.CustomerCode     == this.CustomerCode;
        }

        return pipApprovedCustomerList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPriorityRelation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retieves the most applicable <c>PIPApprovedCustomerList</c> record when there are multiple
    ///     records with a relationship between the item and customer via the table/group/all relations.
    /// </summary>
    /// <param name="_custAccount">
    ///     Customer account number.
    /// </param>
    /// <param name="_pipApprovedCustGroupId">
    ///     Approved customer group identification.
    /// </param>
    /// <param name="_itemId">
    ///     Item identification.
    /// </param>
    /// <param name="_pipApprovedItemGroupId">
    ///     Approved item group identification.
    /// </param>
    /// <param name="_inventDim">
    ///     Record from the <c>InventDim</c> table containing the product dimension to restrict the results to. Optional.
    /// </param>
    /// <returns>
    ///     Returns a <c>PIPApprovedCustomerList</c> record.
    /// </returns>
    private static PIPApprovedCustomerList getPriorityRelation(
        CustAccount                 _custAccount,
        PIPApprovedCustomerGroupId  _pipApprovedCustGroupId,
        ItemId                      _itemId,
        PIPApprovedItemGroupId      _pipApprovedItemGroupId,
        InventDim                   _inventDim = null)
    {
        date                        minDate = dateNull();
        date                        lastDate = dateMax();
    
        PIPApprovedCustomerList     pipApprovedCustomerList;
    
        // Important: It's critical to have both ItemCode and ItemRelation as well as both CustomerCode and CustomerRelation specified in each OR
        // clause, otherwise SQL Server may use a Clustered Index Scan (bad -- like a table scan) instead of an Index seek (good)
        if (_inventDim && _inventDim.anyProductDimensionSpecified())
        {
            InventDimParm prodDimParm = _inventDim.toDimParm();
            prodDimParm.clearTrackingDimensions();
            prodDimParm.clearStorageDimensions();

            InventDim inventDim;
            select firstOnly validTimeState(minDate, lastDate) pipApprovedCustomerList
                    order by CustomerCode, ItemCode asc
                    where (pipApprovedCustomerList.ItemCode                 == TableGroupAll::Table     && pipApprovedCustomerList.ItemRelation     == _itemId)
                        && ((pipApprovedCustomerList.CustomerCode           == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == _custAccount)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == _pipApprovedCustGroupId)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''))
                    #InventDimExistsJoinAllowBlank(pipApprovedCustomerList.InventDimId, inventDim, _inventDim, prodDimParm, prodDimParm);

            if (!pipApprovedCustomerList.RecId)
            {
                select firstOnly validTimeState(minDate, lastDate) pipApprovedCustomerList
                    order by CustomerCode, ItemCode asc
                    where ((pipApprovedCustomerList.ItemCode                == TableGroupAll::GroupId   && pipApprovedCustomerList.ItemRelation     == _pipApprovedItemGroupId)
                            || (pipApprovedCustomerList.ItemCode            == TableGroupAll::All       && pipApprovedCustomerList.ItemRelation     == ''))
                        && ((pipApprovedCustomerList.CustomerCode           == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == _custAccount)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == _pipApprovedCustGroupId)
                            || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''));
            }
        }
        else
        {
            select firstonly validTimeState(minDate, lastDate) pipApprovedCustomerList
                order by CustomerCode, ItemCode asc
                where ((pipApprovedCustomerList.ItemCode                == TableGroupAll::Table     && pipApprovedCustomerList.ItemRelation     == _itemId)
                        || (pipApprovedCustomerList.ItemCode            == TableGroupAll::GroupId   && pipApprovedCustomerList.ItemRelation     == _pipApprovedItemGroupId)
                        || (pipApprovedCustomerList.ItemCode            == TableGroupAll::All       && pipApprovedCustomerList.ItemRelation     == ''))
                    && ((pipApprovedCustomerList.CustomerCode           == TableGroupAll::Table     && pipApprovedCustomerList.CustomerRelation == _custAccount)
                        || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::GroupId   && pipApprovedCustomerList.CustomerRelation == _pipApprovedCustGroupId)
                        || (pipApprovedCustomerList.CustomerCode        == TableGroupAll::All       && pipApprovedCustomerList.CustomerRelation == ''));
        }
    
        return pipApprovedCustomerList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs a lookup of items associated with the specified record.
    /// </summary>
    /// <param name="_formStringControl">
    ///     The form string control that will hold the user selected item.
    /// </param>
    /// <param name="_record">
    ///     The record buffer that the list of items are associated with.
    /// </param>
    /// <param name="_filterStr">
    ///     A filter string used to isolate a subset of associated items. Optional.
    /// </param>
    /// <param name="_caller">
    ///     The caller of the lookup. Optional.
    /// </param>
    public static void itemLookup(FormStringControl _formStringControl, Common _record, str _filterStr = '', Object _caller = _formStringControl)
    {
        Args    args;
        FormRun formRun;
    
        args = new Args(formStr(PIPApprovedItemsLookup));
        args.caller(_caller);
        args.record(_record);
        args.parm(_filterStr);
    
        formRun = classfactory.formRunClass(args);
        formRun.init();
    
        _formStringControl.performFormLookup(formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipACLItemLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the ACL item lookup should be skipped.
    /// </summary>
    /// <param name = "_eventArgs">The event args, set to cancelled to skip the ACL item lookup.</param>
    public static void shouldSkipACLItemLookup(PIPItemIdLookupControlEventArgs _eventArgs)
    {
        if (!_eventArgs.parmIsCanceled() && smmParametersTable::find().PIPACLItemLookupMethod == PIPACLItemLookupMethod::Hide)
        {
            _eventArgs.parmIsCanceled(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailVariantId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the retail variant ID for the current record.
    /// </summary>
    /// <returns>
    /// The retail variant ID for the current record.
    /// </returns>
    [SysClientCacheDataMethod]
    public display RetailVariantId retailVariantId()
    {
        if (this.ItemCode == TableGroupAll::Table && this.ItemRelation && this.InventDimId && this.InventDimId != InventDim::inventDimIdBlank())
        {
            return InventDimCombination::find(this.ItemRelation, this.InventDimId).RetailVariantId;
        }
        else
        {
            return '';
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>PIPACL</ConfigurationKey>
	<DeveloperDocumentation>@PIP238</DeveloperDocumentation>
	<FormRef>PIPApprovedCustomerList</FormRef>
	<Label>@PIP205</Label>
	<TitleField1>ItemRelation</TitleField1>
	<TitleField2>CustomerRelation</TitleField2>
	<ClusteredIndex>ApprovedCustomerListIdx</ClusteredIndex>
	<ValidTimeStateFieldType>Date</ValidTimeStateFieldType>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustomerCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustomerRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemRelation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustomerCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustomerRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidTo</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CustomerGroup</Name>
			<Label>@SYS54788</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustomerCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustomerRelation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ItemGroup</Name>
			<Label>@SYS4922</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemRelation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Validity</Name>
			<Label>@PIP237</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidTo</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Inventory</Name>
			<Label>@SYS981</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CustomerCode</Name>
			<Label>@SYS23780</Label>
			<EnumType>TableGroupAll</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustomerRelation</Name>
			<ExtendedDataType>PIPCustRelation</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ItemCode</Name>
			<Label>@SYS58740</Label>
			<EnumType>TableGroupAll</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemRelation</Name>
			<ExtendedDataType>PIPItemRelation</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ValidFrom</Name>
			<ExtendedDataType>ValidFromDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ValidTo</Name>
			<ExtendedDataType>ValidToDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>InventDimId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>ApprovedCustomerListIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<ValidTimeStateKey>Yes</ValidTimeStateKey>
			<ValidTimeStateMode>Gap</ValidTimeStateMode>
			<Fields>
				<AxTableIndexField>
					<DataField>ValidFrom</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CustomerCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CustomerRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ItemCustomerIdx</Name>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CustomerCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CustomerRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValidFrom</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustomerItemIdx</Name>
			<Fields>
				<AxTableIndexField>
					<DataField>CustomerCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CustomerRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValidFrom</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>ApprovedCustomerGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PIPApprovedCustomerGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustomerRelation</Name>
					<Field>CustomerRelation</Field>
					<RelatedField>ApprovedCustomerGroup</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>CustomerCode</Name>
					<Field>CustomerCode</Field>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ApprovedItemGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PIPApprovedItemGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemRelation</Name>
					<Field>ItemRelation</Field>
					<RelatedField>ApprovedItemGroup</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ItemCode</Name>
					<Field>ItemCode</Field>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustomerRelation</Name>
					<Field>CustomerRelation</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>CustomerCode</Name>
					<Field>CustomerCode</Field>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ItemCode</Name>
					<Field>ItemCode</Field>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemRelation</Name>
					<Field>ItemRelation</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimId1</Name>
					<Field>InventDimId</Field>
					<RelatedField>InventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>