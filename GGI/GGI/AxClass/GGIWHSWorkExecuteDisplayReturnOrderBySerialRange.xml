<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>GGIWHSWorkExecuteDisplayReturnOrderBySerialRange</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Handles the logic behind the RF flow used to manage return orders for a range or serials.
/// </summary>
[WHSWorkExecuteMode(WHSWorkExecuteMode::GGIReturnOrderBySerialRange)]
public class GGIWHSWorkExecuteDisplayReturnOrderBySerialRange extends WHSWorkExecuteDisplay
{
    int64 numberOfReturnDispositionCodes;
	private WMSLocationId suggestedPickPutLocationId;

    #define.SerialEnd('SerialRangeEnd')
 
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>processControl</Name>
				<Source><![CDATA[
    public boolean processControl(WhsControl _control, str _value)
    {
        
        switch (true)
        {
            case _control is WhsControlItemId:
                return this.processItemIdForReturnOrderReceiving(_control);
        }

        return super(_control, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for Return Order screen.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    container buildReturnOrder(container _con)
    {
        container       ret = _con;

        ret += [this.buildControl(#RFLabel, "@SYS105841", pass.exists(#MenuItem) ? WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfTitle : '', 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (pass.exists(#RMANum) && pass.lookup(#RMANum) != '')
        {
            ret += [this.buildControl(#RFText, #RMANum, "@WAX3259", 1, pass.lookup(#RMANum), #WHSRFUndefinedDataType, '', 0, 0)];
            
            if (pass.exists(#SerialId) && pass.lookup(#SerialId) != '')
            {
                ret += [this.buildControl(#RFText, #SerialId, "@GGI:TTB006_080", 1, '', extendedTypeNum(InventSerialId), '', 0, 0)];

                ret += [this.buildControl(#RFText, #SerialEnd, "@GGI:TTB006_081", 1, '', extendedTypeNum(InventSerialId), '', 0)];
 
                ret += [this.buildControl(#RFText, #Qty, "@SYS105177", 1, '', #WHSRFUndefinedDataType, '', 0)];
            
                if (pass.exists(#ItemId))
                {
                    WHSInventTable whsInventTable = WHSInventTable::find(pass.lookup(#ItemId));
                    InventTable inventTable       = InventTable::find(pass.lookup(#ItemId));
                    SalesTable salesTable         = SalesTable::findReturnItemNum(pass.lookup(#RMANum));

                    InventDim inventDim           = this.getReturnOrderLineInventDim(salesTable, inventTable);
                
                    ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookupStr(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, 0)];

                    if (whsInventTable.rfDescription1)
                    {
                        ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
                    }
                    else
                    {
                        ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", inventTable.defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
                    }

                    if (whsInventTable.rfDescription2)
                    {
                        ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
                    }

                }

                ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, '', #WHSRFUndefinedDataType, '', 0)];

                ret  = this.buildDispositon(ret, pass.lookupStr(#Disposition), true, numberOfReturnDispositionCodes > 1);
            }
			else
            {
                ret += [this.buildControl(#RFText, #SerialId, "@GGI:TTB006_080", 1, '', extendedTypeNum(InventSerialId), '', 0)];
            }
        }
        else
        {
            ret += [this.buildControl(#RFText, #RMANum, "@WAX3259", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnOrderSalesSerial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls for return order serial number capturing.
    /// </summary>
    /// <param name = "_con">Container containing the form state before the controls are added.</param>
    /// <param name = "_itemId">ID of the item for which serial numbers are captured</param>
    /// <returns>Container containing the form state after the controls are added.</returns>
    protected container buildReturnOrderSalesSerial(
        container   _con,
        ItemId      _itemId)
    {
        FieldId         fieldId;
        FieldName       fieldName;
        DictField       dictField;
        container       ret = _con;

        fieldId     = fieldNum(InventDim, InventSerialId);
        fieldName   = fieldId2name(tableNum(InventDim), fieldId);
        dictField   = new DictField(tableNum(InventDim), fieldId);

        ret += [this.buildControl(#RFText, #ItemId, "@SYS111673", 1, _itemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        ret += [this.buildControl(#RFLabel,
                                  #SerialCounter,
        strFmt("@WAX3121", pass.lookup(#SerialCounter), pass.lookupNum(#SerialQty), InventTable::find(_itemId).inventUnitId()),
                                  1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, fieldName, dictField.label(), 1, pass.lookupStr(fieldName), dictField.typeId(), '', 0)];

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFSerialUnreadable, "@SYS4030029", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnOrderTrackingDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for tracking dimensions of Return Order screen.
    /// </summary>
    /// <param name="_con">
    /// The form state before the controls are added.
    /// </param>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_defaultQty">
    /// The default quantity of the item.
    /// </param>
    /// <returns>
    /// The form state after the controls are added.
    /// </returns>
    protected container buildReturnOrderTrackingDimensions(
        container   _con,
        ItemId      _itemId,
        Qty         _defaultQty)
    {
        container           ret = _con;
        WHSInventTable      whsInventTable;
        ListEnumerator      le;
        str                 qtyString;
        boolean             enable;

        whsInventTable = WHSInventTable::find(_itemId);
        qtyString = WHSWorkExecuteDisplay::num2StrDisplay(_defaultQty);

        InventDim inventDimReturn;
        if (this.countAllReturnOrderLines(SalesTable::findReturnItemNum(pass.lookup(#RMANum)).SalesId) == 1)
        {
            inventDimReturn = this.getReturnOrderLineInventDim(SalesTable::findReturnItemNum(pass.lookup(#RMANum)), InventTable::find(_itemId));
        }

        InventDim inventDimLocal;
        inventDimLocal.inventBatchId = pass.exists(#BatchId) ? pass.lookupStr(#BatchId)  : inventDimReturn.inventBatchId;
        inventDimLocal.inventSerialId = pass.exists(#SerialId) ? pass.lookupStr(#SerialId) : inventDimReturn.inventSerialId;
        inventDimLocal.InventGtdId_RU = pass.exists(#GtdId_RU) ? pass.lookupStr(#GtdId_RU) : inventDimReturn.InventGtdId_RU;
        inventDimLocal.InventProfileId_RU = pass.exists(#ProfileId_RU) ? pass.lookupStr(#ProfileId_RU) : inventDimReturn.InventProfileId_RU;
        inventDimLocal.InventOwnerId_RU = pass.exists(#OwnerId_RU) ? pass.lookupStr(#OwnerId_RU) : inventDimReturn.InventOwnerId_RU;

        ret += [this.buildControl(#RFLabel, "@GGI:TTB006_075", "@GGI:TTB006_075", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, pass.lookup(#ItemId), extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (whsInventTable.rfDescription1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", whsInventTable.rfDescription1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(whsInventTable.ItemId).defaultProductName()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
        }

        if (whsInventTable.rfDescription2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", whsInventTable.rfDescription2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
        }

        ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookup(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0, false)];

        le = InventDimGroupSetup::newDimensionGroups(0, 0, InventTable::find(_itemId).trackingDimensionGroup()).activeFields().getEnumerator();

        while (le.moveNext())
        {
            if (!this.mustShowInventoryDimension(le.current()))
            {
                continue;
            }

            switch (le.current())
            {
                case fieldNum(InventDim, InventBatchId):
                    enable = inventDimLocal.inventBatchId ? !InventBatch::exist(pass.lookup(#ItemId), inventDimLocal.inventBatchId) : true;
                    ret += [this.buildControl(#RFText, #BatchId, "@SYS53635", 1, inventDimLocal.inventBatchId, extendedTypeNum(InventBatchId), '', 0, false)];
                    break;

                case fieldNum(InventDim, InventSerialId):
                    ret += [this.buildControl(#RFText, #SerialId, "@GGI:TTB006_080", 1, inventDimLocal.inventSerialId, extendedTypeNum(InventSerialId), '', 0, false)];
                    break;

                default:
                    ret += [this.buildControlForTableField(tableNum(InventDim),
                                                            le.current(),
                                                            fieldId2name(tableNum(InventDim), le.current()),
                                                            1,
                                                            inventDimLocal.(le.current()),
                                                            true)];
                    break;
            }
        }

        ret += [this.buildControl(#RFText, #SerialEnd, "@GGI:TTB006_081", 1, pass.lookupStr(#SerialEnd), extendedTypeNum(InventSerialId), '', 0, false)];

        ret += [this.buildControl(#RFText, #Qty, "@SYS105177", 1, qtyString, extendedTypeNum(Qty), '', 0, false)];
        
        ret = this.buildTrackingDimReceiptUOM(ret, '', false, true, pass.lookupStr(#DimUOM), false);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnOrderSerialNumberControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds control for serial number.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the control is added.
    /// </param>
    /// <param name="_itemId">
    /// The item number.
    /// </param>
    /// <param name="_inventSerialId">
    /// The serial number.
    /// </param>
    /// <returns>
    /// The form state after the control is added.
    /// </returns>
    private container buildReturnOrderSerialNumberControl(container _con, ItemId _itemId, InventSerialId _inventSerialId)
    {
        container ret = _con;

        if (WHSInventTable::captureSerial(_itemId) == WHSRFWhenToCapture::Receiving)
        {
            if (_inventSerialId)
            {
                ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, _inventSerialId, extendedTypeNum(InventSerialId), '', 0)];
            }
            else
            {
                ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, '', extendedTypeNum(InventSerialId), '', 0)];
            }
        }
        else
        {
            ret += [this.buildControl(#RFText, #SerialId, "@WAX1614", 1, _inventSerialId, extendedTypeNum(InventSerialId), '', 0, _inventSerialId ? !InventSerial::exist(pass.lookup(#ItemId), _inventSerialId) : true)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks dimensions for a sales order line.
    /// </summary>
    /// <param name = "_salesLine">The sales order line.</param>
    protected void checkDimensions(SalesLine _salesLine)
    {
        if (_salesLine.InventTransIdReturn)
        {
            InventBatchId   batchId = pass.lookupStr(#BatchId);
            InventSerialId  serialId = pass.lookupStr(#SerialId);
        
            if (batchId || serialId)
            {
                if (!InventLookupReturn::validateInventSerialBatchIdReturn(serialId, batchId, _salesLine.InventTransIdReturn, _salesLine.ItemId))
                {
                    if (batchId && !InventLookupReturn::validateInventSerialBatchIdReturn('', batchId, _salesLine.InventTransIdReturn, _salesLine.ItemId))
                    {
                        throw error(strFmt("@SYP4881857", batchId));
                    }
            
                    if (serialId && !InventLookupReturn::validateInventSerialBatchIdReturn(serialId, '', _salesLine.InventTransIdReturn, _salesLine.ItemId))
                    {
                        throw error(strFmt("@SYP4881858", serialId));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDispositionAction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if sales line associated with return order are set to credit only and if so, throw error
    /// </summary>
    /// <param name="_salesTable">
    ///    The sales table record found in displayForm
    /// </param>
    /// <exception cref="Exception::Error">
    ///    If the sales line found has a disposition action of Credit Only, throw error
    /// </exception>
    public void checkDispositionAction(SalesTable    _salesTable)
    {
        SalesLine                   creditOnlySalesLine;
        ReturnDispositionCode       returnDispositionCode;

        while select creditOnlySalesLine
            where creditOnlySalesLine.SalesId                 == _salesTable.SalesId
                && creditOnlySalesLine.ItemId                 == pass.lookup(#ItemId)
                && creditOnlySalesLine.ReturnStatus           == ReturnStatusLine::Awaiting
            outer join RecId, DispositionAction, DispositionCodeId from returnDispositionCode
                where returnDispositionCode.DispositionCodeId == creditOnlySalesLine.ReturnDispositionCodeId
        {
            if (returnDispositionCode.RecId == 0
                || returnDispositionCode.DispositionAction != DispositionAction::CreditOnly)
            {
                break;
            }
        }

        if (!creditOnlySalesLine)
        {
            throw error("@WAX4783");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkStatusAndDispositionCode</Name>
				<Source><![CDATA[
    private void checkStatusAndDispositionCode(SalesLine _salesLine)
    {
        WHSDispositionCode  dispositionCode = pass.lookupStr(#Disposition);
        WHSDispositionTable disposition;

        disposition.InventStatusId = _salesLine.inventDim().InventStatusId;
        disposition.ReturnDispositionCodeId = WHSDispositionTable::find(dispositionCode).ReturnDispositionCodeId;

        if (!disposition.isInventoryStatusValid())
        {
            throw error(strFmt("@SYP4881859", disposition.InventStatusId, dispositionCode));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>countReturnOrderLines</Name>
				<Source><![CDATA[
    private int64 countReturnOrderLines(SalesId _salesId)
    {
        SalesLine   returnLine;

        select count(RecId) from returnLine
            where  returnLine.SalesId        == _salesId
                && returnLine.ItemId         == pass.lookup(#ItemId)
                && returnLine.ReturnStatus   == ReturnStatusLine::Awaiting
                && returnLine.ExpectedRetQty <  0;

        return returnLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countAllReturnOrderLines</Name>
				<Source><![CDATA[
    private int64 countAllReturnOrderLines(SalesId _salesId)
    {
        SalesLine   returnLine;

        select count(RecId) from returnLine
        where  returnLine.SalesId        == _salesId
            && returnLine.ItemId         == pass.lookup(#ItemId)
            && returnLine.ExpectedRetQty <  0;

        return returnLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReceiptDetailDimension</Name>
				<Source><![CDATA[
    private InventDim createReceiptDetailDimension(WHSInventStatusId _inventStatusId, InventSerialId _serialId)
    {
		InventDim receiptInventDim;

		receiptInventDim = pass.createInventDimFromPass();
		receiptInventDim.InventSerialId = _serialId;
		receiptInventDim.wmsLocationId = InventLocation::find(receiptInventDim.InventLocationId).wmsLocationIdDefaultReceipt;
		receiptInventDim.InventStatusId = _inventStatusId;
		receiptInventDim = InventDim::findOrCreate(receiptInventDim);

		return receiptInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayForm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Controls the form displayed for return order processing
    /// </summary>
    /// <param name="_con">
    ///    Container that holds information from the RF entries
    /// </param>
    /// <param name="_buttonClicked">
    ///    Button clicked by user action
    /// </param>
    /// <returns>
    ///    Container holding information for next RF screen update
    /// </returns>
    public container displayForm(container _con, str _buttonClicked = '')
    {
        container                   ret = conNull();
        container                   con = _con;
        int                         hasError = 0;
        WHSRFPassthrough            fieldValues = new WHSRFPassthrough(Types::String, Types::String);
        WHSWorkExecuteDisplay       workExecuteDisplay = WHSWorkExecuteDisplay::construct(mode);
        container                   tmpFieldValues;
        boolean                     complete;
        boolean                     recall;
        WHSWorkCreateReturnOrder    workCreateReturnOrder;
        SalesTable                  salesTable;
        SalesLine                   salesLine;
        WHSWorkBuildId              workBuildId;
        WhsWorkExecute              workExecute = WhsWorkExecute::construct();
        WHSMenuItemName             menuItem;
        WHSRFPassthrough            tmpMap;
        container                   tmpPass;
        int                         tmpStep;
        InventSerialId              serialId;
        boolean                     salesSerialProcess;
        ReturnItemNum               returnItemNum;

        pass = WHSRFPassthrough::create(conPeek(_con, 2));

        hasError = this.hasError(_con);

        salesSerialProcess = InventTable::find(pass.lookupStr(#ItemId)).isSalesProcessSerialActive();

        this.processButtonClicked(_buttonClicked);

        WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookupStr(#MenuItem));
        boolean continueToNextStep;

        switch (step)
        {
            case 0:
                if (pass.exists(#WorkComplete))
                {
                    ret = this.addErrorLabel(ret, "@WAX866", WHSRFColorText::Success);
                    pass.remove(#WorkComplete);

                    ret = this.addClusterMessages(ret);
                }

                ret = this.buildReturnOrder(ret);
                step = 1;
                break;

            case 1:
                if (hasError)
                {
                    con = this.removeErrorMessages(con);
                }

                [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                ret += this.buildReturnOrder(ret);
                [ret, complete] = this.processFieldValues(ret, fieldValues);
                step = 2;
                break;

            case 2:
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }


                if (pass.exists(#SerialId))
                {
                    this.getDetailsBySerial(pass.lookupStr(#SerialId));
                }

                if (pass.exists(#SerialEnd))
                {
                    this.validateSerialRangeEnd(pass.lookupStr(#SerialEnd));
                }
                
                if (pass.exists(#SerialEnd) && pass.exists(#Qty) && pass.lookupStr(#Qty) != '')
                {
                    this.validateSerialRangeQty();
                }

                if (pass.exists(#SerialCounter)
                    &&  _buttonClicked != #RFSerialUnreadable
                    &&  pass.lookupStr(#SerialId) == '')
                {
                    ret = con;
                    ret = conIns(ret, 3, this.buildControl(#RFLabel, #RFError, "@WAX3128", 1, '', 0, '', 0, false, '', WHSRFColorText::Error));
                    break;
                }

                if (pass.exists(#ItemId)
                    && pass.exists(#SerialEnd)
                    && pass.lookup(#ItemId) != ''
                    && !pass.exists(#SerialCounter))
                {
                    salesTable  = SalesTable::findReturnItemNum(pass.lookup(#RMANum));

                    this.checkDispositionAction(salesTable);

                    while select salesLine
                        where salesLine.SalesId         == salesTable.SalesId
                            && salesLine.ItemId         == pass.lookup(#ItemId)
                            && salesLine.ReturnStatus   == ReturnStatusLine::Awaiting
                            && salesLine.ExpectedRetQty <  0
                    {
                        if (InventSite::allowReceiptAtOtherWarehouse(salesLine.inventDim().InventLocationId, pass.lookup(#InventLocationId)))
                        {
                            break;
                        }
                    }

                    if (salesLine.RecId == 0)
                    {
                        throw error("@WAX1239");
                    }
                }

                ret += this.buildReturnOrder(ret);

                [ret, complete] = this.processFieldValues(ret, fieldValues);

                if (complete && this.isWorkCreationDataEntryComplete() && pass.hasValue(#UOM))
                {
                    salesLine = this.getReturnOrderLine(true, pass.exists(#SerialCounter));
                        
                    if (salesLine.RecId == 0)
                    {
                        throw error("@WAX3284");
                    }
                    this.checkStatusAndDispositionCode(salesLine);

                    if (!pass.exists(#ReceiptId))
                    {
                        pass.insert(#ReceiptId, NumberSeq::newGetNum(WHSParameters::numRefWHSReceiptId()).num());
                    }

                    if (this.captureTrackingDimensions(pass.lookup(#ItemId))
                    &&  !WHSReceiptDetails::existByReceiptIdLicensePlate(pass.lookup(#ReceiptId), pass.lookup(#LicensePlateId)))
                    {
                        ret = conNull();
                        ret = this.buildReturnOrderTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#Qty));
                        step = 3;
                        pass.insert(#DimRunningQty, WHSCatchWeightHelper::convertInventQuantity(pass.lookup(#ItemId),
                                                                                           pass.lookup(#UOM),
                                                                                           pass.lookupNum(#Qty),
                                                                                           this.createReceiptDetailDimension(this.getReturnOrderLine().inventDim().InventStatusId, '').InventDimId));
                        break;
                    }
                    else if (salesSerialProcess && !pass.exists(#AssignSerial))
                    {
                        step = 3;
                        break;
                    }

                    ret = conNull();

                    if (pass.exists(#SerialId))
                    {
                        serialId = pass.lookup(#SerialId);
                    }

                    // Batch and serial should not be used when processing work
                    this.resetTrackingDimensionsPassValues();

                    if (!pass.exists(#SerialCounter))
                    {
                        ttsbegin;

                        workCreateReturnOrder = new WHSWorkCreateReturnOrder(salesLine);
                        workCreateReturnOrder.parmInventLocationId(pass.lookup(#InventLocationId));
                        workCreateReturnOrder.parmInventQty(WHSCatchWeightHelper::convertInventQuantity(salesLine.ItemId,
                                                                                                   pass.lookup(#UOM),
                                                                                                   pass.lookupNum(#Qty),
                                                                                                   this.createReceiptDetailDimension(salesLine.inventDim().InventStatusId, '').InventDimId));

                        //workCreateReturnOrder.parmWeight(pass.lookupNum(WHSWorkExecuteDisplayCatchWeightControls::CatchWeight));
                        workCreateReturnOrder.parmCreatedBy(curUserId());
                        workCreateReturnOrder.parmTargetLicensePlateId(pass.lookup(#LicensePlateId));
                        workCreateReturnOrder.parmReturnItemNum(pass.lookup(#RMANum));
                        workCreateReturnOrder.parmDispositionCode(pass.lookupStr(#Disposition));
                        workCreateReturnOrder.parmReceiptId(pass.lookup(#ReceiptId));

                        workBuildId = workCreateReturnOrder.createWork();

                        // If salesSerialProcess, AX will not continue executing the code, but go into a recursive call,
                        // variable workCreateReturnOrder and workBuildId be disposed.
                        // save it to pass. Ax can access it in  later if condition
                        pass.insert(#CanCreateWork, workCreateReturnOrder.canCreateWork() ? 1 : 0);
                        pass.insert(#WorkBuildId, workBuildId);

                        ttscommit;

                        if (salesSerialProcess)
                        {
                            pass.insert(#SerialId, '');
                            pass.insert(#SerialCounter, 1);
                            pass.insert(#SerialQty, pass.lookupNum(#Qty));

                            ret = conNull();
                            ret = this.buildReturnOrderSalesSerial(ret, pass.lookup(#ItemId));
                            step = 2;

                            break;
                        }
                    }
                    else if (salesSerialProcess)
                    {
                        InventTrackingRegisterTrans::createFromSerial(serialId, this.getReturnOrderLine(true, true).InventTransId, _buttonClicked == #RFSerialUnreadable, true);

                        if (pass.lookupNum(#SerialCounter) < pass.lookupNum(#SerialQty))
                        {
                            pass.insert(#SerialCounter, pass.lookupNum(#SerialCounter) + 1);

                            ret = conNull();
                            ret = this.buildReturnOrderSalesSerial(ret, pass.lookup(#ItemId));
                            step = 2;

                            break;
                        }
                    }

                    ttsBegin;

                    if (pass.exists(#CanCreateWork) && pass.lookupNum(#CanCreateWork))
                    {
                        workLine = WHSWorkTable::getFirstWorkLineByWorkBuildId(workBuildId, userId);
                        // Assign serial is completed, remove it
                        pass.remove(#AssignSerial);

                        workLine = WHSWorkTable::getFirstWorkLineByWorkBuildId(pass.lookup(#WorkBuildId), userId);

                        if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                        {
                            throw error("@WAX1459");
                        }
                        workTable = workLine.whsWorkTable();

                        if (workLine)
                        {
                            pass.insert(#DetermineStep, 1);
                            menuItem = pass.lookup(#MenuItem);
                            con = this.updateModeStepPass(con, mode, step, pass);
                            [ret, step , recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, suggestedPickPutLocationId, _buttonClicked, false);
                            pass = new WHSRFPassthrough(Types::String, Types::String);
                            pass = WHSRFPassthrough::create(tmpPass);

                            pass.insert(#MenuItem, menuItem);

                            if (step == #Restart)
                            {
                                step = 0;
                            }
                            else if (step == #StepOne)
                            {
                                step = 1; 
                                pass.insert(#DetermineStep, 1);
                            }

                            con = this.updateModeStepPass(ret, mode, step, pass);
                            con = conPoke(con, 1, [mode, step]);
                            workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                            ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                            pass = new WHSRFPassthrough(Types::String, Types::String);
                            pass = WHSRFPassthrough::create(conPeek(ret, 2));
                            pass.insert(#DoingWork, 1);
                            if (pass.exists(#WorkId) && pass.exists(#LineNum))
                            {
                                workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                                if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                                {
                                    throw error("@WAX1459");
                                }
                                workTable = workLine.whsWorkTable();
                            }
                        }
                    }
                    else
                    {
                        returnItemNum = pass.lookup(#RMANum);
                        pass = this.resetPassthrough(_con, false); 
                        pass.insert(#WorkComplete, 1);
                        pass.insert(#RMANum, returnItemNum);

                        [continueToNextStep, ret] = this.assigningPutawayCluster(ret, workBuildId, 0, menuItemTable);

                        if (!continueToNextStep)
                        {
                            con = conPoke(con, 2, pass.pack());
                            step = 0;
                            workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                            ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                            pass = new WHSRFPassthrough(Types::String, Types::String);
                            pass = WHSRFPassthrough::create(conPeek(ret, 2));
                        }
                    }
                    ttscommit;
                }
                break;

            case 3:
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

    
                if (hasError)
                {
                    ret = con;
                    ret = this.buildTrackingDimReceiptUOM(conDel(ret, conLen(ret) - 2, 3), '', false, true, pass.lookupStr(#DimUOM));
                    ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
                    break;
                }

                //con = this.buildReturnOrderTrackingDimensions(ret, pass.lookup(#ItemId), pass.lookupNum(#DimRunningQty));

                if (!fieldValues.empty())
                {
                    [ret, complete] = this.processFieldValues(con, fieldValues);

                    salesLine = this.getReturnOrderLine();

                    InventHandlingQty dimHandlingQty;

                    if (complete)
                    {
                        //catch weight does not support sales serial
                        if (salesSerialProcess)
                        {
                            pass.insert(#AssignSerial, 1);

                            InventDimId dimId = this.createReceiptDetailDimension(salesLine.inventDim().InventStatusId, '').inventDimId;
                            
                            InventQty   dimQty = InventTableModule::unitConvert(pass.lookup(#ItemId),
                                                                                ModuleInventPurchSales::Invent,
                                                                                pass.lookup(#UOM),
                                                                                pass.lookupNum(#Qty),
                                                                                dimId);

                            WHSReceiptDetails::createOrUpdateReceiptDetails(
                                pass.lookup(#ReceiptId),
                                dimId,
                                dimQty);

                            if (this.captureTrackingDimensions(pass.lookup(#ItemId)))
                            {
                                pass.insert(#DimRunningQty, pass.lookupNum(#DimRunningQty) - dimQty);
                            }
                        }
                        else
                        {
                            this.checkDimensions(salesLine);
                            
                            WHSCapturedWeight calcWeight;
                            dimHandlingQty = pass.lookupNum(#DimQty);

                            InventSerial inventSerialReceipt;

                            while select inventSerialReceipt
									index hint ItemSerialIdx
                                    where inventSerialReceipt.ItemId == pass.lookupStr(#ItemId)
										&& inventSerialReceipt.InventSerialId >= pass.lookupStr(#SerialId)
										&& inventSerialReceipt.InventSerialId <= pass.lookupStr(#SerialEnd)
                            {
                                InventDim receiptDetailsInventDim = this.createReceiptDetailDimension(salesLine.inventDim().InventStatusId, inventSerialReceipt.InventSerialId);

								// Insert or update receiving detail record
								WHSReceiptDetails::createOrUpdateReceiptDetails(
									pass.lookup(#ReceiptId),
									receiptDetailsInventDim.InventDimId,
									dimHandlingQty);
                            }

                            pass.insert(#DimRunningQty, pass.lookupNum(#DimRunningQty) - dimHandlingQty);

                            step = 2;

                            ret = this.updateModeStepPass(ret, mode, step, pass);
                            ret = this.displayForm(ret);
                        }
                    }

                    if (pass.exists(#DisplayBatch))
                    {
                        pass.remove(#DisplayBatch);
                    }
                }
                break;
                
            case #SortReceive:
                ret = this.stepSortReceive(con, _buttonClicked);
                break;

            default:
                if (pass.exists(#WorkId))
                {
                    if (pass.exists(#LineNum))
                    {
                        workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                    }
                    else
                    {
                        workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), userId);
                    }

                    if (step != #Restart && workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                    {
                        throw error("@WAX1459");
                    }

                    workTable = workLine.whsWorkTable();
                }

                menuItem = pass.lookup(#MenuItem);
                con = conPoke(con, 2, pass.pack());
                tmpMap = pass;
                tmpStep = step;
                [ret, step, recall, tmpPass] = this.processWorkLine(workLine, con, mode, step, userId, suggestedPickPutLocationId, _buttonClicked, false);
                pass = new WHSRFPassthrough(Types::String, Types::String);
                pass = WHSRFPassthrough::create(tmpPass);
                pass = this.combineMaps(tmpMap, pass);

                if (step == #Restart)
                {
                    returnItemNum = pass.lookup(#RMANum);
                    pass = WHSRFPassthrough::newReset(pass);
                    pass.insert(#WorkComplete, 1);
                    pass.insert(#RMANum, returnItemNum);
                    con = conNull();
                    con = this.buildReturnOrder(con);
                    step = 0;
                }
                else if (step == #StepOne)
                {
                    if (!pass.exists(#RebuildForm))
                    {
                        step = #StepMax;
                        pass.insert(#DetermineStep, 1);
                    }
                    else
                    {
                        ret = conNull();
                        ret = this.buildReturnOrder(ret);
                        pass.remove(#RebuildForm);
                        step = 1;
                    }
                }

                if (recall)
                {
                    con = this.updateModeStepPass(con, mode, step, pass);
                    con = conPoke(con, 1, [mode, step]);
                    workExecuteDisplay.setGlobals(mode, step, userId, pass, null);
                    ret = workExecuteDisplay.displayForm(con, _buttonClicked);
                    pass = new WHSRFPassthrough(Types::String, Types::String);
                    pass = WHSRFPassthrough::create(conPeek(ret, 2));
                    if (pass.exists(#WorkId) && pass.exists(#LineNum))
                    {
                        workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                        workTable = workLine.whsWorkTable();
                    }
                }
                break;
        }

        ret = this.updateModeStepPass(ret, mode, step, pass);

        if (step > 2  && pass.exists(#Batchid))
        {
            ret = this.addButtons(ret);
        }
        ret = this.addCancelButton(ret, 1, true);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processButtonClicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the button that was clicked by a user, and prepares
    /// the form information based on the button pressed.
    /// </summary>
    /// <param name="_buttonClicked">
    /// Button clicked by user action
    /// </param>
    protected void processButtonClicked(str _buttonClicked)
    {
        WMSLocationId  newSuggestedPickPutLocationId;
        WhsWorkExecute workExecute = WhsWorkExecute::construct();

        if (_buttonClicked == #RFException)				// Exception
        {
            step = #ReceivingExceptionStep1;
        }
        else if (_buttonClicked == #RFOverride)			// Override
        {
            step = #OverrideStep1;
        }
        else if (_buttonClicked == #RFFull)				// Full (Split)
        {
            step = #SplitWork;
        }
        else if (_buttonClicked == #RFNoLocation)		// Suggest Location (NoLocation)
        {
            workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
            Set excludeLocationId = new Set(Types::String);

            if (pass.exists(#ExcludedLocations))
            {
                excludeLocationId = this.buildLocationListFromStr(pass.lookup(#ExcludedLocations));
            }
            else
            {
                excludeLocationId = this.buildLocationListFromStr(workLine.wmsLocationId);
            }
            
            container tmpCon;

            [newSuggestedPickPutLocationId, tmpCon] = workExecute.findNewLocation(workLine, excludeLocationId);
            excludeLocationId = Set::create(tmpCon);
            pass.insert(#SuggestLocation, 1);
            pass.insert(#ExcludedLocations, this.buildLocationListFromSet(excludeLocationId));
            if (pass.exists(#PrevStep))
            {
                step = pass.lookup(#PrevStep);
            }
            else
            {
                pass.insert(#NoValidation, '1');
            }
        }
        else if (_buttonClicked == #RFSplitPut)
        {
            this.validateSplitPutAllowed();
            step = #SplitPutWork;
        }

        suggestedPickPutLocationId = newSuggestedPickPutLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnOrderLine</Name>
				<Source><![CDATA[
    private SalesLine getReturnOrderLine(
        boolean _matchProductDimensions = true,
        boolean _serialId = false)
    {
        SalesTable                  salesTable  = SalesTable::findReturnItemNum(pass.lookup(#RMANum));
        SalesLine                   returnLine;
        InventDim                   inventDim;
        InventDim                   inventDimCriteria;
        InventDimParm               inventDimParm;
        InventDimParm               inventDimParmAllowBlank;
        InventTransOrigin           transOrigin;
        InventTrackingRegisterTrans trackingTrans;

        if (_matchProductDimensions && InventDimGroupSetup::newItemIdProductDimensionsOnly(pass.lookup(#ItemId)).activeFields().elements())
        {
            inventDimParm.setAllProductDimensions();
        }
        
        inventDimParm.InventLocationIdFlag = NoYes::Yes;
        
        if (pass.exists(#SerialId))
        {
            inventDimParm.InventSerialIdFlag = NoYes::Yes;
            inventDimParmAllowBlank.InventSerialIdFlag = NoYes::Yes;
        }
        
        if (pass.exists(#BatchId))
        {
            inventDimParm.InventBatchIdFlag = NoYes::Yes;
            inventDimParmAllowBlank.InventBatchIdFlag = NoYes::Yes;
        }
        
        pass.initInventDimFromPassParm(inventDimCriteria, inventDimParm);

        InventSite::setReceivingWarehouseCriteria(inventDimCriteria, inventDimParm);

        if (_serialId)
        {
            // Select the first SalesLine that's registered and does not have all Serials needed associated to it.
            while select returnLine
                where returnLine.SalesId         == salesTable.SalesId
                    && returnLine.ItemId         == pass.lookup(#ItemId)
                    && returnLine.ReturnStatus   == ReturnStatusLine::Registered
                join RecId from transOrigin
                    where transOrigin.InventTransId == returnLine.InventTransId
                    #InventDimExistsJoinAllowBlank(returnLine.InventDimId, inventDim, inventDimCriteria, inventDimParm, inventDimParmAllowBlank)
            {
                select sum(Qty) from trackingTrans
                    where trackingTrans.InventTransOrigin == transOrigin.RecId;

                if (abs(returnLine.SalesQty) != trackingTrans.Qty)
                {
                    return returnLine;
                }
            }
        }
        else if (pass.exists(#SerialId) || pass.exists(#BatchId))
        {
            returnLine = this.getReturnOrderLineBasedOnMatchingDimensions(salesTable, inventDimCriteria, inventDimParm, inventDimParmAllowBlank);
        }

        if (!returnLine)
        {
            if (!pass.exists(#Qty))
            {
                select firstonly returnLine
                    order by PdsCWExpectedRetQty asc, ExpectedRetQty asc
                    where returnLine.SalesId         == salesTable.SalesId
                        && returnLine.ItemId         == pass.lookup(#ItemId)
                        && returnLine.ReturnStatus   == ReturnStatusLine::Awaiting
                        #InventDimExistsJoinAllowBlank(returnLine.InventDimId, inventDim, inventDimCriteria, inventDimParm, inventDimParmAllowBlank);
            }
            else
            {
                returnLine = this.getReturnOrderLineBasedOnMatchingQuantity(salesTable, inventDimCriteria, inventDimParm, inventDimParmAllowBlank);
            }
        }
        return returnLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkCreationDataEntryComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the user has provided the data needed for work creation.
    /// </summary>
    /// <returns>true if the required data is present; false otherwise.</returns>
    protected boolean isWorkCreationDataEntryComplete()
    {
        return pass.lookupStr(#Disposition) != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        WHSDispositionTable dispositionTable;

        select count(RecId) from dispositionTable
            where dispositionTable.ReturnDispositionCodeId != '';

        numberOfReturnDispositionCodes = dispositionTable.RecId;

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnOrderLineInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>InventDim</c> record needed for the <c>buildReturnOrder</c> method.
    /// </summary>
    /// <param name = "_returnOrder">
    /// The return order.
    /// </param>
    /// <param name = "_item">
    /// The item being returned.
    /// </param>
    /// <returns>The dimensions used for the return order.</returns>
    [Replaceable]
    protected InventDim getReturnOrderLineInventDim(SalesTable _returnOrder, InventTable _item)
    {
        InventDim inventDim;

        if (this.countReturnOrderLines(_returnOrder.SalesId) == 1)
        {
            inventDim  = this.getReturnOrderLine(false).inventDim();
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnOrderLineBasedOnMatchingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Finds the return order line which can cover the return quantity.
    /// </summary>
    /// <param name = "_salesTable">
    ///  The sales header of the return order line.
    /// </param>
    /// <param name = "_inventDimCriteria">
    ///  The inventory dimension criteria.
    /// </param>
    /// <param name = "_inventDimParm">
    ///  The inventory dimension parameter which needs match.
    /// </param>
    /// <param name = "_inventDimParmAllowBlank">
    ///  The inventory dimension parameter which can be blank.
    /// </param>
    /// <returns>
    ///  The suitable return order line.
    /// </returns>
    private SalesLine getReturnOrderLineBasedOnMatchingQuantity(SalesTable       _salesTable,
                                                                InventDim        _inventDimCriteria,
                                                                InventDimParm    _inventDimParm,
                                                                InventDimParm    _inventDimParmAllowBlank)
    {
        SalesLine          returnLine;
        InventDim          inventDim;

        if (pass.hasValue(#UOM))
        {
            Qty retQty = pass.lookupNum(#Qty);

            while select returnLine
                order by PdsCWExpectedRetQty asc, ExpectedRetQty asc // Still need loop because sales unit can be different.
            where returnLine.SalesId        == _salesTable.SalesId
                   && returnLine.ItemId         == pass.lookup(#ItemId)
                   && returnLine.ReturnStatus   == ReturnStatusLine::Awaiting
                   #InventDimExistsJoinAllowBlank(returnLine.InventDimId, inventDim, _inventDimCriteria, _inventDimParm, _inventDimParmAllowBlank)
            {
                
                if (this.isRetQtyCoveredByReturnLine(returnLine, retQty))
                {
                    break;
                }
            }
        }
    
        return returnLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnOrderLineBasedOnMatchingDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Finds the return order line which can cover the return quantity with given dimensions.
    /// </summary>
    /// <param name = "_salesTable">
    ///  The sales header of the return order line.
    /// </param>
    /// <param name = "_inventDimCriteria">
    ///  The inventory dimension criteria.
    /// </param>
    /// <param name = "_inventDimParm">
    ///  The inventory dimension parameter which needs match.
    /// </param>
    /// <param name = "_inventDimParmAllowBlank">
    ///  The inventory dimension parameter which can be blank.
    /// </param>
    /// <returns>
    ///  The suitable return order line.
    /// </returns>
    private SalesLine getReturnOrderLineBasedOnMatchingDimensions(SalesTable       _salesTable,
                                                                 InventDim        _inventDimCriteria,
                                                                 InventDimParm    _inventDimParm,
                                                                 InventDimParm    _inventDimParmAllowBlank)
    {
        SalesLine          returnLine;

        if (pass.hasValue(#UOM))
        {
            Qty retQty = pass.lookupNum(#Qty);

            InventDim          inventDim;
            InventTransOrigin  inventTransOriginReturn;
            InventTrans        inventTransReturn;
            InventDim          inventDimReturn;

            while select returnLine
                order by PdsCWExpectedRetQty asc, ExpectedRetQty asc // Still need loop because sales unit can be different.
            where returnLine.SalesId        == _salesTable.SalesId
                    && returnLine.ItemId         == pass.lookup(#ItemId)
                    && returnLine.ReturnStatus   == ReturnStatusLine::Awaiting
                    #InventDimExistsJoinAllowBlank(returnLine.InventDimId, inventDim, _inventDimCriteria, _inventDimParm, _inventDimParmAllowBlank)
            exists join inventTransOriginReturn
                    where inventTransOriginReturn.InventTransId == returnLine.InventTransIdReturn
                exists join InventDimId from inventTransReturn
                    where inventTransReturn.inventTransOrigin == inventTransOriginReturn.RecId
                #InventDimExistsJoinAllowBlank(inventTransReturn.InventDimId, inventDimReturn, _inventDimCriteria, _inventDimParm, _inventDimParmAllowBlank)
            {
                
                if (this.isRetQtyCoveredByReturnLine(returnLine, retQty))
                {
                    break;
                }
            }
        }
    
        return returnLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetQtyCoveredByReturnLine</Name>
				<Source><![CDATA[
    private boolean isRetQtyCoveredByReturnLine(SalesLine _returnLine, Qty _retQty)
    {
        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        UnitOfMeasureRecId unitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(pass.lookup(#UOM));

        boolean isCWItem = PdsGlobal::pdsIsCWItem(pass.lookup(#ItemId));

        ProductQuantity expectedReturnOrderQty;
        UnitOfMeasureSymbol returnLineUnit;

        if (isCWItem)
        {
            expectedReturnOrderQty = _returnLine.PdsCWExpectedRetQty;
            returnLineUnit = _returnLine.pdsCWUnitId();
        }
        else
        {
            expectedReturnOrderQty = _returnLine.ExpectedRetQty;
            returnLineUnit = _returnLine.SalesUnit;
        }
                
        return (expectedReturnOrderQty <= -releasedProductUnitConverter.convert(_retQty,
                                                        unitOfMeasureRecId,
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(returnLineUnit),
                                                        NoYes::No,
                                                        _returnLine.ItemId,
                                                        _returnLine.InventDimId,
                                                        NoYes::No));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDetailsBySerial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches the inventory transactions to find production records in the status Ordered having the given serial number.
    /// </summary>
    /// <param name = "_serialId">The serial number to search for.</param>
    protected void getDetailsBySerial(InventSerialId _serialId)
    {
        SalesTable salesTable;
        SalesLine salesLine;
        InventSerial inventSerial;
        InventTrans	inventTrans;
        InventDim InventDim;

        salesTable  = SalesTable::findReturnItemNum(pass.lookup(#RMANum));
        
        select firstonly salesLine
                join inventSerial
                    where salesLine.SalesId         == salesTable.SalesId
                        && salesLine.ItemId         == inventSerial.ItemId
                        && inventSerial.InventSerialId == _serialId
						&& salesLine.ReturnStatus   == ReturnStatusLine::Awaiting
                        && salesLine.ExpectedRetQty <  0;

        if (!salesLine.RecId)
        {
            throw error(strFmt("@GGI:TTB006_076", _serialId));
        }

        pass.insert(#ItemId, salesLine.ItemId);
        pass.insert(#StyleId, salesLine.inventDim().InventStyleId);
        pass.insert(#UOM, salesLine.SalesUnit);
        pass.insert(#SerialId, _serialId);

        //find an existing batch for serial number
        select firstonly inventBatchId from inventDim
            join inventTrans
            where inventTrans.ItemId == salesLine.ItemId
                && InventDim.inventDimId == inventTrans.InventDimId
                && InventDim.inventSerialId == _serialId;
  
        if (!inventDim.RecId)
        {
            throw error(strFmt("@GGI:TTB006_077", _serialId));
        }

		pass.insert(#BatchId, inventDim.inventBatchId);
        pass.insert(#DimQty, 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSerialRangeEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches the inventory transactions to find production records in the status Ordered having the given serial number.
    /// </summary>
    /// <param name = "_serialId">The serial number to search for.</param>
    protected void validateSerialRangeEnd(InventSerialId _serialId)
    {
        SalesTable salesTable;
        SalesLine salesLine;
        InventSerial inventSerial;
        InventTrans	inventTrans;
        InventDim InventDim;

        if (!pass.exists(#SerialId))
        {
            throw error(strFmt("@GGI:TTB006_076", _serialId));
        }

        salesTable  = SalesTable::findReturnItemNum(pass.lookup(#RMANum));
        
        select firstonly salesLine
                join inventSerial
                    where salesLine.SalesId         == salesTable.SalesId
                        && salesLine.ItemId         == inventSerial.ItemId
                        && inventSerial.InventSerialId == _serialId
						&& salesLine.ReturnStatus   == ReturnStatusLine::Awaiting
                        && salesLine.ExpectedRetQty <  0;

        if (!salesLine.RecId)
        {
            throw error(strFmt("@GGI:TTB006_076", _serialId));
        }

        if (pass.lookupStr(#SerialId) >= _serialId)
        {
            throw error("@GGI:TTB006_079");
        }


        while select inventSerial
                index hint ItemSerialIdx
                where inventSerial.ItemId == pass.lookupStr(#ItemId)
                    && inventSerial.InventSerialId >= pass.lookupStr(#SerialId)
                    && inventSerial.InventSerialId <= pass.lookupStr(#SerialEnd)
        {
            select firstonly inventBatchId from inventDim
            join inventTrans
            where inventTrans.ItemId == salesLine.ItemId
                && InventDim.inventDimId == inventTrans.InventDimId
                && InventDim.inventBatchId == pass.lookupStr(#BatchId)
                && InventDim.inventSerialId == inventSerial.InventSerialId;
  
            if (!inventDim.RecId)
            {
                throw error(strFmt("@GGI:TTB006_077", inventSerial.InventSerialId));
            }
            
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSerialRangeQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Validates serial range quantity
    /// </summary>
    protected void validateSerialRangeQty()
    {
        int countSerial;

        if (pass.exists(#SerialId) && pass.exists(#SerialEnd))
        {
            countSerial = TTBUtilHelper::countSerialNumberRange(pass.lookupStr(#SerialId), pass.lookupStr(#SerialEnd), pass.lookupStr(#ItemId));
        }

        if (pass.lookupNum(#Qty) != countSerial)
        {
            throw error("@GGI:TTB006_078");
        }

    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>