<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>GGIDumpAndBottlingRecordManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>GGIDumpAndBottlingRecordManager</c> is the main class responsible for capturing and storing specific TTB transactions 
/// pertinent to a Dump and bottling record document.
/// </summary>
public class GGIDumpAndBottlingRecordManager
{
    GGIDumpAndBottlingRecord    dbr;  
    InventTrans                 inventTrans;
    InventTransOrigin           inventTransOrigin;
    InventTable                 inventTable;         
    InventTableModule           inventTableModule;  
    InventDim                   inventDimTrans;
    CostGroupId                 costGroupId;         
    TTBUOMClass                 uomClass;        
    GGITransTypeTxt             transTypeText;
    GGIDumpAndBottlingRecordId  sourceDBRId;
    TTBVPRSerialId              vprSerialId;
    WHSWorkTable                workTable;
    WHSWorkTemplateTable        workTemplateTable;
    WHSWorkLine                 relatedWorkLine;
    WHSWorkLine                 whsWorkLinePICK;
    WHSWorkLine                 whsWorkLinePUT;
    GGIActivityClass            activityClass;  
    WMSLocation                 wmsLocation;
    GGIDumpAndBottlingLine      sourceDBRLine;
    RefRecId                    gaugeRecordRecId;
    GGIDumpAndBottlingRecordId  journalDBRId;
    GGIDumpAndBottlingLine      pickingListDBRLine;
    TTBInventGaugeTable         inventGaugeTable;    
    boolean                     calculateWGFromWorkTemplate;
    boolean                     createFromRAF = true;
    Qty                         prodQty;

    public const str costGroupRM    = 'RM';
    public const str costGroupINT   = 'INT';
    public const str costGroupFG    = 'FG';
    public const str OffBond        = 'OffBond';
    public const str GAL            = 'GAL';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of this class from and inventory transaction record.
    /// </summary>
    /// <param name = "inventTrans">
    /// A record from <c>InventTrans</c> table.
    /// </param>
    /// <returns>
    /// An instance of class <c>GGIDumpAndBottlingRecordManager</c> class.
    /// </returns>
    public static GGIDumpAndBottlingRecordManager constructFromInventTrans(InventTrans inventTrans)
    {
        GGIDumpAndBottlingRecordManager dbrRManager = new GGIDumpAndBottlingRecordManager();

        dbrRManager.parmInventTrans(inventTrans);

        return dbrRManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTrans</Name>
				<Source><![CDATA[
    public InventTrans parmInventTrans(InventTrans _inventTrans = InventTrans)
    {
        inventTrans = _inventTrans;

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProdQty</Name>
				<Source><![CDATA[
    public Qty parmProdQty(Qty _prodQty = prodQty)
    {
        prodQty = _prodQty;

        return prodQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGaugeRecord</Name>
				<Source><![CDATA[
    public RefRecId parmGaugeRecord(RefRecId _gaugeRecordRecId)
    {
        gaugeRecordRecId = _gaugeRecordRecId;
        
        select firstonly inventGaugeTable
            where inventGaugeTable.RecId == _gaugeRecordRecId;

        return gaugeRecordRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWMSLocation</Name>
				<Source><![CDATA[
    public WMSLocation parmWMSLocation(WMSLocation _wmsLocation = wmsLocation)
    {
        wmsLocation = _wmsLocation;

        return wmsLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateFromRAF</Name>
				<Source><![CDATA[
    public boolean parmCreateFromRAF(boolean _createFromRAF = createFromRAF)
    {
        createFromRAF = _createFromRAF;

        return createFromRAF;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDBR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates entries in the DBR tables.
    /// </summary>
    public void createDBR()
    {
        boolean createNewDBR;
        InventTrans inventTransLocal;

        this.initValues();       

        if (!GGIDumpAndBottlingLine::findByInventTrans(inventTrans.RecId).RecId && this.validateForDBR())
        {
            ttsbegin;

            // for inventory adj journals, post to earliest open DBR vs newest
            if (inventTransOrigin.ReferenceCategory == InventTransType::InventLossProfit)
            {
                dbr = GGIDumpAndBottlingRecord::findEarliestForSiteLocation(inventDimTrans.InventSiteId, wmsLocation.wMSLocationId);
            }
            else if (inventTransOrigin.ReferenceCategory == InventTransType::ProdLine)
            {
                dbr = GGIDumpAndBottlingRecord::findEarliestForBatchOrder(inventTransOrigin.ReferenceId, inventDimTrans.InventSiteId, wmsLocation.wMSLocationId);

                if (!dbr)
                {
                    dbr = GGIDumpAndBottlingRecord::findCurrentForSiteLocation(inventDimTrans.InventSiteId, wmsLocation.wMSLocationId);
                }
            }
            else
            {
                dbr = GGIDumpAndBottlingRecord::findCurrentForSiteLocation(inventDimTrans.InventSiteId, wmsLocation.wMSLocationId);
            }            

            if (journalDBRId)
            {
                dbr = GGIDumpAndBottlingRecord::find(journalDBRId);
            }

            createNewDBR = !dbr
                            || (dbr
                                && (transTypeText       == GGITransactionTypes::UnloadToTank
                                    || transTypeText    == GGITransactionTypes::FGDumpToBulk
                                    || transTypeText    == GGITransactionTypes::BatchFromDBR
                                    || (transTypeText   == GGITransactionTypes::TransferFromDBR
                                        && calculateWGFromWorkTemplate)));

            // subsequent RAF's need not create new DBR's.
            if (dbr && transTypeText == GGITransactionTypes::BatchFromDBR && this.hasEarlierRAF())
            {
                createNewDBR = false;
            }
           
            // create new DBR or every offfload and other conditions above
            if (createNewDBR)         
            {
                dbr = GGIDumpAndBottlingRecord::createDBR(inventDimTrans.InventSiteId, wmsLocation.wMSLocationId);
            }
            
            if (transTypeText && dbr)
            {
                this.createLine();

                if (sourceDBRLine)
                {
                    switch (inventTransOrigin.ReferenceCategory)
                    {
                        case InventTransType::WHSWork:
                            this.updateRelatedDBRLineWork();
                            break;
                        case InventTransType::Production:
                            this.updateRelatedDBRLineProduction();
                            break;
                    } 
                }

                if (gaugeRecordRecId)
                {
                    this.updateGaugeRecord();
                }
            }
            
            ttscommit;
        }    
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasEarlierRAF</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a RAF has already occured for the batch order and was handled by DBR.
    /// </summary>
    /// <returns>
    /// True, if RAF'd earlier; otherwise, false.
    /// </returns>
    public boolean hasEarlierRAF()
    {
        GGIDumpAndBottlingLine  rafDBRLine;

        select firstonly rafDBRLine
            where rafDBRLine.ReferenceId            == inventTransOrigin.ReferenceId
                && rafDBRLine.ReferenceCategory     == InventTransType::Production
                && rafDBRLine.InventTransRefRecId   != inventTrans.RecId;

        return (rafDBRLine.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Dump and bottling record lines.
    /// </summary>
    private void createLine()
    {
        GGIDumpAndBottlingLine  dbrLine;
        InventQty               inventQty = inventTrans.Qty;
        InventTrans             inventTransLocal;

        if (activityClass == GGIActivityClass::Dump)
        {            
            if (prodQty)
            {
                inventQty = abs(prodQty);
            }
            else
            {
                inventQty = abs(inventQty);
            }
        }
        else if (activityClass == GGIActivityClass::Removal)
        {
            switch (inventTransOrigin.ReferenceCategory)
            {
                case InventTransType::ProdLine:
                    switch (inventTrans.StatusIssue)
                    {
                        case StatusIssue::Deducted  :
                            inventQty =abs(inventQty) * -1;
                            break;
                        case StatusIssue::Sold  :
                            inventQty =abs(inventQty) * -1;
                            break;                        
                    }
                    break;
                case InventTransType::InventLossProfit:
                    inventQty = inventQty;
                    break;
                default:
                    inventQty =abs(inventQty) * -1;
            }           
        }   

        dbrLine.DBRId               = dbr.DBRId;
        dbrLine.TransDate           = inventTrans.DatePhysical? inventTrans.DatePhysical : DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
        dbrLine.InventTransRefRecId = inventTrans.RecId;   
        dbrLine.InventDimId         = inventTrans.inventDimId;
        dbrLine.Qty                 = inventQty;
        dbrline.ReferenceId         = inventTransOrigin.ReferenceId;
        dbrLine.ReferenceCategory   = inventTransOrigin.ReferenceCategory;
        dbrLine.ItemId              = inventTrans.ItemId;
        dbrLine.Proof               = transTypeText == GGITransactionTypes::UnloadToTank? this.qualityOrderProof() : inventTable.TTBProof;
        dbrLine.VPRSerialId         = vprSerialId? vprSerialId : '';  
        dbrLine.WineGallon          = inventTrans.inventUnit() == GAL? inventQty : TTBWineGalConversion::find(dbrLine.Proof).WineGALEquivalent * inventQty;
        dbrLine.ProofGallon         = TTBUtilHelper::convertWineGallon2Proof(dbrLine.WineGallon, dbrLine.Proof);
        dbrLine.InventGaugeId       = inventGaugeTable? inventGaugeTable.InventGaugeId : '';
        
        // field from trans type
        dbrLine.TransTypeTxt    = sourceDBRLine? strFmt(transTypeText, sourceDBRLine.DBRId) : transTypeText;
        dbrLine.ActivityClass   = activityClass;
        
        if (dbrLine.Qty)
        {
            dbrLine.insert();
        }
        // Durirng TTB offloading and tank tarnsfer (both inv movement) update gauge recordings
        if (whsWorkLinePICK 
            && whsWorkLinePICK.whsWorkTable().WorkTransType == WHSWorkTransType::Invent
            && activityClass == GGIActivityClass::Dump)
        {
            this.updatePreviousDBR();
        }            

        // For Production PURE to PURE transfer scenario, creates additional line for PURE gain/loss after RAF DBR line is created
        if (pickingListDBRLine && createFromRAF)
        {
            this.createAdjustmentForPureGainLoss(dbrLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes several values that are retreived from inventory transaction record.
    /// </summary>
    private void initValues()
    {
        inventTransOrigin       = inventTrans.inventTransOrigin();
        inventDimTrans          = inventTrans.inventDim();        
        inventTable             = inventTrans.inventTable();
        inventTableModule       = inventTable.inventTableModuleInvent();
        costGroupId             = inventTable.CostGroupId;
        uomClass                = UnitOfMeasure::findBySymbol(inventTableModule.UnitId).TTBUOMClass;
        
        if (inventTransOrigin.ReferenceCategory != InventTransType::WHSWork)
        {
            wmsLocation = inventDimTrans.wmsLocation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForDBR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validations to check if transactions qualify to be captured by the DBR functionality and
    /// deetermines the type of transaction.
    /// </summary>
    /// <returns>
    /// True, if validations passed; otherwise, false.
    /// </returns>
    public boolean validateForDBR()
    {
        TTBAlcoholType  rafItemAlcoholType;  
        inventTrans     pickingListTrans;
        InventTable     rafInventTable;
        inventTable     pickingListInventTable;
        ProdTable       prodTable;
        TTBUOMClass     rafItemUOMClass;
        CostGroupId     rafCostGroupId;
        CostGroupId     pickingCostGroupId;
         
        boolean isLocationDBRControlled         = wmsLocation && wmsLocation.GGIDBRControlled;  
        boolean isClassBulkAndCostGrpRMOrINT    = (uomClass == TTBUOMClass::Bulk
                                                    && (costGroupId == costGroupRM
                                                        || costGroupId == costGroupINT));
        
        // For work transactions, the loccation comes from work line and is already checked for. For Production transaction as well, 
        // check is not done until very end as picking list DBR's still need to be created.
        if (!isLocationDBRControlled
            && !(inventTransOrigin.ReferenceCategory    == InventTransType::WHSWork
                || inventTransOrigin.ReferenceCategory  == InventTransType::Production))
        {
            return false;
        }

        switch (inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::WHSWork   :
                WMSLocation workLocationForPick;
                wmsLocation workLocationForPUT;
                WHSZone     zone;
                if (WHSWorkTable::find(inventTransOrigin.ReferenceId).WorkTransType == WHSWorkTransType::Invent)                   
                {
                    this.findWorkLine();

                    workTable                   = relatedWorkLine.whsWorkTable();
                    workTemplateTable           = WHSWorkTemplateTable::find(workTable.WorkTemplateCode, workTable.WorkTransType);
                    calculateWGFromWorkTemplate = workTemplateTable.GGICalculateGaugeWineGallon;

                    switch (relatedWorkLine.WorkType)
                    {
                        case WHSWorkType::Pick  :
                            if (isClassBulkAndCostGrpRMOrINT)
                            {
                                this.findWorkLinePUT();
                                workLocationForPUT  = WMSLocation::find(whsWorkLinePUT.WMSLocationId, whsWorkLinePUT.inventDim().InventLocationId);                                
                                activityClass       = GGIActivityClass::Removal;
                                transTypeText       = workLocationForPUT.GGIDBRControlled? GGITransactionTypes::TransferToDBR : GGITransactionTypes::RemoveForInternalUse;
                            }
                            break;                        
                        case WHSWorkType::Put   :
                            this.findWorkLinePICK();
                            workLocationForPick = WMSLocation::find(whsWorkLinePICK.WMSLocationId, whsWorkLinePICK.inventDim().InventLocationId);
                            zone                = WHSZone::find(workLocationForPick.ZoneId);
                            activityClass       = GGIActivityClass::Dump;

                            // TTB Offload scenario                            
                            if (costGroupId == costGroupRM 
                                && workLocationForPick.GGILocationType      == GGIWMSLocationType::RailcarOrTruck
                                && wmsLocation.GGILocationType   == GGIWMSLocationType::Tank
                                && wmsLocation.GGIDBRControlled)
                            {
                                transTypeText = GGITransactionTypes::UnloadToTank;                            
                            }
                            else if (zone.ZoneGroupId == OffBond)
                            {
                                transTypeText = GGITransactionTypes::ReturnReceipt;
                               
                                this.findRelatedDBRLineWork();
                            }
                            else if (isClassBulkAndCostGrpRMOrINT)
                            {
                                transTypeText = GGITransactionTypes::TransferFromDBR;
                               
                                this.findRelatedDBRLineWork();
                            }
                            break;
                    }
                }
                break;       
            case InventTransType::Production    :  
                // first, log transactions from consumption
                if (createFromRAF)
                {
                    this.createFromRAFAction();
                }                

                pickingListTrans        = inventTrans.ggiPickingListTrans();
                pickingListInventTable  = pickingListTrans.inventTable();
                pickingCostGroupId      = pickingListInventTable.CostGroupId;

                // Picking list lines have been logged, so okay to not run code for RAF lines if non-DBR controlled.
                if (!inventTrans.ggiIsLocationDBRControlled())
                {
                    return false;
                }

                activityClass   = GGIActivityClass::Dump;

                if (pickingListInventTable.CostGroupId == costGroupFG)
                {
                    transTypeText = GGITransactionTypes::FGDumpToBulk;                    
                }
                else if (isClassBulkAndCostGrpRMOrINT
                            && inventTable.TTBAlcoholType()     == TTBAlcoholType::PURE
                            && pickingListInventTable.TTBAlcoholType() == TTBAlcoholType::PURE
                            && pickingListTrans.ggiUOMClass()   == TTBUOMClass::Bulk
                            && pickingListTrans.ggiIsLocationDBRControlled()                            
                            && (pickingCostGroupId              == costGroupRM
                                || pickingCostGroupId           == costGroupINT))
                {
                    transTypeText   = GGITransactionTypes::BatchFromDBR;
                    
                    this.findRelatedDBRLineProduction();               
                }
                if (pickingListInventTable.TTBAlcoholType()     == TTBAlcoholType::PURE
                    && pickingListTrans.ggiUOMClass()           == TTBUOMClass::Bulk
                    && (pickingListInventTable.CostGroupId      == costGroupRM
                        || pickingListInventTable.CostGroupId   == costGroupINT)
                    && inventTable.TTBAlcoholType()             == TTBAlcoholType::PURE
                    && isClassBulkAndCostGrpRMOrINT)
                {
                    pickingListDBRLine = GGIDumpAndBottlingLine::findByInventTrans(pickingListTrans.RecId); 
                }  
                GGIInventTrans  inventTransLocal;
                InventTable     inventTableLocal = InventTable::find(inventTrans.ItemId);

                select firstonly AlcoholType, TTBUOMClass
                    from inventTransLocal
                        where inventTransLocal.InventTrans == inventTrans.RecId;

                if (transTypeText == ''
                        && (inventTableLocal.CostGroupId == costGroupRM
                            || inventTableLocal.CostGroupId == costGroupINT)
                        && inventTransLocal.AlcoholType == TTBAlcoholType::PURE
                        && inventTransLocal.TTBUOMClass == TTBUOMClass::Bulk)
                {
                    transTypeText = GGITransactionTypes::FGDumpToBulk;
                }
                this.findVPRSerialId();
                break;
            case InventTransType::ProdLine    :                
                prodTable           = ProdTable::find(inventTransOrigin.ReferenceId);
                rafInventTable      = prodTable.inventTable();
                rafItemAlcoholType  = rafInventTable.TTBAlcoholType();
                rafItemUOMClass     = UnitOfMeasure::findBySymbol(rafInventTable.inventTableModuleInvent().UnitId).TTBUOMClass;
                rafCostGroupId      = rafInventTable.CostGroupId;
                activityClass       = GGIActivityClass::Removal;
             
                if (rafItemAlcoholType == TTBAlcoholType::PURE)
                { 
                    if (rafCostGroupId == costGroupFG)
                    {
                        switch (rafItemUOMClass)
                        {
                            case TTBUOMClass::Bottled   :
                                transTypeText = GGITransactionTypes::RemoveToBottling;
                                break;
                            case TTBUOMClass::Packaged  :
                                transTypeText = GGITransactionTypes::RemoveToPackaging;
                                break;
                            case TTBUOMClass::Bulk  :
                                transTypeText = GGITransactionTypes::RemoveToBulk;
                                break;
                        }
                    }
                    // PURE batch scenario
                    if (isClassBulkAndCostGrpRMOrINT
                        && rafItemUOMClass      == TTBUOMClass::Bulk                        
                        && (rafCostGroupId      == costGroupRM 
                            || rafCostGroupId   == costGroupINT))
                    {
                        transTypeText = GGITransactionTypes::TransferToDBR;
                    }     
                }
                else if (rafItemAlcoholType != TTBAlcoholType::none)
                {
                    transTypeText = GGITransactionTypes::RemoveToDenaturing;
                }
            
                this.findVPRSerialId();
                break;         
            case InventTransType::InventTransaction :
            case InventTransType::InventLossProfit :
            case InventTransType::BOMMain :
            case InventTransType::BOMLine :
                InventJournalTable  inventJournalTable  = InventJournalTable::find(inventTransOrigin.ReferenceId);               
                InventJournalName   inventJournalName   = InventJournalName::find(inventJournalTable.JournalNameId);             
                GGITransType        transType           = GGITransType::find(inventJournalName.GGITransTypeTxt);

                if (isClassBulkAndCostGrpRMOrINT)
                {
                    transTypeText   = transType.TransTypeTxt;
                    activityClass   = transType.ActivityClass;
                    journalDBRId    = inventJournalTable.GGIDBRId;
                }                
                break;
                
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromRAFAction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates DBR lines from the Picking list lines when the RAF is processed.
    /// </summary>
    public void createFromRAFAction()
    {        
        GGIInventTrans      ggiInventTrans;
        ProdJournalProd     prodJournalProd;

        while select ggiInventTrans
            where ggiInventTrans.ReferenceCategory      == InventTransType::ProdLine
                && ggiInventTrans.ReferenceId           == inventTransOrigin.ReferenceId
                && ggiInventTrans.AlcoholType           == TTBAlcoholType::PURE
                && (ggiInventTrans.StatusIssue          == StatusIssue::Deducted
                    || ggiInventTrans.StatusIssue       == StatusIssue::Sold
                    || ggiInventTrans.StatusReceipt     == StatusReceipt::Purchased)
        {
            if (ggiInventTrans.InventTrans)
            {
                select firstonly count(RecId) from prodJournalProd
                    where prodJournalProd.ProdId == inventTransOrigin.ReferenceId;

                if (ggiInventTrans.StatusIssue  == StatusIssue::Sold && prodJournalProd.RecId > 1)
                {
                    continue;
                }

                GGIDumpAndBottlingRecordManager dbrManager = GGIDumpAndBottlingRecordManager::constructFromInventTrans(InventTrans::findRecId(ggiInventTrans.InventTrans));
                dbrManager.createDBR();
            }            
        }
        
        // look at other potential lines for RAF as well.
        while select ggiInventTrans
            where ggiInventTrans.ReferenceCategory      == InventTransType::Production
                && ggiInventTrans.ReferenceId           == inventTransOrigin.ReferenceId
                && ggiInventTrans.AlcoholType           == TTBAlcoholType::PURE
                && ggiInventTrans.StatusReceipt         == StatusReceipt::Received
                && ggiInventTrans.InventTrans
                && ggiInventTrans.InventTrans           != inventTrans.RecId
        {
            GGIDumpAndBottlingRecordManager dbrManager = GGIDumpAndBottlingRecordManager::constructFromInventTrans(InventTrans::findRecId(ggiInventTrans.InventTrans));
            dbrManager.parmCreateFromRAF(false);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>RAFLocationDBRControlled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the RAF transaction related to the ciurrent transaction is for a DBR controlled location.
    /// </summary>
    /// <returns>
    /// True, if it is DBR controlled; otherwise, false.
    /// </returns>
    public boolean RAFLocationDBRControlled()
    {
        GGIInventTrans  ggiInventTrans;

        select firstonly ggiInventTrans
            where ggiInventTrans.ReferenceCategory  == InventTransType::Production
                && ggiInventTrans.ReferenceId       == inventTransOrigin.ReferenceId
                && ggiInventTrans.DBRControlled;

        return ggiInventTrans.InventTrans!=0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdjustmentForPureGainLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the adjustment to be posted for the Pure batch gain/loss scenario.
    /// </summary>
    /// <param name = "_rafDBRLine">
    /// The DBR line for the RAF.
    /// </param>
    protected void createAdjustmentForPureGainLoss(GGIDumpAndBottlingLine _rafDBRLine)
    {
        GGIDumpAndBottlingLine  consumptionDBRLine;
        GGIDumpAndBottlingLine  rafDBRLine;
        GGIDumpAndBottlingLine  adjJournalDBRLine;
        InventJournalTable      inventJournalTable;
        TTBProofGallon          totalConsumedProofGallon;
        TTBProofGallon          totalProducedProofGallon;
        TTBProofGallon          alreadyAdjProofGallon;
        TTBProofGallon          gainLossProofGallon;
        TTBWineGallon           gainLossWineGallon;
        Qty                     adjustableQty;   
        UnitOfMeasure           uom                     = UnitOfMeasure::findBySymbol(inventTable.inventUnitId());
        TTBWineGALConversion    wineGallonConversion    = TTBWineGALConversion::find(_rafDBRLine.Proof);

        select sum(ProofGallon) from consumptionDBRLine
            where consumptionDBRLine.ReferenceId        == _rafDBRLine.ReferenceId
                && consumptionDBRLine.ReferenceCategory == InventTransType::ProdLine;

        select sum(ProofGallon) from rafDBRLine
            where rafDBRLine.ReferenceId        == _rafDBRLine.ReferenceId
                && rafDBRLine.ReferenceCategory == InventTransType::Production;

        select sum(ProofGallon) from adjJournalDBRLine
            join inventJournalTable
            where inventJournalTable.GGIDBRId           == adjJournalDBRLine.DBRId
                && inventJournalTable.GGIProdId         == _rafDBRLine.ReferenceId
                && adjJournalDBRLine.ReferenceCategory  == InventTransType::InventLossProfit;
                

        totalConsumedProofGallon    = abs(consumptionDBRLine.ProofGallon);
        totalProducedProofGallon    = abs(rafDBRLine.ProofGallon);
        alreadyAdjProofGallon       = adjJournalDBRLine.ProofGallon;
        gainLossProofGallon         = totalConsumedProofGallon - totalProducedProofGallon - alreadyAdjProofGallon;
        gainLossWineGallon          = (gainLossProofGallon * 100)/ _rafDBRLine.Proof;
        adjustableQty               = decRound(gainLossWineGallon, uom.DecimalPrecision);      

        if (adjustableQty)
        {
            this.createPostInvAdjJournal(adjustableQty, _rafDBRLine);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedDBRLineProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the DBR lines from batch consumption that is associated with the same Production order as the currrent RAF transaction.
    /// </summary>
    private void updateRelatedDBRLineProduction()
    {
        GGIDumpAndBottlingLine consumptionDBRLine;
        
        if (sourceDBRLine)
        {
            ttsbegin;
            while select forupdate consumptionDBRLine
                where consumptionDBRLine.ReferenceCategory  == InventTransType::ProdLine
                    && consumptionDBRLine.ReferenceId       == sourceDBRLine.ReferenceId
            {
                consumptionDBRLine.TransTypeTxt = strFmt(GGITransactionTypes::TransferToDBR, dbr.DBRId);
                consumptionDBRLine.update();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedDBRLineProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the DBR line from batch consumption that is associated with the same Production order as the currrent RAF transaction.
    /// </summary>
    private void findRelatedDBRLineProduction()
    {
        InventTrans pickingListTrans = inventTrans.ggiPickingListTrans();

        sourceDBRLine = GGIDumpAndBottlingLine::findByInventTrans(pickingListTrans.RecId, true);   
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedDBRLineWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the DBRR line from PICK work line that is associated with the same Work as current PUT work line.
    /// </summary>
    private void updateRelatedDBRLineWork()
    {
        if (sourceDBRLine)
        {
            sourceDBRLine.selectForUpdate(true);
            ttsbegin;
            sourceDBRLine.TransTypeTxt = strFmt(GGITransactionTypes::TransferToDBR, dbr.DBRId);
            sourceDBRLine.update();
            ttscommit;
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedDBRLineWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the DBR line from PICK work line that is associated with the same Work as current PUT work line.
    /// </summary>
    private void findRelatedDBRLineWork()
    {  
        select firstonly sourceDBRLine
            where sourceDBRLine.ReferenceId       == inventTransOrigin.ReferenceId
                && sourceDBRLine.ActivityClass    == GGIActivityClass::Removal
                && sourceDBRLine.TransTypeTxt     == GGITransactionTypes::TransferToDBR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVPRSerialId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the relevant Verified prroduction record for the batch consumption transaction.
    /// </summary>
    private void findVPRSerialId()
    {
        TTBVerifiedProdTable        verifiedProdTable       = TTBVerifiedProdTable::findProdId(inventTransOrigin.ReferenceId);
        TTBVerifiedProdSerialTable  verifiedProdSerialTable = verifiedProdTable.ttbVerifiedProdSerialTable();

        vprSerialId = verifiedProdSerialTable.SerialId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the work line associated with the current transaction.
    /// </summary>
    public void findWorkLine()
    {
        WHSWorkInventTrans  whsWorkInventTrans;
        
        select firstonly relatedWorkLine
            where relatedWorkLine.WorkId                    == inventTransOrigin.ReferenceId
            join whsWorkInventTrans
            where relatedWorkLine.LineNum                   == whsWorkInventTrans.LineNum
                && (whsWorkInventTrans.InventTransIdFrom    == inventTransOrigin.InventTransId
                    || whsWorkInventTrans.InventTransIdTo   == inventTransOrigin.InventTransId);

    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkLinePICK</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the PICK work line from the current PUT work line related trransaction.
    /// </summary>
    public void findWorkLinePICK()
    {
        select firstonly whsWorkLinePICK
            where whsWorkLinePICK.WorkId    == inventTransOrigin.ReferenceId
                && WHSWorkLinePICK.WorkType == WHSWorkType::Pick;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkLinePUT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the PUT work line from the current PUT work line related trransaction.
    /// </summary>
    public void findWorkLinePUT()
    {
        select firstonly whsWorkLinePUT
            where whsWorkLinePUT.WorkId     == inventTransOrigin.ReferenceId
                && whsWorkLinePUT.WorkType  == WHSWorkType::Put;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGaugeRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updtaes the DBR link on the Gauge record.create
    /// </summary>
    private void updateGaugeRecord()
    {
        ttsbegin;
        if (dbr && inventGaugeTable)
        {
            inventGaugeTable.selectForUpdate(true);
            inventGaugeTable.DBRId = dbr.DBRId;
            inventGaugeTable.doUpdate();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePreviousDBR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Tank gauging wine gallons on the previous DBR.
    /// </summary>
    private void updatePreviousDBR()
    {
        GGIDumpAndBottlingRecord previousDBR;
        
        select firstonly forupdate previousDBR
            order by RecId desc
            where previousDBR.InventSiteId      == dbr.InventSiteId
                && previousDBR.WMSLocationId    == dbr.WMSLocationId
                && previousDBR.Status           == GGIDumpAndBottlingRecordStatus::Open
                && previousDBR.DBRId            != dbr.DBRId;

        Qty                     qtyInLbs            = workTemplateTable.GGICalculateGaugeWineGallon? workTable.ggiGetOffloadQtyFromStartGaugeAndTmp() : 0;
        TTBWineGallon           wineGallon          = TTBUtilHelper::convert2WineGallon(qtyInLbs, 'lb', inventTrans.ItemId);

        if (workTable && workTemplateTable.GGICalculateGaugeWineGallon && wineGallon)
        {
            ttsbegin;
            if (previousDBR)
            {
                previousDBR.TankGaugingWineGallon = wineGallon;
                if (!previousDBR.TankGaugingProof)
                {
                    previousDBR.TankGaugingProof = dbr.TankGaugingProof;
                }
                previousDBR.update();
            }            

            if (!dbr.UpdatedFromWork)
            {
                dbr = GGIDumpAndBottlingRecord::find(dbr.DBRId, true);
                dbr.BalanceWineGallon   += wineGallon;
                dbr.BalanceProofGallon  += TTBUtilHelper::convertWineGallon2Proof(wineGallon, inventTable.TTBProof);
                dbr.UpdatedFromWork     = true;
                dbr.update();
            }            
            ttscommit;
        }               
    }

]]></Source>
			</Method>
			<Method>
				<Name>ProdJournalTable_Post_update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Triggers DBR creation from posting of production journals.
    /// </summary>
    /// <param name = "args">
    /// The args for the event.
    /// </param>
    [PostHandlerFor(tableStr(ProdJournalTable), tableMethodStr(ProdJournalTable, insert))]
    public static void ProdJournalTable_Post_update(XppPrePostArgs args)
    {
        ProdJournalTable        prodJournalTable    = args.getThis() as ProdJournalTable;
        ProdTable               prodTable           = ProdTable::find(prodJournalTable.ProdId);
        GGIInventTrans          ggiInventTrans,ggiInventTransCon;
        ProdJournalProd         prodJournalProd;

        if (prodJournalTable.JournalType == ProdJournalType::ReportFinished && !prodTable.PmfReworkBatch)
        {
            select firstonly ggiInventTransCon
            where ggiInventTransCon.ReferenceCategory      == InventTransType::ProdLine
                && ggiInventTransCon.ReferenceId           == prodJournalTable.ProdId
                && ggiInventTransCon.AlcoholType           == TTBAlcoholType::PURE
                && (ggiInventTransCon.StatusIssue          == StatusIssue::Deducted
                    || ggiInventTransCon.StatusIssue       == StatusIssue::Sold
                    || ggiInventTransCon.StatusReceipt     == StatusReceipt::Purchased);

            select firstonly QtyGood, InventTransId
                from prodJournalProd
                    where prodJournalProd.JournalId == prodJournalTable.JournalId;

            select firstonly ggiInventTrans
                order by InventTrans desc
                where ggiInventTrans.ReferenceId        == prodJournalTable.ProdId
                    && ggiInventTrans.ReferenceCategory == InventTransType::Production
                    && ggiInventTrans.AlcoholType       != TTBAlcoholType::none;

            if (ggiInventTrans && ggiInventTransCon)
            {
                GGIDumpAndBottlingRecordManager dbrManager = GGIDumpAndBottlingRecordManager::constructFromInventTrans(InventTrans::findRecId(ggiInventTrans.InventTrans));
                dbrManager.parmProdQty(prodJournalProd.QtyGood);

                if (prodJournalProd.qtyGood > 0)
                {
                    dbrManager.createDBR();
                }
                else
                {
                    dbrManager.initValues();
                    dbrManager.createDBRReversal();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDBRReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates reverse entries in the DBR tables.
    /// </summary>
    public void createDBRReversal()
    {
        GGIDumpAndBottlingLine bottlingLine, bottlingLineNew, bottlingLineOld;
        const str reverseVal = ' - Reverse';

        dbr = GGIDumpAndBottlingRecord::findCurrentForSiteLocation(inventDimTrans.InventSiteId, wmsLocation.wMSLocationId);


        select firstonly bottlingLineOld
                        where bottlingLineOld.DBRId == dbr.DBRId
                            && bottlingLineOld.Qty > 0;

        if (bottlingLineOld && bottlingLineOld.dumpAndBottlinigRecord().Status == GGIDumpAndBottlingRecordStatus::Open)
        {
            buf2Buf(bottlingLineOld, bottlingLineNew);
            bottlingLineNew.Qty =  prodQty;
            bottlingLineNew.InventTransRefRecId = inventTrans.RecId;
            bottlingLineNew.WineGallon   = (inventTrans.inventUnit() == GAL? bottlingLineNew.Qty : TTBWineGalConversion::find(bottlingLineNew.Proof).WineGALEquivalent * bottlingLineNew.Qty);
            bottlingLineNew.ProofGallon  = (TTBUtilHelper::convertWineGallon2Proof(bottlingLineNew.WineGallon, bottlingLineNew.Proof));
            bottlingLineNew.TransTypeTxt = bottlingLineNew.TransTypeTxt + reverseVal;

            select firstonly bottlingLine
                        where bottlingLine.InventTransRefRecId == inventTrans.RecId
                            && bottlingLine.TransTypeTxt == bottlingLineNew.TransTypeTxt;
            
            if (!bottlingLine && bottlinglineold)
            {
                bottlingLineNew.insert();
                inventTransOrigin = inventTrans.inventTransOrigin();
                inventTable = InventTable::find(inventTrans.ItemId);
            }
        }

        GGIInventTrans      ggiInventTrans;
        ProdJournalProd     prodJournalProd;

        while select ggiInventTrans
            where ggiInventTrans.ReferenceCategory      == InventTransType::ProdLine
                && ggiInventTrans.ReferenceId           == inventTransOrigin.ReferenceId
                && ggiInventTrans.AlcoholType           == TTBAlcoholType::PURE
                && (ggiInventTrans.StatusIssue          == StatusIssue::Deducted
                    || ggiInventTrans.StatusIssue       == StatusIssue::Sold
                    || ggiInventTrans.StatusReceipt     == StatusReceipt::Purchased)
        {
            if (ggiInventTrans.InventTrans)
            {
                select firstonly RecId from prodJournalProd
                    where prodJournalProd.ProdId == inventTransOrigin.ReferenceId;
                
                if (ggiInventTrans.StatusIssue  == StatusIssue::Sold && prodJournalProd)
                {
                    continue;
                }
                GGIDumpAndBottlingRecordManager dbrManager = GGIDumpAndBottlingRecordManager::constructFromInventTrans(InventTrans::findRecId(ggiInventTrans.InventTrans));
                dbrManager.createDBR();
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>JournalCheckPost_Post_run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Triggers DBR creation from posting of inventory journals.
    /// </summary>
    /// <param name = "args">
    /// The args for the event.
    /// </param>
    [PostHandlerFor(classStr(JournalCheckPost), methodStr(JournalCheckPost, run))]
    public static void JournalCheckPost_Post_run(XppPrePostArgs args)
    {
        JournalCheckPost    journalCheckPost    = args.getThis();
        InventJournalTable  inventJournalTable  = InventJournalTable::find(journalCheckPost.parmJournalId());
        GGIInventTrans      ggiInventTrans;

        if (inventJournalTable.Posted)
        {
            while select ggiInventTrans
                where ggiinventtrans.ReferenceId            == inventJournalTable.JournalId
                    && ggiInventTrans.AlcoholType           == TTBAlcoholType::PURE
                    && ggiInventTrans.DBRControlled
                    && (ggiInventTrans.ReferenceCategory    == InventTransType::InventTransaction
                        || ggiInventTrans.ReferenceCategory == InventTransType::InventLossProfit
                        || ggiInventTrans.ReferenceCategory == InventTransType::BOMMain
                        || ggiInventTrans.ReferenceCategory == InventTransType::BOMLine)
            {
                GGIDumpAndBottlingRecordManager dbrManager = GGIDumpAndBottlingRecordManager::constructFromInventTrans(InventTrans::findRecId(ggiInventTrans.InventTrans));
                dbrManager.createDBR();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>qualityOrderProof</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns proof from associated quality order.
    /// </summary>
    /// <returns>
    /// The quality order proof.
    /// </returns>
    protected TTBProof qualityOrderProof()
    {
        InventQualityOrderTable inventQualityOrderTable;
        InventQualityOrderLine  orderLine;
        PdsBatchAttrib          pdsBatchAttrib;
        InventDim               qoInventDim;  
        TTBProof                proof;

        select firstonly inventQualityOrderTable
            order by RecId desc
            join qoInventDim
            where inventQualityOrderTable.InventDimId           == qoInventDim.inventDimId
                && inventQualityOrderTable.ItemId               == inventTrans.ItemId
                && (inventQualityOrderTable.ReferenceType       == InventTestReferenceType::Purch
                    || inventQualityOrderTable.ReferenceType    == InventTestReferenceType::PIPTransfer)
                && qoInventDim.inventBatchId                    == inventDimTrans.inventBatchId;

        if (!inventQualityOrderTable)
        {
            return 0;
        }

        //see if any of the order lines batch attibutes are for proof
        select firstonly orderLine
                    where orderline.QualityOrderId          == inventQualityOrderTable.QualityOrderId
                    join pdsBatchAttrib
                    where pdsBatchAttrib.PdsBatchAttribId   == orderline.PdsBatchAttribId
                        && pdsBatchAttrib.TTBInventQualityProof;

        if (orderline)
        {
            proof = str2Num(orderLine.PdsAttribValue);
        }

        return proof;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPostInvAdjJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts an inventory adjustment jourrnal.
    /// </summary>
    public void createPostInvAdjJournal(Qty _adjustableQty, GGIDumpAndBottlingLine _rafDBRLine)
    {
        InventJournalTable              inventJournalTable;
        InventJournalTrans              inventJournalTrans;
        InventJournalName               inventJournalName;
        JournalCheckPost                journalCheckPost;      
        InventDim                       inventTransDim  = _rafDBRLine.inventTrans().inventDim();
        const str                       gallon ='GAL';

        select firstonly inventJournalName
            where inventJournalName.JournalNameId   == InventParameters::find().GGIPureBatchGainLossJournalNameId;

        if (!inventJournalName)
        {
            throw error("@GGI:SelectPureGainLossJournalError");
            return;
        }

        try
        {
            ttsbegin;
            inventJournalTable.clear();
            inventJournalTable.initFromInventJournalName(inventJournalName);
            inventJournalTable.GGIDbrId     = _rafDBRLine.DBRId;
            InventJournalTable.GGIProdId    = _rafDBRLine.ReferenceId;
            inventJournalTable.insert();

            inventJournalTrans.clear();
            inventJournalTrans.initFromInventJournalTable(inventJournalTable);
            inventJournalTrans.initFromInventTable(inventTable);
            inventJournalTrans.InventDimId      = inventTransDim.InventDimId;
            inventJournalTrans.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(inventTable.DefaultDimension, inventTransDim.inventSite().DefaultDimension);
            inventJournalTrans.TransDate        = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            inventJournalTrans.Qty              = _adjustableQty;
            inventJournalTrans.UnitQty          = inventJournalTrans.Qty;
                     
            if (inventJournalTrans.Unit != gallon)
            {
                inventJournalTrans.UnitQty          = _adjustableQty;
                inventJournalTrans.Unit = gallon;
                inventJournalTrans.modifyInventJournalTransQty(gallon);
            }
            else if(_adjustableQty < 0)
            {
                inventJournalTrans.CostAmount = inventJournalTrans.CostAmount * -1 ;
            }
            
            inventJournalTrans.insert();
   
            journalCheckPost = InventJournalCheckPost::newPostJournal(inventJournalTable);

            if (journalCheckPost.validate())
            {
                journalCheckPost.runOperation();
            }
    
            ttscommit;
        }
        catch(Exception::Error)
        {
            Info(infolog.text());
            Error("@GGI:PureGainLossAdjJournalError");
        }
       
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>