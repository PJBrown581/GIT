<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SKS_LB_SecondaryMatch</Name>
	<SourceCode>
		<Declaration><![CDATA[
// This class is used to perform secondary invoice matching.
class SKS_LB_SecondaryMatch
{
    SelectableDataArea      TmpCpnyID;
    CustPaymSettlementManager   lSettlementManager;


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>BuildCustomValues</Name>
				<Source><![CDATA[
    static delegate void BuildCustomValues(CustTrans custTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>CheckExistingAR</Name>
				<Source><![CDATA[
    [SuppressBPWarningAttribute("BPCheckSelectForUpdateAbsent","Buffer lSKS_LB_JournalAR is selected forUpdate and is passed to other methods where it is modified.")]
    public SKS_LB_JournalAR CheckExistingAR(CustAccount lCustAccount, container virtualCompanyCompanies, SKS_LB_FormatId formatID, CompanyBankAccountId bankAccount, SKS_LB_Journal lSKS_LB_Journal, DimensionDefault defaultdimension, tmpSKS_LB_Importing tmpRecord)
    {
        CustTable l_CustTable;
        DirPartyTable   dirpartyTable;
        SKS_LB_Bank     tmpSKS_LB_Bank;
        SKS_LB_JournalAR    lSKS_LB_Journalar;

        Select crossCompany:virtualCompanyCompanies AccountNum, Party, DefaultDimension
            from l_CustTable
            join Name
                from dirPartyTable
                WHERE l_CustTable.Party == dirPartyTable.RecId
                    && l_CustTable.AccountNum == lCustAccount;

        select * FROM tmpSKS_LB_Bank
            where tmpSKS_LB_Bank.BankAccountId == bankAccount && tmpSKS_LB_Bank.LBFormatId == formatID;


        DimensionDefault arDefaultDimension = SKS_LB_Process_importTemp_records::LBDimensionMerge(SKS_PP_Setup::find()
                                                                                                    ,DefaultDimension
                                                                                                    ,l_CustTable.DefaultDimension
                                                                                                    ,tmpSKS_lb_bank.LBJournalName
                                                                                                    ,l_CustTable.company());

        if(tmpRecord.ParentRecId == 0)
        {
            Select forUpdate firstOnly lSKS_LB_JournalAR
                where lSKS_LB_JournalAR.Party == dirPartyTable.RecId
                    && lSKS_LB_JournalAR.CustAccount == lCustAccount
                    && lSKS_LB_JournalAR.ChkRefNbr == tmpRecord.CheckNumber
                    && lSKS_LB_JournalAR.JournalId == lSKS_LB_Journal.JournalID
                    && lSKS_LB_JournalAR.Batchnum == lSKS_LB_Journal.Batchnum
                    && lSKS_LB_JournalAR.DefaultDimension == arDefaultDimension
                    && lSKS_LB_Journalar.isDED == NoYes::No
                    && lSKS_LB_Journalar.AresDed == NoYes::no;
        }
        else
        {
            select forUpdate firstOnly lSKS_LB_JournalAR
                    where lSKS_LB_JournalAR.JournalId == lSKS_LB_Journal.JournalID
                        && lSKS_LB_JournalAR.BatchNum == lSKS_LB_Journal.BatchNum
                        && lSKS_LB_JournalAR.CustAccount == lCustAccount
                        && lSKS_LB_Journalar.DefaultDimension == arDefaultDimension
                        && lSKS_LB_Journalar.ParentRecid == tmpRecord.ParentRecid
                        && lSKS_LB_Journalar.ChkRefNbr == tmpRecord.CheckNumber
                        && lSKS_LB_Journalar.isDED == NoYes::No
                        && lSKS_LB_Journalar.AresDed == NoYes::no;
        }

        return lSKS_LB_Journalar;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateMultipleSettlements</Name>
				<Source><![CDATA[
    public SKS_LB_MatchParms CreateMultipleSettlements(TmpSKS_LB_RecordCreation _RecordCreation, TmpSKS_LB_Importing _tmpRecord, SKS_LB_Journalar NewJournalAR, CustAccount _CustAccount, container _virtualCompanyCompanies, currencyCode _CurrencyCode, CompanyBankAccountId _bankAccount, SKS_LB_FormatId _formatID, SKS_LB_MatchParms _MatchParms, SKS_LB_MatchType _MatchType,  boolean _ApplyDiscount = false)
    {
        boolean Multiples = false;
        ttsBegin;
        if(_RecordCreation != Null)
        {
            while select * from _RecordCreation
            {
                this.setApplics(_RecordCreation.Company, _RecordCreation.ctorecid, _RecordCreation.ctorefrecid, _RecordCreation.Amount, _RecordCreation.Discount, _RecordCreation.CTODataAreaId,
                    _RecordCreation.CTInvoiceID, _tmpRecord, _CurrencyCode, _CustAccount, _bankAccount, _formatID, NewJournalAR, _MatchType, _ApplyDiscount);

                this.SetInvoiceNumAsterisk(NewJournalAR, _RecordCreation.CTInvoiceID, multiples);
                multiples = true;
            }
        }
        ttsCommit;

        _MatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::OK);
        _MatchParms.StopMatch(NoYes::Yes);
        _MatchParms.CustomOnAccount(true);
        _MatchParms.PaymenCount(1);
        _MatchParms.JournalARRecId(NewJournalAR.RecId);
        return _MatchParms;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateTempRecord</Name>
				<Source><![CDATA[
    public TmpSKS_LB_RecordCreation CreateTempRecord(TmpSKS_LB_RecordCreation RecordCreation, CustTransOpen CTO,
        AmountCur           CTODiscount,
        InvoiceId           CTInvoiceID,
        DimensionDefault    CTDimension)
    {
        SKS_PP_Setup    lSetup = SKS_PP_Setup::find();

        // SKS_19380_FlintfoxAresInvoiceApplicaiton
        //RecordCreation.Amount = CTO.AmountCur;
        RecordCreation.Amount = CTO.sksGetRemainingAmount();
        // SKS_19380_FlintfoxAresInvoiceApplicaiton
        RecordCreation.CTODataAreaId = CTO.DataAreaID;
        recordCreation.CTORecId = CTO.RecId;
        RecordCreation.CTORefRecid = CTO.RefRecId;
        RecordCreation.Discount = CTODiscount;
        RecordCreation.CTInvoiceID = CTInvoiceID;
        RecordCreation.Company = CTO.Company();
        RecordCreation.DimensionDefault = SKS_LB_Process_IMPORTTEMP_Records::LBDimensionMerge(lSetup, CTDimension, CustTable::find(CTO.AccountNum).DefaultDimension, lSetup.journalName, CTO.Company());
        RecordCreation.insert();
        Return RecordCreation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CustomerAmountToleranceMatching</Name>
				<Source><![CDATA[
    public TmpSKS_LB_RecordCreation CustomerAmountToleranceMatching(AmountCur  _Tolerance, container _virtualCompanyCompanies, currencyCode _currencyCode, custAccount _custAccount, amountCur _InvAmount, TmpSKS_LB_RecordCreation _recordCreation, TmpSKS_LB_Importing _TmpRecord)
    {
        CustTransOpen    localCustTransOpen;
        CustTrans        localCustTrans;
        SpecTrans        localSpecTrans;
        SKS_LB_JournalARApplic  localJournalARApplic;
        SKS_LB_JournalAR        lSKS_LB_JournalAR;
        Tmpsks_lb_RecordCreation    RecordCreation;

        Select crosscompany:_virtualCompanyCompanies localCustTransOpen order by localCustTransOpen.duedate asc
                where localCustTransOpen.AccountNum == _CustAccount
                    && (localCustTransOpen.AmountCur <= _InvAmount + _Tolerance && localCustTransOpen.AmountCur >= _InvAmount - _Tolerance)
            join RecId, Invoice, DefaultDimension from localCustTrans
                where localCustTransOpen.RefRecId == localCustTrans.recid
            notExists join localSpectrans
                where localCustTransOpen.dataareaid == localSpecTrans.RefCompany
                    && localCustTransOpen.TableId == localSpecTrans.reftableid
                    && localCustTransOpen.recid == localSpecTrans.refrecid;

        while(localCustTransOpen)
        {
            if(!this.CustAmtMatchARAlreadyMarked(localCustTransOpen, localCustTrans))//Returns false if NOT marked by another journalAR
            {
                return this.CreateTempRecord(_recordcreation, localcusttransopen, 0, localCustTrans.Invoice, localCustTrans.DefaultDimension);
            }
            else
            {
                next localCustTransOpen;
            }
        }

        // SKS_19380_FlintfoxAresInvoiceApplicaiton
        // TODO: add notexists join to journalAR
        SKS_LB_JournalARApplic journalARApplic;
        SKS_LB_JournalAR journalAR;
        while select crosscompany:_virtualCompanyCompanies localCustTransOpen
                order by DueDate asc
            where localCustTransOpen.AccountNum == _custAccount
                join RecId, Invoice, DefaultDimension from localCustTrans
            where localCustTransOpen.RefRecId == localCustTrans.RecId
               // TODO: think to support credit notes
               && localCustTrans.AmountCur > 0
                join localSpecTrans
            where localSpecTrans.RefCompany == localCustTransOpen.DataAreaId
                && localSpecTrans.RefTableId == localCustTransOpen.TableId
                && localSpecTrans.RefRecId == localCustTransOpen.RecId
                && localSpecTrans.SpecTableId == tableNum(LedgerJournalTrans)
                notexists join localJournalARApplic
            where localCustTransOpen.dataAreaId == journalARApplic.CustTransDataAreaId
               && localCustTransOpen.RecId == journalARApplic.CustTransOpenRecId
               && journalARApplic.SettleAmountCur != 0
               join RecId, LedgerJournalTransRecId from journalAR
            where journalAR.RecId == journalARApplic.SKS_LB_JournalARRecId
               && journalAR.LedgerJournalTransRecId == 0
        {
            changecompany (localSpecTrans.SpecCompany)
            {
                Amount remainingAmount = localCustTransOpen.remainAmountCashDisc();
                if (remainingAmount <= _InvAmount + _Tolerance &&
                    remainingAmount >= _InvAmount - _Tolerance)
                {
                    SKS_PP_Setup lSetup = SKS_PP_Setup::find();
                    _recordcreation.Amount = remainingAmount;
                    _recordcreation.CTODataAreaId = localCustTransOpen.DataAreaID;
                    _recordcreation.CTORecId = localCustTransOpen.RecId;
                    _recordcreation.CTORefRecid = localCustTransOpen.RefRecId;
                    _recordcreation.Discount = 0;
                    _recordcreation.CTInvoiceID = localCustTrans.Invoice;
                    _recordcreation.Company = localCustTransOpen.Company();
                    _recordcreation.DimensionDefault = SKS_LB_Process_IMPORTTEMP_Records::LBDimensionMerge(lSetup, localCustTrans.DefaultDimension, CustTable::find(localCustTrans.AccountNum).DefaultDimension, lSetup.journalName, localCustTrans.company());
                    _recordcreation.insert();

                    return _recordcreation;
                }
            }
        }
        // SKS_19380_FlintfoxAresInvoiceApplicaiton

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CustomerAmountToleranceMatchingIncludeDuplicatInvoices</Name>
				<Source><![CDATA[
    public Tmpsks_lb_RecordCreation CustomerAmountToleranceMatchingIncludeDuplicatInvoices(AmountCur  _Tolerance, container _virtualCompanyCompanies,
        currencyCode _currencyCode, custAccount _custAccount, amountCur _InvAmount, TmpSKS_LB_RecordCreation _recordCreation, TmpSKS_LB_Importing _TmpRecord)
    {
        SpecTrans        localSpecTrans;
        SKS_LB_InvoiceMatch     lSKS_LB_InvoiceMatch;
        SKS_LB_InvoiceMatch     lInvoiceMatch;
        SKS_LB_SecondaryMatch   SKS_LB_SecondaryMatch = new SKS_LB_SecondaryMatch();
        boolean                 lAlreadyMarked = false;

        ;

        Select crosscompany:_virtualCompanyCompanies sum(CTOAmountCur), maxof(CustTransRecId) 
            from lSKS_LB_InvoiceMatch  
            group by CustAccount, CustTransRecId 
            where lSKS_LB_InvoiceMatch.CustAccount == _custAccount &&
                lSKS_LB_InvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward;

        while(lSKS_LB_InvoiceMatch)
        {
            if(lSKS_LB_InvoiceMatch.ctoamountcur <= _InvAmount + _Tolerance && lSKS_LB_InvoiceMatch.ctoamountcur >= _InvAmount - _Tolerance)
            {
                select firstonly crosscompany:_virtualCompanyCompanies lInvoiceMatch join localSpectrans
                    where lInvoiceMatch.dataareaid == localSpecTrans.RefCompany &&
                        tableNum('CustTransOpen') == localSpecTrans.reftableid &&
                        lInvoiceMatch.CustTransOpenRecid == localSpecTrans.refrecid &&
                        lInvoiceMatch.CustTransRecid == lSKS_LB_InvoiceMatch.CustTransRecId &&
                        lInvoiceMatch.direction == SKS_LB_MatchTypeDirection::forward;

                if(!localSpecTrans)
                {
                    while select crosscompany:_virtualCompanyCompanies lInvoiceMatch 
                        where lInvoiceMatch.CustTransRecId == lSKS_LB_InvoiceMatch.CustTransRecId &&
                            lInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward
                    {
                        CustTransOpen   lCustTransOpen = CustTransOpen::find(lInvoiceMatch.CustTransOpenRecId);
                        CustTrans       lCustTrans = CustTrans::find(lCustTransOpen.RefRecId);
                        if(SKS_LB_SecondaryMatch.CustAmtMatchARAlreadyMarked(lCustTransOpen, lCustTrans))//Returns false if NOT marked by another journalAR
                        {
                            lAlreadyMarked = true;
                        }
                        else
                        {
                            ttsbegin;
                            _recordCreation = this.CreateTempRecord(_recordcreation, lCustTransOpen, 0, lCustTrans.Invoice, lCustTrans.DefaultDimension);
                            ttscommit;
                        }
                    }
                }

                if(lAlreadyMarked)
                {
                    _recordCreation = null;
                    next lSKS_LB_InvoiceMatch;
                }
                else
                {
                    return _recordCreation;
                }
            }
            else
            {
                next lSKS_LB_InvoiceMatch;
            }
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindTolerance</Name>
				<Source><![CDATA[
    public amountcur FindTolerance(boolean  _ToleranceEnabled)
    {
        CustParameters  lcustParameters;

        if(_toleranceEnabled)
        {
            lcustparameters = CustParameters::findByCompany(curext());
            return abs(lCustParameters.MaxMSTOverUnder);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>InitARRecord</Name>
				<Source><![CDATA[
    public SKS_LB_JournalAR InitARRecord(CompanyBankAccountId bankAccount, JournalId lbJournalID, SKS_LB_BatchNum _formattedBatNum, str pathFile, Date fileDate, SKS_LB_FormatId formatID, CustAccount _CustAccount, container _virtualCompanyCompanies, TMPSKS_LB_Importing _tmpRecord, AmountCur settleAmount, InvoiceID _InvoiceID = '', DimensionDefault _dimensionDefault = 0)
    {
        SKS_LB_JournalAR    NewJournalAR;
        CompanyId           CpnyId;
        CustTable           l_CustTable;
        DirPartyTable       dirPartyTable;
        SKS_PP_Setup        tmpSetup;
        SKS_LB_Bank         tmpBank;
        ;

        select * from tmpSetup;
        select LBjournalname, LBformatID, bankAccountID from tmpBank where tmpBank.bankaccountID == bankaccount && tmpBank.LBformatid == formatID;

        NewJournalAR.JournalId = lbJournalID;
        NewJournalAR.BatchNum = _formattedBatNum;
        NewJournalAR.FormatID = formatID;
        NewJournalAR.BankAcct = bankAccount;
        NewJournalAR.FileDate = fileDate;
        NewJournalAR.Filename = pathFile;
        newJournalAR.ChkRefNbr = _tmpRecord.CheckNumber;
        newJournalAR.ParentRecid = _tmpRecord.ParentRecid;
        newJournalAR.CustBankAccountNum = _tmpRecord.CustBankAccountNum;
        newJournalAR.CustBankRegNum = _tmpRecord.CustBankRegNum;
        newJournalAR.ChkRefNbr = _tmpRecord.CheckNumber;
        newJournalAR.CustName = _tmpRecord.CustName;
        newJournalAR.CustAccount = _CustAccount;
        NewJournalAR.PaymNote = _tmpRecord.PaymNote;
        NewJournalAR.Description = _tmpRecord.description;

        //-- Get Customer's name
        select crossCompany:_virtualCompanyCompanies AccountNum, Party, DefaultDimension
                from l_CustTable
                    join Name
                from dirPartyTable
                    WHERE l_CustTable.Party == dirPartyTable.RecId
                        && l_CustTable.AccountNum == _CustAccount
                        && l_CustTable.DataAreaId == curExt();

        if(l_CustTable)
        {
            cpnyID = l_CustTable.DataAreaId;
        }

        if(tmpSetup.LBPaymentCompanyOption == SKS_LB_PaymentCompanyOption::InvoiceCompany || !l_CustTable)
        {
            Select crossCompany:_virtualCompanyCompanies AccountNum, Party, DefaultDimension
            from l_CustTable
            join Name
                from dirPartyTable
                WHERE l_CustTable.Party == dirPartyTable.RecId
                    && l_CustTable.AccountNum == _CustAccount
                    && l_CustTable.DataAreaId != curExt();

            if(l_CustTable)
            {
                cpnyID = l_CustTable.DataAreaId;
            }
        }


        newJournalAR.CustName = dirPartyTable.Name;
        newJournalAR.Party = l_custTable.Party;
        newJournalAR.CustomerCompany = cpnyID;
        newJournalAR.DiscApplyAmt = _tmpRecord.DiscAmount;
        newJournalAR.ImageIdentifierFront = _tmpRecord.ImageIdentifierFront;
        newJournalAR.ImageIdentifierBack = _tmpRecord.ImageIdentifierBack;
        newJournalAR.FileRecord = _tmpRecord.FileLineNbrBegin;
        newJournalAR.ParentRecId = _tmpRecord.ParentRecId;
        newJournalAR.Invoice = _InvoiceID;
        newJournalAR.LBInvoice = _tmpRecord.LBInvoice;
        newJournalAR.LedgerJournalTransRecId = 0;
        newJournalAR.MarkedForApply = NoYes::No;
        newJournalAR.PendingSettlement = 0;
        newJournalAR.PmtAmountCur = _tmpRecord.CheckAmount;
        newJournalAR.ActualSettleAmountCur = settleAmount;
        newJournalAR.defaultdimension = SKS_LB_Process_IMPORTTEMP_Records::LBDimensionMerge(Tmpsetup, _DimensionDefault, l_CustTable.DefaultDimension, tmpBank.LBJournalName, cpnyID);
        NewJournalAR.TrackingInvoices = _tmpRecord.InvoiceNumber;
        newJournalAR.LBSettlementMethod = SKS_EFT_CustomerLoad::CreateFindCustomerRecord(_CustAccount, null, true, true, true, cpnyID).LBSettlementMethod;
        if(tmpSetup.PayJrnlDeposit)
        {
            newJournalAR.PayJrnlDeposit = NoYes::Yes;
        }
        else
        {
            newJournalAR.PayJrnlDeposit = NoYes::No;
        }

        if(SKS_LB_Payment::isOffsetDimMapped(formatID))
        {
            NewJournalAR.OffsetDimension = _tmpRecord.OffsetDimension;
            NewJournalAR.OffsetDimensionReference = _tmpRecord.OffsetDimensionReference;
        }

        if(!SKS_LB_Process_IMPORTTEMP_Records::NullDateCheck(_tmpRecord.DateDay, _tmpRecord.DateMonth, _tmpRecord.DateYear))//Returns TRUE if the date is NULL
        {
            NewJournalAR.PaymDate = mkDate( _tmpRecord.DateDay, _tmpRecord.DateMonth, _tmpRecord.DateYear );
        }
        else if(!SKS_LB_Process_IMPORTTEMP_Records::NullDateCheck(_tmpRecord.HeadDateDay, _tmpRecord.HeadDateMonth, _tmpRecord.HeadDateYear))
        {
            NewJournalAR.PaymDate = mkDate( _tmpRecord.HeadDateDay, _tmpRecord.HeadDateMonth, _tmpRecord.HeadDateYear );
        }
        else
        {
            NewJournalAR.PaymDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
        }
        NewJournalAR.MOP = _tmpRecord.PaymentMOP;

        SKS_LB_FileFormat lsks_lb_fileformat = SKS_LB_FileFormat::find(formatID);

        if(lsks_lb_fileformat.FeeId != '')
        {
            NewJournalAR.FeeId = lsks_lb_fileformat.FeeId;
            NewJournalAR.FeeValue = _tmpRecord.FeeValue;
        }

        newJournalAR.write();

        return NewJournalAR;

    }

]]></Source>
			</Method>
			<Method>
				<Name>InitSettlementManager</Name>
				<Source><![CDATA[
    public void InitSettlementManager(SelectableDataArea _company, date _date, CurrencyCode _CurrencyCode, CustAccount _CustAccount, CompanyBankAccountId bankAccount = '', SKS_LB_FormatId formatID = '', paymMode PaymMode = '')
    {
        if(_company != tmpCPNYID)
        {
            TmpCpnyId = _company;
            changecompany(_company) // 9479 - Customer Matching
            {
                lSettlementManager = SKS_LB_Process_IMPORTTEMP_Records::constructSettlementManager(_date,
                    _CurrencyCode,
                    ExchangeRateHelper::getExchangeRate1_Static(Ledger::primaryLedger(CompanyInfo::find().RecID), _CurrencyCode, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())),
                    TmpCpnyId, _CustAccount, bankAccount, formatID, paymmode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReferenceMatch</Name>
				<Source><![CDATA[
    public SKS_LB_MatchParms ReferenceMatch(CompanyBankAccountId bankAccount, JournalId lbJournalID, SKS_LB_BatchNum _formattedBatNum, str pathFile, Date fileDate,
        SKS_LB_FormatId formatID, container virtualCompanyCompanies, SKS_LB_MatchingRulesGroupID GroupID, TmpSKS_LB_Importing tmpRecord, Boolean CTOForm = false)
    {
        SKS_LB_MatchParms lMatchParms = new SKS_LB_MatchParms();
        SKS_LB_SecondaryMatch SecondaryMatch = new SKS_LB_SecondaryMatch();
        SKS_LB_Process_IMPORTTEMP_Records  Process_ImportTemp_Records = new SKS_LB_Process_IMPORTTEMP_Records();
        TmpSKS_LB_Importing     lImporting;
        SKS_LB_CustomerMatching lCustomerMatch;
        CustTrans TmpInvCustTrans;
        CustTransOpen TmpInvCustTransOpen;
        CustBankAccount CustBankAccount;
        SKS_LB_InvoiceMatch TmpInvoiceMatch;
        SKS_LB_MatchingRules    SKS_LB_MatchingRules;
        SKS_LB_Journal          lSKS_LB_Journal;
        SpecTrans               lSpecTrans;
        SKS_LB_JournalARApplic  lSKS_LB_JournalARApplic;
        SKS_LB_JournalAR        lSKS_LB_JournalAR;
        TmpSKS_LB_RecordCreation    RecordCreation;
        CustAccount             lCustAccount;
        AmountCur               lDiscount;
        AmountCur               lBalance;
        AmountCur               lMatchAmt;
        AmountCur               lTolerance;
        AmountCur               UniqueMatchAmt;
        int                     counter;
        container               OpenInvoiceList;
        container               DiscList;
        boolean                 useApplic = false;
        boolean                 AllowAmountMatching = true;
        boolean                 FoundByDiscAmount = false;
        SKS_LB_ClsJARRecord        ClsJARRecord = new SKS_LB_ClsJARRecord();
        List                    RemitTxtDataList = new List(Types::Class);
        SKS_LB_UnstructuredRulesMatching    UnstructuredRulesMatching = new SKS_LB_UnstructuredRulesMatching();
        SKS_LB_UnstructuredMatchContainers UnstructuredMatchContainer = new SKS_LB_UnstructuredMatchContainers();
        ExecutePermission perm;
        DictClass locDictClass;
        Object locClassInstance;
        int64 rec;
        int listCount = 0;
        boolean ItemFound = false;
        RefRecId TmpRecid;
        ;

        while select * from SKS_LB_MatchingRules order by SKS_LB_MatchingRules.Step where SKS_LB_MatchingRules.GroupID == GroupID
        {
            if(!ItemFound)
            {
                // search for customer only if matching rule is Customer and invoice amount or Customer and total invoice balance
                if(!lCustomerMatch 
                    && 
                    (SKS_LB_MatchingRules.lookupType == SKS_LB_MatchType::CustomerAndAmount 
                        || SKS_LB_MatchingRules.lookupType == SKS_LB_MatchType::CustomerAndInvBalance 
                        || SKS_LB_MatchingRules.lookupType == SKS_LB_MatchType::Custom 
                        || SKS_LB_MatchingRules.lookupType == SKS_LB_MatchType::UnstrData)
                    )
                {
                    lCustomerMatch = SKS_LB_SecondaryMatch::SearchForCustomer(tmpRecord.CustAccount, tmpRecord.CustName, tmpRecord.CustBankAccountNum, tmpRecord.CustBankRegNum, virtualCompanyCompanies);
                    ClsJARRecord.setAll(bankAccount, lbJournalID, _formattedBatNum, pathFile, FileDate, formatID, lCustomerMatch.ParmAccountNum(), virtualCompanyCompanies);
                }
                
                if(SKS_LB_Matchingrules.searchtype == SKS_LB_SearchType::NotApplicable && !CTOForm)
                {
                    if(tmpRecord.InvAmount != 0)
                    {
                        lMatchAmt = tmpRecord.InvAmount;
                    }
                    else
                    {
                        lImporting.setTmpData(tmpRecord);
                        select count(Parentrecid) from lImporting where lImporting.ParentRecid == tmpRecord.ParentRecid;
                        if(lImporting.parentrecid > 1)
                        {
                            AllowAmountMatching = false;
                        }
                        else
                        {
                            lMatchAmt = tmpRecord.CheckAmount;
                        }
                    }

                    if(SKS_LB_MatchingRules.lookupType == SKS_LB_Matchtype::Custom)
                    {
                        perm = new ExecutePermission();
                        perm.assert();
                        locDictClass = new DictClass(className2Id(SKS_LB_MatchingRules.CustomParseClass));
                        locClassInstance = locDictClass.makeObject();

                        lmatchParms = locDictClass.callObject('MatchParms', locClassInstance, tmpRecord, ClsJARRecord);
                        CodeAccessPermission::revertAssert();

                        if(lMatchParms.StopMatch() == NoYes::Yes)
                        {
                            return lMatchParms;
                        }
                    }
                    else if(SKS_LB_MatchingRules.lookupType == SKS_LB_Matchtype::CustomerAndAmount && AllowAmountMatching)
                    {
                        lsks_lb_journal = SKS_LB_Journal::FindByBatchAndJournalNum(_formattedBatNum, lbJournalID);
                        select firstonly crosscompany:virtualCompanyCompanies TmpInvCustTransOpen join TmpInvCustTrans where TmpInvCustTransOpen.AccountNum == lCustAccount
                                && TmpInvCustTransOpen.RefRecId == TmpInvCustTrans.RecId && TmpInvCustTrans.CurrencyCode != lSKS_LB_Journal.CurrencyCode;

                        if(TmpInvCustTransOpen)
                        {
                            TmpInvCustTransOpen = null;
                        }
                        else
                        {
                            if(!lCustomerMatch)
                            {
                                lCustomerMatch = SKS_LB_SecondaryMatch::SearchForCustomer(tmpRecord.CustAccount, tmpRecord.CustName, tmpRecord.CustBankAccountNum, tmpRecord.CustBankRegNum, virtualCompanyCompanies);//Find customer account
                            }
                            if(lCustomerMatch.ParmAccountNum() != ''
                                && lCustomerMatch.ParmCustomerError() != SKS_LB_CustIDErr::DupCustMatch
                                && lCustomerMatch.ParmCustomerError() != SKS_LB_CustIDErr::DuplicateRtnAcct)//If no customer account was found or duplicates were found exit this search criteria
                            {
                                lCustAccount = lCustomerMatch.ParmAccountNum();

                                lTolerance = this.FindTolerance(SKS_lb_MatchingRules.Tolerance);

                                if(SKS_LB_MatchingRules.Discount == NoYes::No)
                                {
                                    if(SKS_LB_MatchingRules.IncludeDuplicateInvs)
                                    {
                                        RecordCreation = SecondaryMatch.CustomerAmountToleranceMatchingIncludeDuplicatInvoices(lTolerance, virtualCompanyCompanies, lSKS_LB_Journal.CurrencyCode, lCustAccount, lMatchAmt, RecordCreation, tmpRecord);//Pass zero as the tolerance amount so that no invoices are filtered out
                                    }
                                    else
                                    {
                                        //Find by invoice amount only
                                        RecordCreation = SecondaryMatch.CustomerAmountToleranceMatching(lTolerance, virtualCompanyCompanies, lSKS_LB_Journal.CurrencyCode, lCustAccount, lMatchAmt, RecordCreation, tmpRecord);//Pass zero as the tolerance amount so that no invoices are filtered out
                                    }

                                    if(RecordCreation != null)
                                    {
                                        tmpRecord.CustomerCompany = RecordCreation.company;
                                        return this.CustAmtMatchWBRecordsCreate(RecordCreation, tmpRecord, BankAccount, formatID, lCustAccount, RecordCreation.DimensionDefault, TmpInvCustTrans.Invoice, lMatchAmt, lSKS_LB_Journal, pathfile , fileDate, _formattedBatNum, lMatchParms, virtualCompanyCompanies);
                                    }
                                }
                                else
                                {
                                    if(SKS_LB_MatchingRules.IncludeDuplicateInvs)
                                    {
                                        RecordCreation = SecondaryMatch.DiscountedInvoiceSearchIncludeDuplicateInvoices(lMatchAmt, lTolerance, lCustAccount, SKS_LB_SecondaryMatch::FindPaymDate(tmpRecord.DateDay, tmpRecord.DateMonth, tmpRecord.DateYear, tmpRecord.HeadDateDay, tmpRecord.HeadDateMonth, tmpRecord.HeadDateYear), lSKS_LB_Journal.currencyCode, virtualCompanyCompanies, RecordCreation);//Pass zero as the tolerance amount so that no invoices are filtered out
                                    }
                                    else
                                    {
                                        RecordCreation = this.DiscountedInvoiceSearch(lMatchAmt, lTolerance, lCustAccount, SKS_LB_SecondaryMatch::FindPaymDate(tmpRecord.DateDay, tmpRecord.DateMonth, tmpRecord.DateYear, tmpRecord.HeadDateDay, tmpRecord.HeadDateMonth, tmpRecord.HeadDateYear), lSKS_LB_Journal.currencyCode, virtualCompanyCompanies);
                                    }

                                    if(RecordCreation != null)
                                    {
                                        tmpRecord.CustomerCompany = RecordCreation.company;
                                        return this.CustAmtMatchWBRecordsCreate(RecordCreation, tmpRecord, BankAccount, formatID, lCustAccount, RecordCreation.DimensionDefault, TmpInvCustTrans.Invoice, lMatchAmt, lSKS_LB_Journal, pathfile , fileDate, _formattedBatNum, lMatchParms, virtualCompanyCompanies);
                                    }
                                }
                            }
                        }
                    }
                    else if(SKS_LB_MatchingRules.lookupType == SKS_LB_Matchtype::CustomerAndInvBalance && AllowAmountMatching)
                    {
                        lCustomerMatch = SKS_LB_SecondaryMatch::SearchForCustomer(tmpRecord.CustAccount, tmpRecord.CustName, tmpRecord.CustBankAccountNum, tmpRecord.CustBankRegNum, virtualCompanyCompanies);//Find customer account

                        select firstonly crosscompany:virtualCompanyCompanies TmpInvCustTransOpen join TmpInvCustTrans where TmpInvCustTransOpen.AccountNum == lCustAccount
                                        && TmpInvCustTransOpen.RefRecId == TmpInvCustTrans.RecId && TmpInvCustTrans.CurrencyCode != lSKS_LB_Journal.CurrencyCode;

                        if(TmpInvCustTransOpen)
                        {
                            TmpInvCustTransOpen = null;
                        }
                        else
                        {
                            if(lCustomerMatch.ParmAccountNum() != ''
                                && lCustomerMatch.ParmCustomerError() != SKS_LB_CustIDErr::DupCustMatch
                                && lCustomerMatch.ParmCustomerError() != SKS_LB_CustIDErr::DuplicateRtnAcct)//If no customer account was found or duplicates were found exit this search criteria
                            {
                                lCustAccount = lCustomerMatch.ParmAccountNum();

                                lTolerance = this.FindTolerance(SKS_lb_MatchingRules.Tolerance);

                                select firstonly CurrencyCode, JournalId, BatchNum from lsks_lb_journal where lSKS_LB_Journal.JournalID == lbJournalID;

                                if(SKS_LB_MatchingRules.Discount == NoYes::No)
                                {
                                    UnstructuredMatchContainer = this.InvoiceBalanceTotalSearch(lMatchAmt, ltolerance, lCustAccount, virtualCompanyCompanies, lCustomerMatch.ParmCompanyId());

                                    OpenInvoiceList = UnstructuredMatchContainer.GoodInv();
                                    UnstructuredMatchContainer = null;

                                    if(OpenInvoiceList != conNull())
                                    {
                                        For(Counter = 1; Counter <= conLen(OpenInvoiceList); Counter++)
                                        {
                                            TmpRecid = conPeek(OpenInvoiceList, Counter);

                                            select firstonly crossCompany:virtualCompanyCompanies TmpInvCustTransOpen where TmpInvCustTransOpen.recid == TmpRecid;
                                            select firstonly crossCompany:virtualCompanyCompanies TmpInvCustTrans where TmpInvCustTrans.recid == TmpInvCustTransOpen.RefRecId;

                                            RecordCreation = this.CreateTempRecord(RecordCreation, TmpInvCustTransOpen, 0, TmpInvCustTrans.Invoice, TmpInvCustTrans.DefaultDimension);
                                        }

                                        return SecondaryMatch.CreateMultipleSettlements(RecordCreation, tmpRecord, SecondaryMatch.InitARRecord(bankAccount, lbJournalID, _formattedBatNum, pathFile, FileDate, formatID, lCustAccount, virtualCompanyCompanies, tmpRecord, tmpRecord.InvAmount != 0 ? tmprecord.InvAmount : tmpRecord.CheckAmount, TmpInvCustTrans.Invoice, TmpInvCustTrans.DefaultDimension), lCustAccount, virtualCompanyCompanies, lSKS_LB_Journal.CurrencyCode, bankAccount, formatID, lMatchParms, SKS_LB_MatchType::CustomerAndInvBalance);
                                    }
                                    TmpInvCustTransOpen = null;//Clear the custtransopen buffer settlement amount doesn't match invoice balance total
                                }
                                else
                                {
                                    UnstructuredMatchContainer = this.DiscountedInvoiceBalanceTotalSearch(lMatchAmt, lTolerance, lCustAccount,
                                        SKS_LB_SecondaryMatch::FindPaymDate(tmpRecord.DateDay, tmpRecord.DateMonth, tmpRecord.DateYear, tmpRecord.HeadDateDay, tmpRecord.HeadDateMonth, tmpRecord.HeadDateYear),
                                        lSKS_LB_Journal.CurrencyCode, virtualCompanyCompanies, BankAccount, formatID);

                                    OpenInvoiceList = UnstructuredMatchContainer.GoodInv();
                                    DiscList = UnstructuredMatchContainer.ConDiscount();
                                    UnstructuredMatchContainer = null;

                                    if(OpenInvoiceList != conNull())
                                    {
                                        for(counter = 1; Counter <= conlen(OpenInvoiceList); counter++)
                                        {
                                            TmpRecid = conPeek(OpenInvoiceList, Counter);

                                            select firstonly crossCompany:virtualCompanyCompanies TmpInvCustTransOpen where TmpInvCustTransOpen.recid == TmpRecid;
                                            select firstonly crossCompany:virtualCompanyCompanies TmpInvCustTrans where TmpInvCustTrans.recid == TmpInvCustTransOpen.RefRecId;

                                            RecordCreation = this.CreateTempRecord(RecordCreation, TmpInvCustTransOpen, conPeek(DiscList, counter), TmpInvCustTrans.Invoice, TmpInvCustTrans.DefaultDimension);
                                        }
                                        return SecondaryMatch.CreateMultipleSettlements(RecordCreation, tmpRecord,
                                                SecondaryMatch.InitARRecord(bankAccount, lbJournalID, _formattedBatNum, pathFile, FileDate, formatID, lCustAccount, virtualCompanyCompanies, tmpRecord, tmpRecord.InvAmount != 0 ? tmprecord.InvAmount : tmpRecord.CheckAmount, TmpInvCustTrans.Invoice, TmpInvCustTrans.DefaultDimension),
                                                lCustAccount, virtualCompanyCompanies, lSKS_LB_Journal.CurrencyCode, bankAccount, formatID, lMatchParms, SKS_LB_MatchType::CustomerAndInvBalance, true);

                                    }
                                }
                            }
                        }
                    }
                    else if(SKS_LB_MatchingRules.lookupType == SKS_LB_Matchtype::UnstrData)
                    {
                        select firstonly lsks_lb_journal where lSKS_LB_Journal.JournalID == lbJournalID;
                        lImporting.setTmpData(tmpRecord);
                        select count(parentrecid) from lImporting where lImporting.ParentRecid == tmpRecord.ParentRecid;
                        if(lImporting.parentrecid <= 1)
                        {
                            boolean searchAcrossCompany = true;
                            if(SKS_LB_Bank::find(lSKS_LB_Journal.BankAcct, lSKS_LB_Journal.FormatID).LBRestrictCrossCompanySearch)
                            {
                                searchAcrossCompany = false;
                            }
                            RemitTxtDataList = UnstructuredRulesMatching.ParseInvNumbers(tmpRecord.PaymNote, SKS_LB_MatchingRules.UnstrRuleID);
                            UnstructuredMatchContainer = UnstructuredRulesMatching.CycleValues(RemitTxtDataList, tmpRecord.CustAccount, SKS_LB_MatchingRules.IncludeDuplicateInvs, searchAcrossCompany);
                            lMatchParms = UnstructuredRulesMatching.DetermineSettleAmount(UnstructuredMatchContainer, SKS_LB_MatchingRules.UnstrRuleID,
                                SKS_LB_SecondaryMatch::FindPaymDate(tmpRecord.DateDay, tmpRecord.DateMonth, tmpRecord.DateYear, tmpRecord.HeadDateDay, tmpRecord.HeadDateMonth, tmpRecord.HeadDateYear),
                                lsks_lb_journal.exchrate, lsks_lb_journal.currencyCode, tmpRecord.CheckAmount);
                            if(lMatchParms.StopMatch() == NoYes::Yes)
                            {
                                if(lMatchParms.SettlementAction() == SKS_LB_SettlementAction::OverpayOnAccount || lMatchParms.SettlementAction() == SKS_LB_SettlementAction::ShortpayOnAccount)
                                {
                                    lMatchParms.JournalARRecId(UnstructuredRulesMatching.CreateOnAccount(UnstructuredMatchContainer.GoodInv(), UnstructuredMatchContainer.MatchType(), ClsJARRecord, tmpRecord, lsks_lb_journal));
                                }
                                else
                                {
                                    lMatchParms.JournalARRecId(UnstructuredRulesMatching.ReorderAndShortpayHandling(tmpRecord, ClsJARRecord, UnstructuredMatchContainer, lsks_lb_journal, lMatchParms.UseDiscount(), lMatchParms.UseTolerance()));
                                }
                                return lMatchParms;
                            }
                        }
                    }
                }
                else if(SKS_LB_Matchingrules.searchtype == SKS_LB_SearchType::Exact)
                {
                    if(tmpRecord.InvoiceNumber != '')
                    {
                        Select firstOnly crosscompany:virtualCompanyCompanies
                        TmpInvoiceMatch
                                where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                            TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber;

                        If (TmpInvoiceMatch)
                        {
                            rec = TmpInvoiceMatch.CustTransRecId;

                            Select firstOnly crosscompany:virtualCompanyCompanies
                            TmpInvoiceMatch
                                where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber &&
                                TmpInvoiceMatch.custtransrecid != Rec;

                            if(!TmpInvoiceMatch)
                            {
                                Select firstOnly crosscompany:virtualCompanyCompanies
                                TmpInvoiceMatch
                                where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber &&
                                TmpInvoiceMatch.custtransrecid == Rec;

                                lMatchParms.invoiceIDErr(SKS_LB_InvoiceIDErr::OK);
                                changeCompany(TmpInvoiceMatch.company())
                                {
                                    TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                }
                            }
                            else
                            {
                                if(tmpRecord.CustAccount != '')
                                {
                                    Select firstOnly crosscompany:virtualCompanyCompanies
                                    TmpInvoiceMatch
                                    where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                    TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                    TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber &&
                                    TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount;

                                    if(TmpInvoiceMatch)
                                    {
                                        rec = TmpInvoiceMatch.CustTransRecId;

                                        Select firstOnly crosscompany:virtualCompanyCompanies
                                        TmpInvoiceMatch
                                        where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                        TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                        TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber &&
                                        TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount &&
                                        TmpInvoiceMatch.CustTransRecId != rec;

                                        if(TmpInvoiceMatch)
                                        {
                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                        }
                                        else
                                        {
                                            Select firstOnly crosscompany:virtualCompanyCompanies
                                            TmpInvoiceMatch
                                            where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                            TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                            TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber &&
                                            TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount;

                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIDErr::OK);
                                            changeCompany(TmpInvoiceMatch.company())
                                            {
                                                TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                            }
                                        }
                                    }
                                }
                                //cust acct was blank, try cust bank rtg/acct
                                else if(tmpRecord.CustBankAccountNum != '' && tmpRecord.CustBankRegNum != '')
                                {
                                    Select firstOnly crosscompany:virtualCompanyCompanies
                                    TmpInvoiceMatch
                                    where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                    TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                    TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber
                                join CustBankAccount
                                    where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                        CustBankAccount.registrationnum == tmpRecord.CustBankRegNum &&
                                        CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                    if(TmpInvoiceMatch)
                                    {
                                        rec = TmpInvoiceMatch.CustTransRecId;

                                        Select firstOnly crosscompany:virtualCompanyCompanies
                                        TmpInvoiceMatch
                                        where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                            TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                            TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber &&
                                            TmpInvoiceMatch.CustTransRecId != rec
                                        join CustBankAccount
                                            where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                                CustBankAccount.registrationnum ==  tmpRecord.CustBankRegNum &&
                                                CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                        if(TmpInvoiceMatch)
                                        {
                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                        }
                                        else
                                        {
                                            Select firstOnly crosscompany:virtualCompanyCompanies
                                            TmpInvoiceMatch
                                            where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                                TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                                TmpInvoiceMatch.MatchValue == tmpRecord.InvoiceNumber &&
                                                TmpInvoiceMatch.CustTransRecId == rec
                                            join CustBankAccount
                                                where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                                    CustBankAccount.registrationnum ==  tmpRecord.CustBankRegNum &&
                                                    CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::OK);
                                            changeCompany(TmpInvoiceMatch.company())
                                            {
                                                TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    if(TmpInvoiceMatch)
                                    {
                                        lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                    }
                                    TmpInvCustTransOpen = null;
                                }
                            }
                        }
                    }
                    else
                    {
                        // we did not find anything, do a further test
                        TmpInvCustTransopen = null;
                    }
                }
                else if(SKS_LB_MatchingRules.SearchType == SKS_LB_SearchType::StartsWith)
                {
                    if(tmpRecord.InvoiceNumber != '')
                    {
                        Select firstOnly crosscompany:virtualCompanyCompanies
                        TmpInvoiceMatch
                        where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                        TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                        TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*';

                        If (TmpInvoiceMatch)
                        {
                            rec = TmpInvoiceMatch.CustTransRecId;

                            Select firstOnly crosscompany:virtualCompanyCompanies
                            TmpInvoiceMatch
                            where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                            TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                            TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*' &&
                            TmpInvoiceMatch.CustTransRecId != rec;

                            if(!TmpInvoiceMatch)
                            {
                                Select firstOnly crosscompany:virtualCompanyCompanies
                                TmpInvoiceMatch
                                where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*' &&
                                TmpInvoiceMatch.CustTransRecId == rec;

                                lMatchParms.invoiceIDErr(SKS_LB_InvoiceIDErr::OK);
                                changeCompany(TmpInvoiceMatch.company())
                                {
                                    TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                }
                            }
                            else
                            {
                                if(tmpRecord.CustAccount != '')
                                {
                                    Select firstOnly crosscompany:virtualCompanyCompanies
                                    TmpInvoiceMatch
                                    where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                    TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                    TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*' &&
                                    TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount;

                                    if(TmpInvoiceMatch)
                                    {
                                        rec = TmpInvoiceMatch.CustTransRecId;

                                        Select firstOnly crosscompany:virtualCompanyCompanies
                                        TmpInvoiceMatch
                                        where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                        TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                        TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*' &&
                                        TmpInvoiceMatch.CustTransRecId != rec &&
                                        TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount;

                                        if(TmpInvoiceMatch)
                                        {
                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                        }
                                        else
                                        {
                                            Select firstOnly crosscompany:virtualCompanyCompanies
                                            TmpInvoiceMatch
                                            where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                            TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                            TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*' &&
                                            TmpInvoiceMatch.CustTransRecId == rec &&
                                            TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount;

                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIDErr::OK);
                                            changeCompany(TmpInvoiceMatch.company())
                                            {
                                                TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                            }
                                        }
                                    }
                                }
                                else if(tmpRecord.CustBankAccountNum != '' && tmpRecord.CustBankRegNum != '')//cust acct was blank, try cust bank rtg/acct
                                {
                                    Select firstOnly crosscompany:virtualCompanyCompanies
                                    TmpInvoiceMatch
                                    where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                    TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                    TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*'
                                    join CustBankAccount
                                    where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                        CustBankAccount.registrationnum == tmpRecord.CustBankRegNum &&
                                        CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                    if(TmpInvoiceMatch)
                                    {
                                        rec = TmpInvoiceMatch.CustTransRecId;

                                        Select firstOnly crosscompany:virtualCompanyCompanies
                                        TmpInvoiceMatch
                                        where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                            TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                            TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*' &&
                                            TmpInvoiceMatch.CustTransRecId != rec
                                        join CustBankAccount
                                            where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                                CustBankAccount.registrationnum ==  tmpRecord.CustBankRegNum &&
                                                CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                        if(TmpInvoiceMatch)
                                        {
                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                        }
                                        else
                                        {
                                            Select firstOnly crosscompany:virtualCompanyCompanies
                                            TmpInvoiceMatch
                                            where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                                TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                                                TmpInvoiceMatch.MatchValue LIKE tmpRecord.InvoiceNumber + '*' &&
                                                TmpInvoiceMatch.CustTransRecId == rec
                                            join CustBankAccount
                                                where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                                    CustBankAccount.registrationnum ==  tmpRecord.CustBankRegNum &&
                                                    CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::OK);
                                            changeCompany(TmpInvoiceMatch.company())
                                            {
                                                TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    if(TmpInvoiceMatch)
                                    {
                                        lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                    }
                                    TmpInvCustTransOpen = null;
                                }
                            }
                        }
                        else
                        {
                            // we did not find anything, do a further test
                            TmpInvCustTransOpen = null;
                        }
                    }
                }
                else if(SKS_LB_MatchingRules.SearchType == SKS_LB_SearchType::EndsWith)
                {
                    if(tmpRecord.InvoiceNumber != '')
                    {
                        Select firstOnly crosscompany:virtualCompanyCompanies
                        TmpInvoiceMatch
                        where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                        TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                        TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*';

                        If (TmpInvoiceMatch)
                        {
                            rec = TmpInvoiceMatch.CustTransRecId;

                            Select firstOnly crosscompany:virtualCompanyCompanies
                            TmpInvoiceMatch
                            where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                            TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                            TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*' &&
                            TmpInvoiceMatch.CustTransRecId != rec;

                            if(!TmpInvoiceMatch)
                            {
                                Select firstOnly crosscompany:virtualCompanyCompanies
                                TmpInvoiceMatch
                                where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                                TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*' &&
                                TmpInvoiceMatch.CustTransRecId == rec;

                                lMatchParms.invoiceIDErr(SKS_LB_InvoiceIDErr::OK);
                                changeCompany(TmpInvoiceMatch.company())
                                {
                                    TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                }
                            }
                            else
                            {
                                if(tmpRecord.CustAccount != '')
                                {
                                    Select firstOnly crosscompany:virtualCompanyCompanies
                                    TmpInvoiceMatch
                                    where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                    TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                                    TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*' &&
                                    TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount;

                                    if(TmpInvoiceMatch)
                                    {
                                        rec = TmpInvoiceMatch.CustTransRecId;

                                        Select firstOnly crosscompany:virtualCompanyCompanies
                                        TmpInvoiceMatch
                                        where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                        TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                                        TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*' &&
                                        TmpInvoiceMatch.CustTransRecId != rec &&
                                        TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount;

                                        if(TmpInvoiceMatch)
                                        {
                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                        }
                                        else
                                        {
                                            Select firstOnly crosscompany:virtualCompanyCompanies
                                            TmpInvoiceMatch
                                            where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                            TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                                            TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*' &&
                                            TmpInvoiceMatch.CustTransRecId == rec &&
                                            TmpInvoiceMatch.CustAccount == tmpRecord.CustAccount;

                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIDErr::OK);
                                            changeCompany(TmpInvoiceMatch.company())
                                            {
                                                TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                            }
                                        }
                                    }
                                }
                                //cust acct was blank, try cust bank rtg/acct
                                else if(tmpRecord.CustBankAccountNum != '' && tmpRecord.CustBankRegNum != '')//cust acct was blank, try cust bank rtg/acct
                                {
                                    Select firstOnly crosscompany:virtualCompanyCompanies
                                    TmpInvoiceMatch
                                    where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                    TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                                    TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*'
                                    join CustBankAccount
                                    where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                        CustBankAccount.registrationnum == tmpRecord.CustBankRegNum &&
                                        CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                    if(TmpInvoiceMatch)
                                    {
                                        rec = TmpInvoiceMatch.CustTransRecId;

                                        Select firstOnly crosscompany:virtualCompanyCompanies
                                        TmpInvoiceMatch
                                        where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                            TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                                            TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*' &&
                                            TmpInvoiceMatch.CustTransRecId != rec
                                        join CustBankAccount
                                            where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                                CustBankAccount.registrationnum ==  tmpRecord.CustBankRegNum &&
                                                CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                        if(TmpInvoiceMatch)
                                        {
                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                        }
                                        else
                                        {
                                            Select firstOnly crosscompany:virtualCompanyCompanies
                                            TmpInvoiceMatch
                                            where TmpInvoiceMatch.MatchType == SKS_LB_MatchingRules.lookuptype &&
                                                TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::reverse &&
                                                TmpInvoiceMatch.MatchValue LIKE SKS_PP_StringFormats::reverse_String(tmpRecord.InvoiceNumber) + '*' &&
                                                TmpInvoiceMatch.CustTransRecId == rec
                                            join CustAccount, registrationnum, AccountNum from CustBankAccount
                                                where CustBankAccount.custaccount == TmpInvoiceMatch.CustAccount &&
                                                    CustBankAccount.registrationnum ==  tmpRecord.CustBankRegNum &&
                                                    CustBankAccount.accountnum == tmpRecord.CustBankAccountNum;

                                            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::OK);
                                            changeCompany(TmpInvoiceMatch.company())
                                            {
                                                TmpInvCustTransOpen = CustTransOpen::find(TmpInvoiceMatch.CustTransOpenRecId);
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    if(TmpInvoiceMatch)
                                    {
                                        lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
                                    }
                                    TmpInvCustTransOpen = null;
                                }
                            }
                        }
                        else
                        {
                            // we did not find anything, do a further test
                            TmpInvCustTransOpen = null;
                        }
                    }
                }

                // Was an Open Invoice found?
                if (TmpInvCustTransOpen  || lmatchparms.invoiceIDErr() == SKS_LB_InvoiceIDErr::MultipleMatchesFound)
                {
                    // If so, then record it and stop looking
                    lMatchParms.matchTransOpen(TmpInvCustTransOpen);
                    lMatchParms.MatchType(TmpInvoiceMatch.MatchType);
                    if(TmpInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Reverse)
                    {
                        lMatchParms.MatchValue(strReverse(TmpInvoiceMatch.MatchValue));
                    }
                    else
                    {
                        lMatchParms.MatchValue(TmpInvoiceMatch.MatchValue);
                    }
                    lMatchParms.CustomerValidation(SKS_LB_MatchingRules.SkipCustValidation);
                    ItemFound = true;
                }
                else
                {
                    lMatchParms.invoiceIDErr(SKS_LB_InvoiceIDErr::InvoiceNotFound);
                    lMatchParms.MatchType(SKS_LB_MatchType::Blank);
                    lMatchParms.MatchValue(tmpRecord.InvoiceNumber);
                }
            }
        }

        if(lmatchparms.invoiceIDErr() == SKS_LB_InvoiceIDErr::InvoiceNotFound && tmpRecord.InvoiceNumber == '')
        {
            lMatchParms.invoiceIDErr(SKS_LB_InvoiceIDErr::OK);
        }

        return lMatchParms;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setApplics</Name>
				<Source><![CDATA[
    public void setApplics( SelectableDataArea _CTOCompany, int64 _CTORECID, int64 _CTORefRecid, AmountCur _CTOAmount, AmountCur _CTODiscount, SelectableDataarea _CTODataareaID, InvoiceID _InvoiceID, TmpSKS_LB_Importing _tmpRecord, currencyCode _currencyCode, custaccount _CustAccount,  CompanyBankAccountId _bankAccount, SKS_LB_FormatId _formatID, SKS_LB_Journalar NewJournalAR, SKS_LB_MatchType _MatchType, boolean _applyDiscount = false)
    {
        SKS_LB_Process_IMPORTTEMP_Records SKS_LB_Process_IMPORTTEMP_Records = new SKS_LB_Process_IMPORTTEMP_Records();

        SKS_LB_Process_IMPORTTEMP_Records.InsertJournalARApplic(_CTODiscount, _CTOAmount - _CTODiscount, _CTORECID, _CTOAmount, _CTORefRecid, _CTODataareaID, NewJournalAR,
                                                                    _InvoiceID, _MatchType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>SetInvoiceNumAsterisk</Name>
				<Source><![CDATA[
    public void SetInvoiceNumAsterisk(SKS_LB_JournalAR  _JournalAR, invoiceid _InvoiceID, boolean _multiples)
    {
        if(!_multiples)
        {
            if(_JournalAR.invoice == '')
            {
                _JournalAR.Invoice = _InvoiceID;
            }
            else
            {
                if(_JournalAR.Invoice != _InvoiceID)
                {
                    _JournalAR.Invoice = '*';
                }
            }
            _JournalAR.update();
        }
        else
        {
            _JournalAR.Invoice = '*';
            _JournalAR.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ValidateInvoiceManualEntry</Name>
				<Source><![CDATA[
    public SKS_LB_MatchParms ValidateInvoiceManualEntry(TmpSKS_LB_Importing _tmpRecord, container _virtualCompanyCompanies, SKS_LB_54000BAS  _SKS_LB_54000BAS, SKS_LB_JournalarErrors _SKS_LB_JournalARErrors, SKS_LB_Journal _SKS_LB_Journal)
    {
        SKS_LB_MatchParms   lMatchParms = new SKS_LB_MatchParms();
        CustTrans           lCustTrans;
        CustTransOpen       lCustTransOpen;
        CustPaymSettlementManager settlementmanager;
        //Workbench only populates invoice, cust account, bank accout, and bank reg number

        if(_tmpRecord.CustAccount)
        {
            Select firstOnly crosscompany:_virtualCompanyCompanies lCustTransOpen
            order by lCustTransOpen.duedate
            join AccountNum, RecId, Invoice from lCustTrans
            where lCustTrans.accountnum == lcusttransopen.accountnum
                && lCustTrans.RecId == lcusttransOpen.RefRecId
                && lCustTrans.AccountNum == _tmpRecord.CustAccount
                && lCustTrans.Invoice == _tmpRecord.InvoiceNumber;

            if(lCustTransOpen)
            {
                changecompany(lCustTransOpen.company())
                {
                    settlementManager = CustPaymSettlementManager::construct(
                            _SKS_LB_54000Bas.CreateTempLedgerJournalTrans
                                (_SKS_LB_JournalARErrors.paymDate,
                                _SKS_LB_Journal.CurrencyCode,
                                _SKS_LB_Journal.ExchRate,
                                _SKS_LB_JournalARErrors.customercompany,
                                lcusttransopen.accountNum));

                    if(!settlementManager.sks_lbisAlreadyMarked(lcusttransopen, 0))
                    {
                        lMatchParms.matchTransOpen(lCustTransOpen);
                        lMatchParms.MatchType(SKS_LB_MatchType::Blank);
                        lMatchParms.MatchValue(_tmpRecord.InvoiceNumber);
                    }
                    else
                    {
                        lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::AlreadyMarked);
                    }
                }
            }
            else
            {
                if(_SKS_LB_JournalARErrors.ActualSettlementAmountCur < 0)
                {
                    lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::CreditNoteNotFound);
                }
                else
                {
                    lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::InvoiceNotFound);
                }
            }
        }
        else
        {
            Select crosscompany:_virtualCompanyCompanies count(RecId) from lCustTransOpen
                    join AccountNum, RecId, Invoice from lCustTrans
                        where lCustTrans.accountnum == lcusttransopen.accountnum
                            && lCustTrans.RecId == lcusttransOpen.RefRecId
                            && lCustTrans.Invoice == _tmpRecord.InvoiceNumber;

            if(lCustTransOpen.RecId == 1)
            {
                Select firstOnly crosscompany:_virtualCompanyCompanies lCustTransOpen
                            order by lCustTransOpen.duedate
                            join AccountNum, RecId, Invoice from lCustTrans
                            where lCustTrans.accountnum == lcusttransopen.accountnum
                                && lCustTrans.RecId == lcusttransOpen.RefRecId
                                && lCustTrans.Invoice == _tmpRecord.InvoiceNumber;

                settlementManager = CustPaymSettlementManager::construct(
                                _SKS_LB_54000Bas.CreateTempLedgerJournalTrans
                                            (_SKS_LB_JournalARErrors.paymDate,
                                    _SKS_LB_Journal.CurrencyCode,
                                            _SKS_LB_Journal.ExchRate,
                                            _SKS_LB_JournalARErrors.customercompany,
                                            lcusttransopen.accountNum));

                if(!settlementManager.sks_lbisAlreadyMarked(lcusttransopen, 0))
                {
                    lMatchParms.matchTransOpen(lCustTransOpen);
                    lMatchParms.MatchType(SKS_LB_MatchType::Blank);
                    lMatchParms.MatchValue(_tmpRecord.InvoiceNumber);
                }
                else
                {
                    lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::AlreadyMarked);
                }
            }
            else if(lCustTransOpen.RecId > 1)
            {
                lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::MultipleMatchesFound);
            }
            else
            {
                if(_SKS_LB_JournalARErrors.ActualSettlementAmountCur < 0)
                {
                    lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::CreditNoteNotFound);
                }
                else
                {
                    lMatchParms.invoiceIDErr(SKS_LB_InvoiceIdErr::InvoiceNotFound);
                }
            }
        }

        return lMatchParms;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildMatchValues</Name>
				<Source><![CDATA[
    static void buildMatchValues(CustTransOpen _CustTransOpen )
    {
        SKS_LB_InvoiceMatch lInvoiceMatch;
        custInvoiceSalesLink SalesLink;
        SalesTable          SalesTable;
        CustInvoiceJour Cust_InvoiceJour;
        WMSBillOfLadingOrder WMS_BillOfLadingOrder;
        CustTrans lCustTrans;
        CustInvoiceTable    CustInvoiceTable;
        SKS_PP_Setup setup;

        container companies = CustVendOpenTransManager::findSharedServiceCompanies(curext());

        select firstonly crosscompany:companies ModLockbox, ModBR, Recid from setup where setup.ModLockbox == NoYes::Yes || setup.ModBR == NoYes::Yes;

        if(!setup)
        {
            return;
        }

        lCustTrans = CustTrans::find(_CustTransOpen.refrecid);

        if(lCustTrans.PaymId != '')
        {
            //insert the Secondary match search value which is the invoice id string reversed
            lInvoiceMatch.MatchType = SKS_LB_MatchType::PaymentID;
            lInvoiceMatch.Direction  = SKS_LB_MatchTypeDirection::Reverse;
            lInvoiceMatch.MatchValue = SKS_PP_Stringformats::reverse_String(lCustTrans.PaymID);
            lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
            lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
            lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
            lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
            lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
            lInvoiceMatch.insert();

            // Add the forward search information so the lookup can be a Inner Join VS an Outer join
            lInvoiceMatch.MatchType = SKS_LB_MatchType::PaymentID;
            lInvoiceMatch.Direction  = SKS_LB_MatchTypeDirection::Forward;
            lInvoiceMatch.MatchValue = lCustTrans.PaymID;
            lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
            lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
            lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
            lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
            lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
            lInvoiceMatch.insert();
        }

        if (lCustTrans.Invoice != '')
        {

            //insert the Secondary match search value which is the invoice id string reversed
            lInvoiceMatch.MatchType = SKS_LB_MatchType::InvoiceNumber;
            lInvoiceMatch.Direction  = SKS_LB_MatchTypeDirection::Reverse;
            lInvoiceMatch.MatchValue = SKS_PP_Stringformats::reverse_String(lCustTrans.Invoice);
            lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
            lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
            lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
            lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
            lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
            lInvoiceMatch.insert();

            // Add the forward search information so the lookup can be a Inner Join VS an Outer join
            lInvoiceMatch.MatchType = SKS_LB_MatchType::InvoiceNumber;
            lInvoiceMatch.Direction  = SKS_LB_MatchTypeDirection::Forward;
            lInvoiceMatch.MatchValue = lCustTrans.Invoice;
            lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
            lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
            lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
            lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
            lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
            lInvoiceMatch.insert();

            // Now find the purchase order references.
            select firstOnly Cust_InvoiceJour where Cust_InvoiceJour.PurchaseOrder != '' &&
                                    Cust_InvoiceJour.InvoiceId == lCustTrans.Invoice &&
                                    Cust_InvoiceJour.InvoiceAccount == lCustTrans.AccountNum &&
                                    Cust_InvoiceJour.InvoiceDate == lCustTrans.TransDate;

            if( Cust_InvoiceJour )
            {
                lInvoiceMatch.MatchType = SKS_LB_MatchType::CustomerReq;
                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                lInvoiceMatch.MatchValue = SKS_PP_Stringformats::reverse_String(Cust_InvoiceJour.PurchaseOrder);
                lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                lInvoiceMatch.insert();


                lInvoiceMatch.MatchType = SKS_LB_MatchType::CustomerReq;
                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                lInvoiceMatch.MatchValue = Cust_InvoiceJour.PurchaseOrder;
                lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                lInvoiceMatch.insert();

            }
            // Now find the CustInvoiceTable record that goes with this CustTrans.

            select * from Cust_InvoiceJour
                where Cust_InvoiceJour.InvoiceID == lCustTrans.Invoice
                    && Cust_InvoiceJour.InvoiceAccount == lCustTrans.AccountNum
                    && Cust_InvoiceJour.InvoiceDate == lCustTrans.TransDate
                            join CustInvoiceTable
                    where CustInvoiceTable.InvoiceId == Cust_InvoiceJour.InvoiceId
                    && CustInvoiceTable.InvoiceDate == Cust_InvoiceJour.InvoiceDate
                    && CustInvoiceTable.numberSequenceGroup == Cust_InvoiceJour.numberSequenceGroup;
                        
            if(CustInvoiceTable.ExternalInvoiceId != '')
            {
                lInvoiceMatch.MatchType = SKS_LB_MatchType::ExternalID;
                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                lInvoiceMatch.MatchValue = SKS_PP_Stringformats::reverse_String(CustInvoiceTable.ExternalInvoiceId);
                lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                lInvoiceMatch.insert();


                lInvoiceMatch.MatchType = SKS_LB_MatchType::ExternalID;
                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                lInvoiceMatch.MatchValue = CustInvoiceTable.ExternalInvoiceId;
                lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                lInvoiceMatch.insert();
            }

            // See if a SalesOrder Type Invoice was created.
            select PurchaseOrder, SalesID from SalesLink where SalesLink.InvoiceID  == lCustTrans.Invoice;
            if( SalesLink )
            {
                // Deal with Sales Order
                if( SalesLink.SalesID != '' )
                {
                    lInvoiceMatch.MatchType = SKS_LB_MatchType::SalesOrderNumber;
                    lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                    lInvoiceMatch.MatchValue = SKS_PP_Stringformats::reverse_String(SalesLink.SalesID);
                    lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                    lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                    lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                    lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                    lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                    lInvoiceMatch.insert();

                    lInvoiceMatch.MatchType = SKS_LB_MatchType::SalesOrderNumber;
                    lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                    lInvoiceMatch.MatchValue = SalesLink.SalesID;
                    lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                    lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                    lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                    lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                    lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                    lInvoiceMatch.insert();

                    Select firstonly SalesTable where SalesTable.SalesId == SalesLink.salesId && SalesTable.SalesId && SalesTable.CustomerRef != '';
                    if(SalesTable)
                    {
                        lInvoiceMatch.MatchType = SKS_LB_MatchType::CustomerRef;
                        lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                        lInvoiceMatch.MatchValue = SKS_PP_Stringformats::reverse_String(SalesTable.CustomerRef);
                        lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                        lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                        lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                        lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                        lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                        lInvoiceMatch.insert();

                        lInvoiceMatch.MatchType = SKS_LB_MatchType::CustomerRef;
                        lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                        lInvoiceMatch.MatchValue = SalesTable.CustomerRef;
                        lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                        lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                        lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                        lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                        lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                        lInvoiceMatch.insert();
                    }
                }

            }

            // Deal with Bill of Lading
            select * from Cust_InvoiceJour where ( Cust_InvoiceJour.InvoiceID == lCustTrans.Invoice ) join
                WMS_BillOfLadingOrder where ( WMS_BillOfLadingOrder.InventTransRefID == Cust_InvoiceJour.SalesId && WMS_BillOfLadingOrder.WMSReferenceType == WMSReferenceType::Sales);
            if( WMS_BillOfLadingOrder && WMS_BillOfLadingOrder.billOfLadingId != '' )
            {
                lInvoiceMatch.MatchType = SKS_LB_MatchType::BillOfLading;
                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                lInvoiceMatch.MatchValue = SKS_PP_Stringformats::reverse_String(WMS_BillOfLadingOrder.billOfLadingId);
                lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                lInvoiceMatch.insert();

                lInvoiceMatch.MatchType = SKS_LB_MatchType::BillOfLading;
                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                lInvoiceMatch.MatchValue = WMS_BillOfLadingOrder.billOfLadingId;
                lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
                lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
                lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
                lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
                lInvoiceMatch.insert();
            }
        }
        if(lCustTrans.PaymReference != '' )
        {
            lInvoiceMatch.MatchType = SKS_LB_MatchType::PaymentReference;
            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
            lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(lCustTrans.PaymReference);
            lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
            lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
            lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
            lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
            lInvoiceMatch.insert();

            // Add the forward so the Join on the lookup screen\form can be an inner vs outer join
            lInvoiceMatch.MatchType = SKS_LB_MatchType::PaymentReference;
            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
            lInvoiceMatch.MatchValue = lCustTrans.PaymReference;
            lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
            lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
            lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
            lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
            lInvoiceMatch.insert();
        }

        if(lCustTrans.DocumentNum != '')
        {
            lInvoiceMatch.MatchType = SKS_LB_MatchType::DocNum;
            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
            lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(lCustTrans.DocumentNum);
            lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
            lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
            lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
            lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
            lInvoiceMatch.insert();

            // Add the forward so the Join on the lookup screen\form can be an inner vs outer join
            lInvoiceMatch.MatchType = SKS_LB_MatchType::DocNum;
            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
            lInvoiceMatch.MatchValue = lCustTrans.DocumentNum;
            lInvoiceMatch.CustTransOpenRecId = _CustTransOpen.RecId;
            lInvoiceMatch.CustAccount = _CustTransOpen.AccountNum;
            lInvoiceMatch.DueDate = _CustTransOpen.DueDate;
            lInvoiceMatch.CTOAmountCur = _CustTransOpen.AmountCur;
            lInvoiceMatch.insert();
        }
        SKS_LB_SecondaryMatch::buildCustomValues(lCustTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CheckSwiftIBAN</Name>
				<Source><![CDATA[
    public static boolean CheckSwiftIBAN(str _IBANSwiftAcctRTN, boolean IbanCheck)
    {
        str TestString;
        int Chars;

        if(IbanCheck)
        {
            Chars = 2;
        }
        else
        {
            chars = 6;
        }

        TestString = strrem(stralpha(substr(_IBANSwiftAcctRTN,1,Chars)), '0123456789');

        if(TestString == substr(_IBANSwiftAcctRTN,1,Chars))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>DoesReferenceMatchMask</Name>
				<Source><![CDATA[
    static boolean DoesReferenceMatchMask( str ReferenceId, str Format )
    {
        boolean retval;
        str Mask;
        str Value;
        int MaskLen;
        int ValueLen;
        str x;
        str y;
        int i;
        int j;
        int t;
        int OK;
        ;

        Mask = Format;
        Value = ReferenceId;

        ValueLen = strlen( Value );
        MaskLen = strlen( Mask );
        OK = 1;
        i = 1;
        while (OK == 1 && i < ValueLen + 1)
        {
            x = substr( Value,i, 1 );
            y = substr( Mask, i, 1 );
            // # represents a numeric character
            if( y == '#')
            {
                t = strfind('1234567890',x, 1, 10);
                if( t > 0)
                    OK = 1;
                else
                    OK = 0;
            }
            else if( y == x )
                OK = 1;
            else
                OK = 0;
            i++;
        }

        //
        if( MaskLen > ValueLen && OK == 1 )
        {
            j = ValueLen;
            // if any chars of the mask are not # then it is NOT a match
            while( OK == 1 && j < MaskLen )
            {
                y = substr( Mask, j, 1 );
                if( y != '#' )
                    OK = 0;
                j++;
            }

        }

        // If we did not find a match, search it again, but backwards.
        if( OK == 0 )
        {
            OK = 1;
            i = ValueLen;
            j = MaskLen;
            while (OK == 1 && i > 0 && j > 0 )
            {
                x = substr( Value,i, 1);
                y = substr( Mask, j, 1 );
                // # represents a numeric character
                if( y == '#')
                {
                    t = strfind('1234567890',x, 1, 10);
                    if( t > 0)
                        OK = 1;
                    else
                        OK = 0;
                }
                else if( y == x )
                    OK = 1;
                else
                    OK = 0;
                i--;
                j--;
            }
        }
        if( OK == 1 )
            retval = true;
        else
            retval = false;

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindPaymDate</Name>
				<Source><![CDATA[
    static date FindPaymDate(Days _day, Months _months, Yr _yr, Days _Journday, Months _Journmonths, Yr _Journyr)
    {
        if(!SKS_LB_Process_IMPORTTEMP_Records::NullDateCheck(_day, _months, _yr))
        {
            return mkDate(_day, _months, _yr);
        }
        else
        {
            if(!SKS_LB_Process_IMPORTTEMP_Records::NullDateCheck(_Journday, _Journmonths, _Journyr))
            {
                return mkDate(_Journday, _Journmonths, _Journyr);
            }
            else
            {
                return DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInvoiceMatchTable</Name>
				<Source><![CDATA[
    [SuppressBPWarningAttribute("BPCheckNestedLoopinCode","Necessary to allow the processing of every Cust Trans record(inner loop) for every Sales Link record(outer loop)")]
    static server void initializeInvoiceMatchTable()
    {
        container companies = SKS_EB_VirtualCompany::getLockboxBankRecCompanies();

        if(companies != conNull())
        {
            for(int i = 1; i <= conLen(companies); i++)
            {
                changecompany(conPeek(companies, i))
                {
                    SKS_LB_InvoiceMatch lInvoiceMatch;
                    CustTrans lCustTrans;
                    recordInsertList ril;
                    custInvoiceSalesLink SalesLink;
                    SalesTable          SalesTable;
                    WMSBILLOFLADINGORDER WMSBillOfLadingOrder;
                    CustInvoiceJour Cust_InvoiceJour;
                    CustTransOpen lCustTransOpen;
                    RefRecId        ctorecid;
                    CustInvoiceTable    CustInvoiceTable;

                    ttsbegin;
                    //Only deleting records in InvoiceMatch if the invoice lookupoption does not exist
                    delete_from lInvoiceMatch where lInvoiceMatch.MatchValue == '';
                    ril = new RecordInsertList(lInvoiceMatch.TableId);

                    select firstOnly lInvoiceMatch where lInvoiceMatch.CustTransOpenRecId == 0;
                    if(lInvoiceMatch)
                    {
                        delete_from lInvoiceMatch;
                    }

                    //Deal with invoice numbers
                    select firstonly linvoicematch where lInvoiceMatch.MatchType == sks_lb_matchtype::InvoiceNumber;
                    if(!lInvoiceMatch)
                    {
                        while select RecID, Invoice from lCustTrans join lCustTransOpen where lCustTrans.RecId == lCusttransOpen.RefRecId && lCustTrans.Invoice != ''
                        {
                            lInvoiceMatch.MatchType = SKS_LB_MatchType::InvoiceNumber;
                            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                            lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(lCustTrans.Invoice);
                            lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                            lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                            lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                            lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                            ril.add(lInvoiceMatch);

                            // Add the forward so the Join on the lookup screen\form can be an inner vs outer join
                            lInvoiceMatch.MatchType = SKS_LB_MatchType::InvoiceNumber;
                            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                            lInvoiceMatch.MatchValue = lCustTrans.Invoice;
                            lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                            lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                            lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                            lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                            ril.add(lInvoiceMatch);
                        }
                    }

                    //Deal with invoice numbers
                    select firstonly linvoicematch where lInvoiceMatch.MatchType == sks_lb_matchtype::PaymentID;
                    if(!lInvoiceMatch)
                    {
                        while select RecID, Invoice, PaymId from lCustTrans join lCustTransOpen where lCustTrans.RecId == lCusttransOpen.RefRecId && lCustTrans.PaymId != ''
                        {
                            lInvoiceMatch.MatchType = SKS_LB_MatchType::PaymentID;
                            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                            lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(lCustTrans.PaymId);
                            lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                            lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                            lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                            lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                            ril.add(lInvoiceMatch);

                            // Add the forward so the Join on the lookup screen\form can be an inner vs outer join
                            lInvoiceMatch.MatchType = SKS_LB_MatchType::PaymentID;
                            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                            lInvoiceMatch.MatchValue = lCustTrans.PaymId;
                            lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                            lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                            lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                            lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                            ril.add(lInvoiceMatch);
                        }
                    }

                    // Deal with Customer Req from sales Orders
                    select firstonly linvoicematch where lInvoiceMatch.MatchType == SKS_LB_MatchType::CustomerReq;
                    if(!lInvoiceMatch)
                    {
                        while select PurchaseOrder, InvoiceId, InvoiceAccount, InvoiceDate from  Cust_InvoiceJour
                        group by PurchaseOrder, InvoiceId
                        where Cust_InvoiceJour.PurchaseOrder != ''
                        JOIN RecId,Invoice,AccountNum,TransDate  from lCustTrans group by RecId where Cust_InvoiceJour.InvoiceId == lCustTrans.Invoice &&
                                            Cust_InvoiceJour.InvoiceAccount == lCustTrans.AccountNum &&
                                            Cust_InvoiceJour.InvoiceDate == lCustTrans.TransDate
                        {
                            lCustTransOpen = CustTransOpen::findRefId(lCustTrans.RecId);
                            if(lCustTransOpen)
                            {
                                lInvoiceMatch.MatchType = SKS_LB_MatchType::CustomerReq;
                                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                                lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                                lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(Cust_InvoiceJour.PurchaseOrder);
                                lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                ril.add(lInvoiceMatch);

                                lInvoiceMatch.MatchType = SKS_LB_MatchType::CustomerReq;
                                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                                lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                                lInvoiceMatch.MatchValue = Cust_InvoiceJour.PurchaseOrder;
                                lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                ril.add(lInvoiceMatch);
                            }
                        }
                    }

                    // Deal with Customer Req from sales Orders
                    select firstonly linvoicematch where lInvoiceMatch.MatchType == SKS_LB_MatchType::ExternalID;
                    if(!lInvoiceMatch)
                    {
                        while select * from Cust_InvoiceJour
                            join lCustTrans
                            where Cust_InvoiceJour.InvoiceID == lCustTrans.Invoice
                                && Cust_InvoiceJour.InvoiceAccount == lCustTrans.AccountNum
                                && Cust_InvoiceJour.InvoiceDate == lCustTrans.TransDate
                            join CustInvoiceTable
                            where CustInvoiceTable.InvoiceId == Cust_InvoiceJour.InvoiceId
                                && CustInvoiceTable.InvoiceDate == Cust_InvoiceJour.InvoiceDate
                                && CustInvoiceTable.numberSequenceGroup == Cust_InvoiceJour.numberSequenceGroup
                                && CustInvoiceTable.ExternalInvoiceId != ''
                        {
                            lCustTransOpen = CustTransOpen::findRefId(lCustTrans.RecId);
                            if(lCustTransOpen)
                            {
                                lInvoiceMatch.MatchType = SKS_LB_MatchType::ExternalID;
                                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                                lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                                lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(CustInvoiceTable.EXTERNALINVOICEID);
                                lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                ril.add(lInvoiceMatch);

                                lInvoiceMatch.MatchType = SKS_LB_MatchType::ExternalID;
                                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                                lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                                lInvoiceMatch.MatchValue = CustInvoiceTable.EXTERNALINVOICEID;
                                lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                ril.add(lInvoiceMatch);
                            }
                        }
                    }

                    // Deal with Sales Order ID from sales Orders
                    // SalesOrder = 4
                    select firstonly linvoicematch where lInvoiceMatch.MatchType == SKS_LB_MatchType::SalesOrderNumber;
                    if(!lInvoiceMatch)
                    {
                        while Select recid from lCustTrans
                            join lCustTransOpen where lCustTrans.RecId == lCusttransOpen.RefRecId
                            join SalesID from SalesLink order by lCustTransOpen.recid where lCustTrans.Invoice == SalesLink.InvoiceID
                            
                        {

                            select count(RecId) from lInvoiceMatch where
                            lInvoiceMatch.MatchType == SKS_LB_MatchType::SalesOrderNumber &&
                            lInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Reverse &&
                            lInvoiceMatch.MatchValue == SKS_PP_StringFormats::reverse_String(SalesLink.SalesID) &&
                            lInvoiceMatch.CustTransRecId == lCustTrans.Recid &&
                            lInvoicematch.CustTransOpenRecId == lCustTransOpen.RecId;

                            // If a record was found
                            if( lInvoiceMatch.recid == 0 )
                            {
                                lInvoiceMatch.MatchType = SKS_LB_MatchType::SalesOrderNumber;
                                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                                lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                                lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(SalesLink.SalesID);
                                lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                lInvoiceMatch.insert(); //insert instead of add so that the record is found in the next iteration
                            }

                            select Count(recid) from lInvoiceMatch where
                            lInvoiceMatch.MatchType == SKS_LB_MatchType::SalesOrderNumber &&
                            lInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward &&
                            lInvoiceMatch.MatchValue == SalesLink.SalesID &&
                            lInvoiceMatch.CustTransRecId == lCustTrans.Recid &&
                            lInvoicematch.CustTransOpenRecId == lCustTransOpen.RecId;

                            // If a record was found
                            if( lInvoiceMatch.recid == 0 )
                            {
                                lInvoiceMatch.MatchType = SKS_LB_MatchType::SalesOrderNumber;
                                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                                lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                                lInvoiceMatch.MatchValue = SalesLink.SalesID;
                                lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                lInvoiceMatch.insert(); //insert instead of add so that the record is found in the next iteration
                            }

                            if(lCustTransOpen.recid != ctorecid)
                            {
                                Select firstonly SalesTable where SalesTable.SalesId == SalesLink.salesId && SalesTable.SalesId && SalesTable.CustomerRef != '';
                                if(SalesTable)
                                {
                                    lInvoiceMatch.MatchType = SKS_LB_MatchType::CustomerRef;
                                    lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                                    lInvoiceMatch.MatchValue = SKS_PP_Stringformats::reverse_String(SalesTable.CustomerRef);
                                    lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                                    lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                    lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                    lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                    lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                    lInvoiceMatch.insert();

                                    lInvoiceMatch.MatchType = SKS_LB_MatchType::CustomerRef;
                                    lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                                    lInvoiceMatch.MatchValue = SalesTable.CustomerRef;
                                    lInvoiceMatch.CustTransRecId = lCustTrans.RecId;
                                    lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                    lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                    lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                    lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                    lInvoiceMatch.insert();
                                }
                            }
                            ctorecid = lCustTransOpen.recid;
                        }
                    }

                    // Deal with Bill of Lading now...
                    // BillOfLading = 3
                    select firstonly linvoicematch where lInvoiceMatch.MatchType == SKS_LB_MatchType::BillOfLading;
                    if(!lInvoiceMatch)
                    {
                        while select billOfLadingID from WMSBillOfLadingOrder  group by billOfLadingID
                    where WMSBillOfLadingOrder.WMSReferenceType == WMSReferenceType::Sales && WMSBillOfLadingOrder.billOfLadingId != ''
                    join Cust_InvoiceJour where ( Cust_InvoiceJour.SalesId == WMSBillOfLadingOrder.InventTransRefid )
                        {
                            lCustTransOpen = CustTransOpen::findRefId(lCustTrans.RecId);
                            if(lCustTransOpen)
                            {
                                lInvoiceMatch.MatchType = SKS_LB_MatchType::BillOfLading;
                                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                                lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                                lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(WMSBillOfLadingOrder.billOfLadingID);
                                lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                ril.add(lInvoiceMatch);

                                lInvoiceMatch.MatchType = SKS_LB_MatchType::BillOfLading;
                                lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                                lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                                lInvoiceMatch.MatchValue = WMSBillOfLadingOrder.billOfLadingID;
                                lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                                lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                                lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                                lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                                ril.add(lInvoiceMatch);
                            }
                        }
                    }

                    select firstonly linvoicematch where lInvoiceMatch.MatchType == SKS_LB_MatchType::PaymentReference;
                    if(!lInvoiceMatch)
                    {
                        while select RecID, PaymReference from lCustTrans join lCustTransOpen where lCustTrans.RecId == lCusttransOpen.RefRecId && lCustTrans.PaymReference != ''
                        {
                            lInvoiceMatch.MatchType = SKS_LB_MatchType::PaymentReference;
                            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                            lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(lCustTrans.PaymReference);
                            lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                            lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                            lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                            lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                            ril.add(lInvoiceMatch);

                            // Add the forward so the Join on the lookup screen\form can be an inner vs outer join
                            lInvoiceMatch.MatchType = SKS_LB_MatchType::PaymentReference;
                            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                            lInvoiceMatch.MatchValue = lCustTrans.PaymReference;
                            lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                            lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                            lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                            lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                            ril.add(lInvoiceMatch);

                        }
                    }

                    select firstonly linvoicematch where lInvoiceMatch.MatchType == SKS_LB_MatchType::DocNum;
                    if(!lInvoiceMatch)
                    {
                        while select RecID, DocumentNum from lCustTrans join lCustTransOpen where lCustTrans.RecId == lCusttransOpen.RefRecId && lCustTrans.DocumentNum != ''
                        {
                            lInvoiceMatch.MatchType = SKS_LB_MatchType::DocNum;
                            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Reverse;
                            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                            lInvoiceMatch.MatchValue = SKS_PP_StringFormats::reverse_String(lCustTrans.DocumentNum);
                            lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                            lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                            lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                            lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                            ril.add(lInvoiceMatch);

                            // Add the forward so the Join on the lookup screen\form can be an inner vs outer join
                            lInvoiceMatch.MatchType = SKS_LB_MatchType::DocNum;
                            lInvoiceMatch.Direction = SKS_LB_MatchTypeDirection::Forward;
                            lInvoiceMatch.CustTransRecId = lCustTrans.Recid;
                            lInvoiceMatch.MatchValue = lCustTrans.DocumentNum;
                            lInvoiceMatch.CustTransOpenRecId = lCustTransOpen.RecId;
                            lInvoiceMatch.CustAccount = lCustTransOpen.AccountNum;
                            lInvoiceMatch.DueDate = lCustTransOpen.DueDate;
                            lInvoiceMatch.CTOAmountCur = lCustTransOpen.AmountCur;
                            ril.add(lInvoiceMatch);

                        }
                    }
                    ril.insertDatabase();
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>SearchForCustomer</Name>
				<Source><![CDATA[
    public static SKS_LB_CustomerMatching SearchForCustomer(CustAccount _CustId, CustName _CustName, SKS_EB_CustBankAccountNum _CustBankAccountNum, SKS_EB_CustomerBankRegNum _CustBankRegNum, container virtualCompanyCompanies)
    {
        SKS_LB_CustomerMatching CustomerMatch = new SKS_LB_CustomerMatching();
        CustomerMatch.GetSetCrossCompanyContainer(virtualCompanyCompanies);
        if(_CustId != '')
        {
            CustomerMatch.CustIDMatch(_CustId);//Retrieve customer account to be used in matching
        }

        if(CustomerMatch.ParmAccountNum() == '')
        {
            if(_CustBankRegNum != '' && _CustBankAccountNum != '')
            {
                if(!SKS_LB_SecondaryMatch::CheckSwiftIban(_CustBankRegNum, false))
                {
                    CustomerMatch.CustBankAcctRTNMatch(_CustBankAccountNum, _CustBankRegNum, virtualCompanyCompanies);
                }
                Else//qualifies as swift code
                {
                    CustomerMatch.CustSwiftAcctMatch(_CustBankAccountNum, _CustBankRegNum, virtualCompanyCompanies);
                }
            }


            if(CustomerMatch.ParmAccountNum() == '')
            {
                if(_CustBankAccountNum != '')
                {
                    if(SKS_LB_SecondaryMatch::CheckSwiftIBAN(_CustBankAccountNum, true))
                    {
                        CustomerMatch.CustIBANMatch(_CustBankAccountNum, virtualCompanyCompanies);//qualifies as IBAN
                    }
                }
            }

            if(CustomerMatch.ParmAccountNum() == '')
            {
                if(_CustName != '')
                {
                    CustomerMatch.CustNameMatch(_CustName);
                }
            }
        }

        return CustomerMatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>secondaryInvoiceMatch</Name>
				<Source><![CDATA[
    static boolean secondaryInvoiceMatch()
    {
        //REMOVING THIS METHOD WILL CAUSE AN ENUM ERROR WHEN UPGRADING FROM VERSION 4.4.4.5 or lower via XPO import
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>DiscountedInvoiceSearch</Name>
				<Source><![CDATA[
    /// <summary>
    ///
    /// </summary>
    public Tmpsks_lb_RecordCreation DiscountedInvoiceSearch(AmountCur _matchAmt, amountcur _tolerance, CustAccount _CustAccount, date _date, currencycode _currencyCode, container _virtualCompanyCompanies, CompanyBankAccountId _bankAccount = '', SKS_LB_FormatId _formatID = '')
    {
        CustTransOpen   TmpInvCustTransOpen;
        CustTrans       TmpInvCustTrans;
        SpecTrans       lSpecTrans;
        AmountCur       lDiscount;
        SKS_LB_JournalARApplic  lSKS_LB_JournalARApplic;
        SKS_LB_JournalAR    lSKS_LB_JournalAR;
        Tmpsks_lb_RecordCreation    RecordCreation;

        //Find by invoice amount with Discount and tolerance
        Select crosscompany:_virtualCompanyCompanies TmpInvCustTransOpen order by TmpInvCustTransOpen.duedate asc
                where TmpInvCustTransOpen.AccountNum == _CustAccount
            join TmpInvCustTrans
                where TmpInvCustTransOpen.RefRecId == TmpInvCustTrans.recid;
            // SKS_19380_FlintfoxAresInvoiceApplicaiton
            //notExists join lSpectrans
            //    where TmpInvCustTransOpen.dataareaid == lSpecTrans.RefCompany
            //        && TmpInvCustTransOpen.TableId == lSpecTrans.reftableid
            //        && TmpInvCustTransOpen.recid == lSpecTrans.refrecid;
            // SKS_19380_FlintfoxAresInvoiceApplicaiton

        while(TmpInvCustTransOpen)
        {
            if(!this.CustAmtMatchARAlreadyMarked(TmpInvCustTransOpen, TmpInvCustTrans))//Returns false if NOT marked by another journalAR
            {
                this.InitSettlementManager(TmpInvCustTransOpen.company(), _date, _currencyCode, _CustAccount, _bankAccount, _formatID, TmpInvCustTrans.PaymMode);//BankRec would leave bankaccount and formatID blank and pass a payment method
                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                //lDiscount = lSettlementManager.calcCashDiscAmountToTake(TmpInvCustTransOpen);
                if (TmpInvCustTransOpen.AmountCur == TmpInvCustTransOpen.sksGetRemainingAmount())
                {
                    lDiscount = lSettlementManager.calcCashDiscAmountToTake(TmpInvCustTransOpen);
                }
                else
                {
                    lDiscount = lSettlementManager.calculatePartialApplicableCashDiscount(TmpInvCustTransOpen, TmpInvCustTransOpen.sksGetRemainingAmount());
                }
                // SKS_19380_FlintfoxAresInvoiceApplicaiton

                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                //if(TmpInvCustTransOpen.AmountCur - lDiscount <= _matchAmt + _tolerance && TmpInvCustTransOpen.AmountCur - lDiscount >= _matchAmt - _tolerance)
                if(TmpInvCustTransOpen.sksGetRemainingAmount(true) - lDiscount <= _matchAmt + _tolerance && TmpInvCustTransOpen.sksGetRemainingAmount(true) - lDiscount >= _matchAmt - _tolerance)
                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                {
                    return this.CreateTempRecord(RecordCreation, TmpInvCustTransOpen, lDiscount, TmpInvCustTrans.Invoice, TmpInvCustTrans.DefaultDimension);
                }
            }
            next TmpInvCustTransOpen;
        }

        // SKS_19380_FlintfoxAresInvoiceApplicaiton
        // TODO: add notexists join to journalAR
        SKS_LB_JournalARApplic journalARApplic;
        SKS_LB_JournalAR journalAR;
        CustTransOpen localCustTransOpen;
        CustTrans localCustTrans;
        SpecTrans localSpecTrans;
        SKS_LB_JournalARApplic localJournalARApplic;
        while select crosscompany:_virtualCompanyCompanies localCustTransOpen
                order by DueDate asc
            where localCustTransOpen.AccountNum == _custAccount
                join RecId, Invoice, DefaultDimension from localCustTrans
            where localCustTransOpen.RefRecId == localCustTrans.RecId
               && localCustTrans.AmountCur != 0
                join localSpecTrans
            where localSpecTrans.RefCompany == localCustTransOpen.DataAreaId
                && localSpecTrans.RefTableId == localCustTransOpen.TableId
                && localSpecTrans.RefRecId == localCustTransOpen.RecId
                && localSpecTrans.SpecTableId == tableNum(LedgerJournalTrans)
                notexists join localJournalARApplic
            where localCustTransOpen.dataAreaId == journalARApplic.CustTransDataAreaId
               && localCustTransOpen.RecId == journalARApplic.CustTransOpenRecId
               && journalARApplic.SettleAmountCur != 0
               join RecId, LedgerJournalTransRecId from journalAR
            where journalAR.RecId == journalARApplic.SKS_LB_JournalARRecId
               && journalAR.LedgerJournalTransRecId == 0
        {
            changecompany (localSpecTrans.SpecCompany)
            {
                Amount remainingAmount = localCustTransOpen.remainAmountCashDisc();
                if (remainingAmount <= _matchAmt + _tolerance &&
                    remainingAmount >= _matchAmt - _tolerance)
                {
                    SKS_PP_Setup lSetup = SKS_PP_Setup::find();
                    RecordCreation.Amount = remainingAmount;
                    RecordCreation.CTODataAreaId = localCustTransOpen.DataAreaID;
                    RecordCreation.CTORecId = localCustTransOpen.RecId;
                    RecordCreation.CTORefRecid = localCustTransOpen.RefRecId;
                    RecordCreation.Discount = 0;
                    RecordCreation.CTInvoiceID = localCustTrans.Invoice;
                    RecordCreation.Company = localCustTransOpen.Company();
                    RecordCreation.DimensionDefault = SKS_LB_Process_IMPORTTEMP_Records::LBDimensionMerge(lSetup, localCustTrans.DefaultDimension, CustTable::find(localCustTrans.AccountNum).DefaultDimension, lSetup.journalName, localCustTrans.company());
                    RecordCreation.insert();

                    return RecordCreation;
                }
            }
        }
        // SKS_19380_FlintfoxAresInvoiceApplicaiton

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>DiscountedInvoiceSearchIncludeDuplicateInvoices</Name>
				<Source><![CDATA[
    public Tmpsks_lb_RecordCreation DiscountedInvoiceSearchIncludeDuplicateInvoices(AmountCur _matchAmt, amountcur _tolerance, CustAccount _CustAccount, date _date, currencycode _currencyCode, container _virtualCompanyCompanies, Tmpsks_lb_RecordCreation    RecordCreation, CompanyBankAccountId _bankAccount = '', SKS_LB_FormatId _formatID = '')
    {
        CustTransOpen   TmpInvCustTransOpen;
        CustTrans       TmpInvCustTrans;
        SpecTrans       lSpecTrans;
        AmountCur       lDiscount;
        SKS_LB_JournalARApplic  lSKS_LB_JournalARApplic;
        SKS_LB_JournalAR        lSKS_LB_JournalAR;
        ;
        SKS_LB_InvoiceMatch     l_SumInvoicematch, lInvoiceMatch;
        SpecTrans               localSpecTrans;
        real            totalAmt;
        container       conCTO, conCT, conDisc;
        Integer         Counter;
        boolean         lAlreadyMarked = false;
        SKS_LB_SecondaryMatch   SKS_LB_SecondaryMatch = new SKS_LB_SecondaryMatch();

        Select crosscompany:_virtualCompanyCompanies sum(CTOAmountCur), maxof(CustTransRecId)
            from l_SumInvoicematch
            group by CustAccount, CustTransRecId
            where l_SumInvoicematch.CustAccount == _custAccount &&
                l_SumInvoicematch.Direction == SKS_LB_MatchTypeDirection::Forward;

        while(l_SumInvoicematch)
        {
            totalAmt = 0;
            select firstonly crosscompany:_virtualCompanyCompanies lInvoiceMatch join localSpectrans
                where lInvoiceMatch.dataareaid == localSpecTrans.RefCompany &&
                    tableNum('CustTransOpen') == localSpecTrans.reftableid &&
                    lInvoiceMatch.CustTransOpenRecid == localSpecTrans.refrecid &&
                    lInvoiceMatch.CustTransRecid == l_SumInvoicematch.CustTransRecId &&
                    lInvoiceMatch.direction == SKS_LB_MatchTypeDirection::forward;

            if(!localSpecTrans)
            {
                select crosscompany:_virtualCompanyCompanies lInvoiceMatch
                    where lInvoiceMatch.CustTransRecId == l_SumInvoicematch.CustTransRecId &&
                        lInvoiceMatch.Direction == SKS_LB_MatchTypeDirection::Forward;
                while(lInvoiceMatch)
                {
                    CustTransOpen   lCustTransOpen = CustTransOpen::find(lInvoiceMatch.CustTransOpenRecId);
                    CustTrans       lCustTrans = CustTrans::find(lCustTransOpen.RefRecId);
                    if(SKS_LB_SecondaryMatch.CustAmtMatchARAlreadyMarked(lCustTransOpen, lCustTrans))//Returns false if NOT marked by another journalAR
                    {
                        lInvoiceMatch = null;
                        conCTO = conNull();
                        conCT = conNull();
                        conDisc = conNull();
                        next l_SumInvoicematch;
                    }
                    else
                    {
                        this.InitSettlementManager(lCustTransOpen.company(), _date, _currencyCode, _CustAccount, _bankAccount, _formatID, lCustTrans.PaymMode);//BankRec would leave bankaccount and formatID blank and pass a payment method
                        lDiscount = lSettlementManager.calcCashDiscAmountToTake(lCustTransOpen);
                        totalAmt += lCustTransOpen.AmountCur - lDiscount;
                        if(totalAmt - _tolerance > _matchAmt)
                        {
                            lInvoiceMatch = null;
                            conCTO = conNull();
                            conCT = conNull();
                            conDisc = conNull();
                            next l_SumInvoicematch;
                        }
                        else
                        {
                            conCTO += lCustTransOpen;
                            conCT += lCustTrans;
                            conDisc += lDiscount;

                            next lInvoiceMatch;
                            if(!linvoicematch && totalAmt <= _matchAmt + _Tolerance && totalAmt >= _matchAmt - _Tolerance)
                            {
                                For(Counter = 1; Counter <= conLen(conCTO); Counter++)
                                {
                                    lCustTransOpen = ConPeek(conCTO, counter);
                                    lCustTrans = ConPeek(conCT, counter);
                                    lDiscount = ConPeek(conDisc, counter);
                                    ttsbegin;
                                    RecordCreation = this.CreateTempRecord(RecordCreation, lCustTransOpen, lDiscount, lCustTrans.Invoice, lCustTrans.DefaultDimension);
                                    ttscommit;
                                }
                                return RecordCreation;
                            }
                            else if(!lInvoiceMatch)
                            {
                                conCTO = conNull();
                                conCT = conNull();
                                conDisc = conNull();
                                next l_SumInvoicematch;
                            }
                        }
                    }
                }
            }
            else
            {
                next l_SumInvoicematch;
            }
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CustAmtMatchWBRecordsCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// SIGNATURE LOCKED BY CUSTOMIZATION
    /// </summary>
    /// <param name = "_RecordCreation">_RecordCreation</param>
    /// <param name = "_tmpRecord">_tmpRecord</param>
    /// <param name = "_bankAccount">_bankAccount</param>
    /// <param name = "_formatID">_formatID</param>
    /// <param name = "_CustAccount">_CustAccount</param>
    /// <param name = "_DefaultDimension">_DefaultDimension</param>
    /// <param name = "_InvoiceID">_InvoiceID</param>
    /// <param name = "_MatchAmt">_MatchAmt</param>
    /// <param name = "_SKS_LB_Journal">_SKS_LB_Journal</param>
    /// <param name = "_pathFile">_pathFile</param>
    /// <param name = "_fileDate">_fileDate</param>
    /// <param name = "_formattedBatNum">_formattedBatNum</param>
    /// <param name = "_MatchParms">_MatchParms</param>
    /// <param name = "_virtualCompanyCompanies">_virtualCompanyCompanies</param>
    /// <returns></returns>
    public SKS_LB_MatchParms CustAmtMatchWBRecordsCreate(TmpSKS_LB_RecordCreation _RecordCreation, TmpSKS_LB_Importing _tmpRecord, CompanyBankAccountId _bankAccount,
        SKS_LB_FormatId _formatID, CustAccount _CustAccount, DimensionDefault _DefaultDimension, invoiceid _InvoiceID, AmountCur _MatchAmt,
        SKS_LB_Journal _SKS_LB_Journal, str _pathFile, Date _fileDate, SKS_LB_BatchNum _formattedBatNum, SKS_LB_MatchParms _MatchParms, container _virtualCompanyCompanies)
    {
        CustTable           TmpCustTable;
        DirPartyTable       dirPartyTable;
        SKS_LB_Bank         lbBank = SKS_LB_Bank::find(_bankAccount, _formatID);
        SKS_LB_JournalAR    lSKS_LB_JournalAR;
        SKS_LB_JournalAR    rootAR;
        SKS_LB_SecondaryMatch SecondaryMatch = new SKS_LB_SecondaryMatch();
        SKS_LB_Process_IMPORTTEMP_Records ProcessImportTemp = new SKS_LB_Process_IMPORTTEMP_Records();

        //Necessary to find the dirparty recid
        Select crossCompany:_virtualCompanyCompanies AccountNum, Party, DefaultDimension
                from TmpCustTable
                join Name from dirPartyTable
                    WHERE TmpCustTable.Party == dirPartyTable.RecId
                        && TmpCustTable.AccountNum == _CustAccount;
        //Set the global variable for use in the new SKS_LB_Process_ImportTemp_records instance
        ProcessImportTemp.GetSetGlobalTmpJournal(_SKS_LB_Journal);
        //Set JournalARRecordExists handles split payment logic. Determines if the current imported record is a split pmt and adjusts the payment amount on the root pmt AR record
        ProcessImportTemp.SetJournalARRecordExists(_tmpRecord,lbBank,_DefaultDimension,DirPartyTable.RecID,_CustAccount,lbBank.SepPaymByInv,false,_RecordCreation.Company);
        lSKS_LB_JournalAR = ProcessImportTemp.getsetTmpJournalAR();
        
        if(lSKS_LB_JournalAR && !lbBank.SepPaymByInv)
        {
            lSKS_LB_JournalAR.ActualSettleAmountCur += _MatchAmt;
            lSKS_LB_JournalAR.FeeValue += _tmprecord.FeeValue;
            if(SKS_LB_FileFormat::find(_formatID).PmtAmtEQSumChkAmts)
            {
                lSKS_LB_JournalAR.PmtAmountCur += _tmpRecord.CheckAmount;
            }
        }
        else if (lSKS_LB_JournalAR && lbBank.SepPaymByInv)
        {
            if(SKS_LB_Process_IMPORTTEMP_Records::ParentRecIDFileType(SKS_LB_FileFormat::find(_formatID).FileType))
            {
                lSKS_LB_JournalAR.PmtAmountCur -= _tmpRecord.InvAmount;
                lSKS_LB_JournalAR.update();
                _tmpRecord.CheckAmount = _tmpRecord.InvAmount;
            }

            lSKS_LB_JournalAR = SecondaryMatch.InitARRecord(_bankAccount, _SKS_LB_Journal.JournalID, _formattedBatNum, _pathFile, _FileDate, _formatID, _CustAccount, _virtualCompanyCompanies, _tmpRecord, _tmpRecord.InvAmount != 0 ? _tmpRecord.InvAmount : _tmpRecord.CheckAmount, _InvoiceID, _DefaultDimension);
            lSKS_LB_JournalAR.CustomerCompany = SKS_PP_Setup::find().LBPaymentCompanyOption == SKS_LB_PaymentCompanyOption::InvoiceCompany ? _RecordCreation.Company : lSKS_LB_JournalAR.CustomerCompany;
            lSKS_LB_JournalAR.PmtWasSplit = ProcessImportTemp.GetSetGlobalSplitPayment();
            lSKS_LB_JournalAR.update();
        }
        else
        {
            lSKS_LB_JournalAR = SecondaryMatch.InitARRecord(_bankAccount, _SKS_LB_Journal.JournalID, _formattedBatNum, _pathFile, _FileDate, _formatID, _CustAccount, _virtualCompanyCompanies, _tmpRecord, _tmpRecord.InvAmount != 0 ? _tmpRecord.InvAmount : _tmpRecord.CheckAmount, _InvoiceID, _DefaultDimension);
            lSKS_LB_JournalAR.CustomerCompany = SKS_PP_Setup::find().LBPaymentCompanyOption == SKS_LB_PaymentCompanyOption::InvoiceCompany ? _RecordCreation.Company : lSKS_LB_JournalAR.CustomerCompany;
            lSKS_LB_JournalAR.PmtWasSplit = ProcessImportTemp.GetSetGlobalSplitPayment();
            lSKS_LB_JournalAR.update();
        }

        return SecondaryMatch.CreateMultipleSettlements(_RecordCreation, _tmpRecord, lSKS_LB_JournalAR, _CustAccount, _virtualCompanyCompanies, _SKS_LB_Journal.CurrencyCode, _bankAccount, _formatID, _MatchParms, SKS_LB_MatchType::CustomerAndAmount, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CustAmtMatchARAlreadyMarked</Name>
				<Source><![CDATA[
    private boolean CustAmtMatchARAlreadyMarked(CustTransOpen _CustTransOpen, CustTrans _CustTrans)
    {
        SKS_LB_JournalARApplic  localJournalARApplic;
        SKS_LB_JournalAR        lSKS_LB_JournalAR;

        select firstonly localJournalARApplic
                where _CustTransOpen.dataAreaId == localJournalARApplic.CustTransDataAreaId
                    && _CustTransOpen.recid == localJournalARApplic.CustTransOpenRecId
                    && localJournalARApplic.SettleAmountCur != 0
                join RecId, LedgerJournalTransRecId from lSKS_LB_JournalAR
                where lSKS_LB_JournalAR.recid == localJournalARApplic.SKS_LB_JournalARRecId
                    && lSKS_LB_JournalAR.LedgerJournalTransRecId == 0;

        if(!localJournalARApplic)
        {
            return false;
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>DiscountedInvoiceBalanceTotalSearch</Name>
				<Source><![CDATA[
    public SKS_LB_UnstructuredMatchContainers DiscountedInvoiceBalanceTotalSearch(AmountCur _matchAmt, amountcur _tolerance, CustAccount _CustAccount, date _date, currencycode _currencyCode, container _virtualCompanyCompanies, CompanyID _CustomerCompany, CompanyBankAccountId _bankAccount = '', SKS_LB_FormatId _formatID = '')
    {
        container               OpenInvoiceList;
        container               DiscList;
        CustTrans               TmpInvCustTrans;
        CustTransOpen           TmpInvCustTransOpen;
        SpecTrans               lSpecTrans;
        SKS_LB_JournalAR        lSKS_LB_Journalar;
        SKS_LB_JournalARApplic  lSKS_LB_JournalArApplic;
        AmountCur               lDiscount;
        AmountCur               lBalance;
        CustTable               TmpCustTable;
        CustTable               lCustTable;
        DirPartyTable           dirPartyTable;
        SKS_LB_UnstructuredMatchContainers SKS_LB_UnstructuredMatchContainers = new SKS_LB_UnstructuredMatchContainers();
        // SKS_19380_FlintfoxAresInvoiceApplicaiton
        AmountCur               remainingMatchAmount = _matchAmt;
        // SKS_19380_FlintfoxAresInvoiceApplicaiton

        Select crossCompany:_virtualCompanyCompanies AccountNum, Party, DefaultDimension
                from TmpCustTable
                join Name
                    from dirPartyTable
                    WHERE TmpCustTable.Party == dirPartyTable.RecId
                        && TmpCustTable.AccountNum == _CustAccount
                        && TmpCustTable.dataareaid == _CustomerCompany;
        // SKS_19380_FlintfoxAresInvoiceApplicaiton
        // TODO : BUG
        //select crosscompany:_virtualCompanyCompanies AmountCur from TmpInvCustTransOpen order by TmpInvCustTransOpen.duedate asc
        select crosscompany:_virtualCompanyCompanies TmpInvCustTransOpen
            order by TmpInvCustTransOpen.duedate asc
        // SKS_19380_FlintfoxAresInvoiceApplicaiton
        where TmpInvCustTransOpen.AccountNum == _CustAccount
            join TmpInvCustTrans
                where TmpInvCustTransOpen.RefRecId == TmpInvCustTrans.recid
            join lCustTable
                where lCustTable.AccountNum == TmpInvCustTransOpen.AccountNum
                    && lCustTable.Party == TmpCustTable.Party;
        // SKS_19380_FlintfoxAresInvoiceApplicaiton
        //notExists join lSpectrans
        //    where TmpInvCustTransOpen.dataareaid == lSpecTrans.RefCompany
        //        && TmpInvCustTransOpen.TableId == lSpecTrans.reftableid
        //        && TmpInvCustTransOpen.recid == lSpecTrans.refrecid;
        // SKS_19380_FlintfoxAresInvoiceApplicaiton

        while(TmpInvCustTransOpen)
        {
            select crosscompany:_virtualCompanyCompanies lSKS_LB_JournalARApplic
                where TmpInvCustTransOpen.dataAreaId == lSKS_LB_JournalARApplic.CustTransDataAreaId
                    && TmpInvCustTransOpen.recid == lSKS_LB_JournalARApplic.CustTransOpenRecId
                    && lSKS_LB_JournalARApplic.SettleAmountCur != 0
                join RecId, ledgerJournalTransRecID from lSKS_LB_JournalAR
                where lSKS_LB_JournalAR.recid == lSKS_LB_JournalARApplic.SKS_LB_JournalARRecId
                    && lSKS_LB_JournalAR.LedgerJournalTransRecId == 0;

            if(!lSKS_LB_JournalarApplic)
            {
                this.InitSettlementManager(TmpInvCustTransOpen.company(), _date, _CurrencyCode, _CustAccount, _bankAccount, _formatID, TmpInvCustTrans.PaymMode);//BankRec would leave bankaccount and formatID blank and pass a payment method
                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                //ldiscount = lSettlementManager.calcCashDiscAmountToTake(TmpInvCustTransOpen);//Retrieves discount amount
                Amount remainingAmount = TmpInvCustTransOpen.sksGetRemainingAmount();
                if (remainingAmount == TmpInvCustTransOpen.AmountCur)
                {
                    ldiscount = lSettlementManager.calcCashDiscAmountToTake(TmpInvCustTransOpen);//Retrieves discount amount
                }
                else
                {
                    ldiscount = lSettlementManager.calculatePartialApplicableCashDiscount(TmpInvCustTransOpen, remainingAmount);//Retrieves discount for remaining amount
                }
                // SKS_19380_FlintfoxAresInvoiceApplicaiton

                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                //lBalance += (TmpInvCustTransOpen.AmountCur - lDiscount);//Add discounted invoices amounts to the invoice balance total
                //lBalance += (remainingAmount - lDiscount);//Add discounted invoices amounts to the invoice balance total
                //AmountCur processAmount = min(remainingAmount - lDiscount, remainingMatchAmount);
                AmountCur processAmount = remainingAmount - lDiscount;
                lBalance += processAmount;//Add discounted invoices amounts to the invoice balance total
                remainingMatchAmount -= processAmount;
                // SKS_19380_FlintfoxAresInvoiceApplicaiton

                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                // BUG system doesn't considering credit notes
                /*
                if(lBalance > (_matchAmt + _Tolerance))
                {
                    TmpInvCustTransOpen = null;//If the invoice balance total is greater than the check total from the file then end the loop
                    break;
                }
                else
                {
                    OpenInvoiceList += TmpInvCustTransOpen.RecId;
                    DiscList += lDiscount;
                    next TmpInvCustTransOpen;
                }
                */
                // SKS_19380_FlintfoxAresInvoiceApplicaiton

                OpenInvoiceList += TmpInvCustTransOpen.RecId;
                DiscList += lDiscount;

                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                /*
                if (!remainingMatchAmount)
                {
                    TmpInvCustTransOpen = null;//If the invoice balance total is greater than the check total from the file then end the loop
                    break;
                }
                */
                // SKS_19380_FlintfoxAresInvoiceApplicaiton

                next TmpInvCustTransOpen;
            }
            else
            {
                next TmpInvCustTransOpen;
            }
        }

        if((lBalance >= (_MatchAmt - _Tolerance)) && (lBalance <= (_MatchAmt + _Tolerance)))//Invoice balances are within the payment total with tolerances. Create the payment line and settlements
        {
            SKS_LB_UnstructuredMatchContainers.goodinv(OpenInvoiceList);
            SKS_LB_UnstructuredMatchContainers.ConDiscount(DiscList);
        }

        return SKS_LB_UnstructuredMatchContainers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>InvoiceBalanceTotalSearch</Name>
				<Source><![CDATA[
    public SKS_LB_UnstructuredMatchContainers InvoiceBalanceTotalSearch(AmountCur  _matchAmt, Amountcur _tolerance, AccountNum _CustAccount, container _VirtualCompanyCompanies, CompanyID _CustomerCompany)
    {
        container               OpenInvoiceList;
        container               DiscList;
        CustTrans               TmpInvCustTrans;
        CustTransOpen           TmpInvCustTransOpen;
        SpecTrans               lSpecTrans;
        SKS_LB_JournalAR        lSKS_LB_Journalar;
        SKS_LB_JournalARApplic  lSKS_LB_JournalArApplic;
        AmountCur               lDiscount;
        AmountCur               lBalance;
        AmountCur               UniqueMatchAmt;
        CustTable               TmpCustTable;
        CustTable               lCustTable;
        DirPartyTable           dirPartyTable;
        SKS_LB_UnstructuredMatchContainers SKS_LB_UnstructuredMatchContainers = new SKS_LB_UnstructuredMatchContainers();

        Select crossCompany:_virtualCompanyCompanies AccountNum, Party, DefaultDimension
                from TmpCustTable
                join Name
                    from dirPartyTable
                    WHERE TmpCustTable.Party == dirPartyTable.RecId
                        && TmpCustTable.AccountNum == _CustAccount
                        && TmpCustTable.dataareaid == _CustomerCompany;

        //Find by invoice balance with tolerance
        while select crosscompany:_VirtualCompanyCompanies AmountCur from TmpInvCustTransOpen order by TmpInvCustTransOpen.duedate asc
                where TmpInvCustTransOpen.AccountNum == _CustAccount
            join RecId from TmpInvCustTrans
                where TmpInvCustTransOpen.RefRecId == TmpInvCustTrans.recid
            join lCustTable
                where lCustTable.AccountNum == TmpInvCustTransOpen.AccountNum
                    && lCustTable.Party == TmpCustTable.Party
            // SKS_19380_FlintfoxAresInvoiceApplicaiton
            //notExists join refcompany, RefTableId, RefRecId from lSpectrans
            //    where TmpInvCustTransOpen.dataareaid == lSpecTrans.RefCompany
            //        && TmpInvCustTransOpen.TableId == lSpecTrans.reftableid
            //        && TmpInvCustTransOpen.recid == lSpecTrans.refrecid
            // SKS_19380_FlintfoxAresInvoiceApplicaiton
        {
            select crosscompany:_virtualCompanyCompanies lSKS_LB_JournalARApplic
                where TmpInvCustTransOpen.dataAreaId == lSKS_LB_JournalARApplic.CustTransDataAreaId
                    && TmpInvCustTransOpen.recid == lSKS_LB_JournalARApplic.CustTransOpenRecId
                    && lSKS_LB_JournalARApplic.SettleAmountCur != 0
                join lSKS_LB_JournalAR
                where lSKS_LB_JournalAR.recid == lSKS_LB_JournalARApplic.SKS_LB_JournalARRecId
                    && lSKS_LB_JournalAR.LedgerJournalTransRecId == 0;

            if(!lSKS_LB_JournalarApplic)
            {
                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                //UniqueMatchAmt += TmpInvCustTransOpen.AmountCur;
                Amount remainingAmount = TmpInvCustTransOpen.sksGetRemainingAmount(false);
                UniqueMatchAmt += remainingAmount;
                // SKS_19380_FlintfoxAresInvoiceApplicaiton
                OpenInvoiceList += TmpInvCustTransOpen.RecId;
            }
        }

        if(abs(_MatchAmt - UniqueMatchAmt) <= _tolerance)//Settlement amount matches total invoice balance within the tolerance amount
        {
            SKS_LB_UnstructuredMatchContainers.goodinv(OpenInvoiceList);
        }

        return SKS_LB_UnstructuredMatchContainers;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>