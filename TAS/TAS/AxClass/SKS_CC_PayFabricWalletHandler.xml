<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SKS_CC_PayFabricWalletHandler</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The SKS_CC_PayFabricWalletHandler class implements credit card processing for a PayFabric Connector.
/// </summary>
using Retail=Microsoft.Dynamics.Retail;
using System.Web;

class SKS_CC_PayFabricWalletHandler
{
    const str PFWebServLoc = 'PFWebServLoc';
    const str PFWebHostedPage = 'PFWebHostedPage';
    const str PayFabricOperation = 'PayFabricOperation';
    const str PayFabric_Operation = 'PayFabric Operation';
    const str RefreshAllCreditCards = 'RefreshAllCreditCards';
    const str CustomerId = 'CustomerId';
    const str Customer_Id = 'Customer Id';
    const str PayFabric_Card_Id = 'PayFabric Card Id';
    const str CreditCardPaymentCardPropertyName_Company = 'Company';
    const str CreditCardPaymentCardPropertyName_Note = 'Note';
    const str CreditCardPaymentCardPropertyName_EMail = 'EMail';
    const str StreetAddress3 = 'StreetAddress3';
    const str IsDefaultCard = 'IsDefaultCard';
    const str YesDfltCard = 'Yes';
    const boolean Decrypt = false;
    const str constCustomerName = 'CustomerName';
    const str constNotificationEmail = 'NotificationEmail';
    const str constNotificationPhone = 'NotificationPhone';
    const str constCustomerMessage = 'CustomeMessage';
    const str constEmailOrSMS = 'Email or SMS';
    const str constEmail = 'Email';
    const str constSMS = 'SMS';
    const str constPLWebServiceLoc = 'PLWebSvcLoc';

    #OCCRetryCount


    str             pfUrlWithSecToken;
    str             pfSecurityToken;
    str             pfBaseURL, pfWebBaseURL;
    CustTable       custTable;
    CustAccount     custAccount;
    RefTableId      oneTimeCustRefTableId;
    RefRecId        oneTimeCustRefRecId;
    str             payFabricCustomerNbr;
    Common          payLinkCallerRecord;
        

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getPayFabricCreateWalletUrl</Name>
				<Source><![CDATA[
    public str getPayFabricCreateWalletUrl()
    {
        LogisticsPostalAddress  logisticsPostalAddress;
        Phone                   phone = '';
        Email                   email = '';
        str                     tmpStr;
        counter                 i;

        if (!custAccount)
        {
            throw error(strFmt("@SKS6053", error::wrongUseOfFunction(funcName())));
        }

        this.getPayFabricSecurityToken();

        custTable = custTable::find(custAccount);
        if (!custTable.RecId)
        {
            throw error(strFmt("@SKS6054", custAccount));
        }

        if (!pfSecurityToken)
        {
            throw error(strFmt("@SKS6055", custAccount));
        }
        
        if (!oneTimeCustRefRecId)
        {
            phone = custTable.phone();
            email = custTable.email();
            logisticsPostalAddress = custTable.postalAddress();

            if (!logisticsPostalAddress)
            {
                logisticsPostalAddress.clear();
            }
        }        

        if (!strEndsWith(pfWebBaseURL, '/'))
        {
            pfWebBaseURL = pfWebBaseURL + '/';
        }

        str custAccountEncoded = HttpUtility::UrlEncode(custAccount);
        str payFabricCustomerNbrEncoded;

        if (payFabricCustomerNbr)
        {
            payFabricCustomerNbrEncoded = HttpUtility::UrlEncode(payFabricCustomerNbr);
        }

        pfUrlWithSecToken = strFmt('%1Wallet/Create?customer=%2&tender=CreditCard&token=%3',
            pfWebBaseURL, payFabricCustomerNbrEncoded ? payFabricCustomerNbrEncoded : custAccountEncoded, pfSecurityToken);

        if (logisticsPostalAddress)
        {
            if (logisticsPostalAddress.CountryRegionId)
            {
                str countryRegionIdEncoded = HttpUtility::UrlEncode(logisticsPostalAddress.CountryRegionId);
                pfUrlWithSecToken = strFmt('%1&Country=%2', pfUrlWithSecToken, countryRegionIdEncoded);
            }

            if (logisticsPostalAddress.Street)
            {
                do
                {
                    tmpStr = '';
                    tmpStr = strline(logisticsPostalAddress.Street, i);

                    if (tmpStr)
                    {
                        str tmpStrEncoded = HttpUtility::UrlEncode(tmpStr);
                        pfUrlWithSecToken = strFmt('%1&Street%2=%3', pfUrlWithSecToken, int2str(i+1), tmpStrEncoded);
                    }
                    i++;
                }
                while (tmpStr && i <= 2);
            }

            if (logisticsPostalAddress.City)
            {
                str cityEncoded = HttpUtility::UrlEncode(logisticsPostalAddress.City);
                pfUrlWithSecToken = strFmt('%1&City=%2', pfUrlWithSecToken, cityEncoded);
            }

            if (logisticsPostalAddress.State)
            {
                str stateEncoded = HttpUtility::UrlEncode(logisticsPostalAddress.State);
                pfUrlWithSecToken = strFmt('%1&State=%2', pfUrlWithSecToken, stateEncoded);
            }

            if (logisticsPostalAddress.ZipCode)
            {
                str zipCodeEncoded = HttpUtility::UrlEncode(logisticsPostalAddress.ZipCode);
                pfUrlWithSecToken = strFmt('%1&Zip=%2', pfUrlWithSecToken, zipCodeEncoded);
            }
        }

        if (email)
        {
            str emailEncoded = HttpUtility::UrlEncode(email);
            pfUrlWithSecToken = strFmt('%1&Email=%2', pfUrlWithSecToken, emailEncoded);
        }

        if (phone)
        {
            str phoneEncoded = HttpUtility::UrlEncode(phone);
            pfUrlWithSecToken = strFmt('%1&Phone=%2', pfUrlWithSecToken, phoneEncoded);
        }        

        return pfUrlWithSecToken;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricSecurityToken</Name>
				<Source><![CDATA[
    public void getPayFabricSecurityToken()
    {
        const str GetSecurityToken = 'GetSecurityToken';
        const str PayFabricSecurityToken = 'PayFabricSecurityToken';

        CreditCardProcessors                                    activeCreditCardProcessors;        
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;        
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;
        Retail.PaymentSDK.Portable.PaymentProperty              property;
        InteropPermission                                       perm = new InteropPermission(InteropKind::ClrInterop);

        perm.assert();
        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
                  creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;

        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);        

        property = CreditCardConnectorSetup::findPropertyByName(processorProperties,
                                                            Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_MerchantAccount(),
                                                            PFWebServLoc);

        pfBaseURL = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());

        property = CreditCardConnectorSetup::findPropertyByName(processorProperties,
                                                            Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_MerchantAccount(),
                                                            PFWebHostedPage);

        pfWebBaseURL = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());

        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricOperation, CreditCardPropertySecurityLevel::None,
                                                                    PayFabric_Operation, PayFabric_Operation, GetSecurityToken));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());

        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS6062", strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            property = CreditCardConnectorSetup::findPropertyByName(paymentCardProperties,
                                                                Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                PayFabricSecurityToken);

            if(property)
            {
                pfSecurityToken = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
            }
            else
            {
                throw error("@SKS6063");
            }
        }    
        else
        {
            throw error("@SKS6408");
        } 

        CodeAccessPermission::revertAssert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricCreditCardsForCustomer</Name>
				<Source><![CDATA[
    public CreditCardPaymentProperties getPayFabricCreditCardsForCustomer()
    {
        const str SyncAllCreditCards = 'SyncAllCreditCards';

        CreditCardProcessors                                    activeCreditCardProcessors;        
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;        
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties, allPaymentCardProperties;
        CreditCardPaymentErrors                                 errors;        
        str                                                     pfResponseXml;

        if (!custAccount)
        {
            throw error(strFmt("@SKS6056", error::wrongUseOfFunction(funcName())));
        }

        custTable = custTable::find(custAccount);
        if (!custTable.RecId)
        {
            throw error(strFmt("@SKS6054", custAccount));
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
                  creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;

        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName); 

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricOperation, CreditCardPropertySecurityLevel::None,
                                                                    PayFabric_Operation, PayFabric_Operation, SyncAllCreditCards));

        str custAccountEncoded = HttpUtility::UrlEncode(custAccount);
        str payFabricCustomerNbrEncoded;

        if (payFabricCustomerNbr)
        {
            payFabricCustomerNbrEncoded = HttpUtility::UrlEncode(payFabricCustomerNbr);
        }

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    CustomerId, CreditCardPropertySecurityLevel::PII,
                                                                    Customer_Id, Customer_Id, payFabricCustomerNbrEncoded ? payFabricCustomerNbrEncoded : custAccountEncoded));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());

        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS6057", strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            pfResponseXml = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
            allPaymentCardProperties = CreditCardPaymentProperties::fromProperties(paymentCardProperties);
        }

        return allPaymentCardProperties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricCreditCardTokensForCustomer</Name>
				<Source><![CDATA[
    public str getPayFabricCreditCardTokensForCustomer()
    {
        CreditCardProcessors                                    activeCreditCardProcessors;        
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;        
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;
        Retail.PaymentSDK.Portable.PaymentProperty              property;
        str                                                     pfCards;

        if (!custAccount)
        {
            throw error(strFmt("@SKS6056", error::wrongUseOfFunction(funcName())));
        }

        custTable = custTable::find(custAccount);
        if (!custTable.RecId)
        {
            throw error(strFmt("@SKS6054", custAccount));
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
                  creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;

        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);        
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricOperation, CreditCardPropertySecurityLevel::None,
                                                                    PayFabric_Operation, PayFabric_Operation, RefreshAllCreditCards));

        str custAccountEncoded = HttpUtility::UrlEncode(custAccount);
        str payFabricCustomerNbrEncoded;

        if (payFabricCustomerNbr)
        {
            payFabricCustomerNbrEncoded = HttpUtility::UrlEncode(payFabricCustomerNbr);
        }

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    CustomerId, CreditCardPropertySecurityLevel::PII,
                                                                    Customer_Id, Customer_Id, payFabricCustomerNbrEncoded ? payFabricCustomerNbrEncoded : custAccountEncoded));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());

        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS6058", strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            property = CreditCardConnectorSetup::findPropertyByName(paymentCardProperties,
                                                                    Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_CardToken());

            if (property)
            {
                pfCards = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
            }
        }

        return pfCards;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricEditWalletUrl</Name>
				<Source><![CDATA[
    public str getPayFabricEditWalletUrl(str _pfCardId, str _cardLast4Digits)
    {
        if (!_pfCardId)
        {
            throw error(strFmt("@SKS6060", error::wrongUseOfFunction(funcName())));
        }

        this.getPayFabricSecurityToken();

        if (!pfSecurityToken)
        {
            throw error(strFmt("@SKS6061", custAccount, _cardLast4Digits));
        }

        if (!strEndsWith(pfWebBaseURL, '/'))
        {
            pfWebBaseURL = pfWebBaseURL + '/';
        }

        pfUrlWithSecToken = strFmt('%1Wallet/Edit?card=%2&token=%3', pfWebBaseURL, _pfCardId, pfSecurityToken);

        return pfUrlWithSecToken;
    }

]]></Source>
			</Method>
			<Method>
				<Name>readPayFabricWallet</Name>
				<Source><![CDATA[
    public str readPayFabricWallet(str _pfCardId, str _cardLast4Digits)
    {
        const str ReadCreditCard = 'ReadCreditCard';
        const str PayFabricCardId = 'PayFabricCardId';

        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;        
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;
        Retail.PaymentSDK.Portable.PaymentProperty              property;
        str                                                     pfReadWalletResponseXmlString;
        str                                                     cardCompanyName;

        if (!_pfCardId)
        {
            throw error(strFmt("@SKS6060", error::wrongUseOfFunction(funcName())));
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
        where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
              creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        custTable = custTable::find(custAccount);
        if (!custTable.RecId)
        {
            throw error(strFmt("@SKS6054", custAccount));
        }

        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);        
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        property = CreditCardConnectorSetup::findPropertyByName(processorProperties,
                                                                Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                CreditCardPaymentCardPropertyName_Company);

        if (property)
        {
            cardCompanyName = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
        }
        else
        {
            if (!oneTimeCustRefTableId || !oneTimeCustRefRecId)
            {
                cardCompanyName = custTable.name();
            }
        }

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricOperation, CreditCardPropertySecurityLevel::None,
                                                                    PayFabric_Operation, PayFabric_Operation, ReadCreditCard));

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricCardId, CreditCardPropertySecurityLevel::PII,
                                                                    PayFabric_Card_Id, PayFabric_Card_Id, _pfCardId));

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    CustomerId, CreditCardPropertySecurityLevel::PII,
                                                                    Customer_Id, Customer_Id, payFabricCustomerNbr ? payFabricCustomerNbr : custAccount));

        if (cardCompanyName)
        {
            requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                        CreditCardPaymentCardPropertyName_Company,
            CreditCardPropertySecurityLevel::PII, "@SYS15581", "@SYS84356", cardCompanyName));
        }

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());

        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS6064", _cardLast4Digits ? _cardLast4Digits : _pfCardId, strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            pfReadWalletResponseXmlString = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
        }

        return pfReadWalletResponseXmlString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendAndRecordWalletLink</Name>
				<Source><![CDATA[
    public void sendAndRecordWalletLink(Email _sendToEmail, SMS _sendToSMS, ItemFreeTxt _customerMessage, boolean _skipInfoLog = false)
    {        
        const str constSendWalletLink = 'SendWalletLink';
        
        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;        
        str                                                     pfSendWalletLinkResponseXmlString;
        DirPartyName                                            customerName;

        if (!_sendToEmail && !_sendToSMS)
        {
            throw error(strFmt("@SKS:SKGCCParameterMustBeSpecified", error::wrongUseOfFunction(funcName()), constEmailOrSMS));
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
        where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
              creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        custTable = custTable::find(custAccount);
        if (!custTable.RecId)
        {
            throw error(strFmt("@SKS6054", custAccount));
        }        

        customerName = custTable.name();

        URL PLWebSvcLoc = SKS_PP_Setup::find().CCPLWebServLoc;
        if (!PLWebSvcLoc)
        {
            throw error("@SKS:SKGCCPLWebSvcLocMustBeSpecified");
        }

        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);         

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        str nsPaymCard = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, PayFabricOperation, constSendWalletLink));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPLWebServiceLoc, PLWebSvcLoc));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, CustomerId, payFabricCustomerNbr ? payFabricCustomerNbr : custAccount));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constCustomerName, customerName));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constNotificationEmail, _sendToEmail));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constNotificationPhone, _sendToSMS));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constCustomerMessage, _customerMessage));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());
        
        utcdatetime sendDateTime = DateTimeUtil::utcNow();
        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileSendingWalletLink", custAccount, _sendToEmail ? constEmail : constSMS,
                 _sendToEmail ? _sendToEmail : _sendToSMS, strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            pfSendWalletLinkResponseXmlString = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
        }

        if (!pfSendWalletLinkResponseXmlString)
        {
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileSendingWalletLink", custAccount, _sendToEmail ? constEmail : constSMS,
                 _sendToEmail ? _sendToEmail : _sendToSMS, "@SKS:SKGCCPaylinkResponseIsEmpty"));
        }

        const str constPFWalletResponseLink = 'PFWalletResponseLink';
        const str constPFWalletResponseID = 'PFWalletResponseID';
        CreditCardPaymentProperties responseProperties = CreditCardPaymentProperties::fromXmlString(pfSendWalletLinkResponseXmlString);
        CreditCardPaymentProperty responseProperty;
        SKS_CC_PayLinkQueue payLinkQueue;

        responseProperty = responseProperties.find(nsPaymCard, constPFWalletResponseID);
        str PayLinkID = responseProperty ? responseProperty.parmStringValue() : '';

        if (!PayLinkID)
        {
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileReceivingWalletLink", custAccount, _sendToEmail ? constEmail : constSMS,
                 _sendToEmail ? _sendToEmail : _sendToSMS, "@SKS:SKGCCIdMissingFromPaylinkResponse"));
        }

        responseProperty = responseProperties.find(nsPaymCard, constPFWalletResponseLink);
        str PayLinkURL = responseProperty ? responseProperty.parmStringValue() : '';

        if (!PayLinkURL)
        {
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileReceivingWalletLink", custAccount, _sendToEmail ? constEmail : constSMS,
                 _sendToEmail ? _sendToEmail : _sendToSMS, "@SKS:SKGCCURLMissingFromPaylinkResponse"));
        }

        if (!_skipInfoLog)
        {
            info(strFmt("@SKS:SKGCCWalletLinkSentSuccessMsg", custAccount, _sendToEmail ? _sendToEmail : _sendToSMS));
        }

        try
        {
            ttsbegin;
            payLinkQueue.clear();
            payLinkQueue.PayLinkRequest = requestProperties.toXmlString();
            payLinkQueue.PayLinkResponse = responseProperties.toXmlString();
            payLinkQueue.PayLinkId = PayLinkID;
            payLinkQueue.PayLinkURL = PayLinkURL;
            payLinkQueue.AccountNum = custAccount;
            payLinkQueue.AccountName = customerName;
            payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Pending;
            payLinkQueue.TransType = SKS_CC_PayLinkTransactionType::WalletLink;
            payLinkQueue.Entity = SKS_CC_PayLinkEntityType::CreditCardWalletLink;
            payLinkQueue.PFCustomerNbr = payFabricCustomerNbr;
            payLinkQueue.Email = _sendToEmail;
            payLinkQueue.SMS = _sendToSMS;
            payLinkQueue.PayLinkCustomerMessage = _customerMessage;
            payLinkQueue.SentDateTime = sendDateTime;

            if (oneTimeCustRefTableId && oneTimeCustRefRecId)
            {
                payLinkQueue.IsOneTimeCust = NoYes::Yes;
                payLinkQueue.RefTableId = oneTimeCustRefTableId;
                payLinkQueue.RefRecId = oneTimeCustRefRecId;
            }

            payLinkQueue.insert();
            ttscommit;
        }
        catch(Exception::Error)
        {
            ttsabort;
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileRecordingWalletLink", custAccount));
        }

        if (!_skipInfoLog)
        {
            info(strFmt("@SKS:SKGCCWalletLinkRecordSuccessMsg", custAccount, PayLinkID));  
        }     
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendAndRecordPayLink</Name>
				<Source><![CDATA[
    public void sendAndRecordPayLink(Email _sendToEmail,
        SMS _sendToSMS,
        Amount _linkAmount,
        Amount _documentAmount,     
        Amount _taxAmount,  
        ItemFreeTxt _customerMessage,
        boolean _isPreAuth = false)
    {        
        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;        
        str                                                     pfSendWalletLinkResponseXmlString;
        DirPartyName                                            customerName;

        if (!_sendToEmail && !_sendToSMS)
        {
            throw error(strFmt("@SKS:SKGCCParameterMustBeSpecified", error::wrongUseOfFunction(funcName()), constEmailOrSMS));
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
        where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
              creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        custTable = custTable::find(custAccount);
        if (!custTable.RecId)
        {
            throw error(strFmt("@SKS6054", custAccount));
        }

        customerName = custTable.name();

        SKS_PP_Setup sKS_PP_Setup = SKS_PP_Setup::find();
        URL PLWebSvcLoc = sKS_PP_Setup.CCPLWebServLoc;
        if (!PLWebSvcLoc)
        {
            throw error("@SKS:SKGCCPLWebSvcLocMustBeSpecified");
        }
        
        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);
        
        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        str PFTransType;
        if (_isPreAuth)
        {
            PFTransType = 'Book';
        }
        else
        {
            PFTransType = 'Sale';
        }
        
        SalesTable payLinkSalesTableCaller;
        SMAServiceOrderTable payLinkServiceOrderCaller;
        LedgerJournalTrans payLinkJournalTransCaller;
        CurrencyCode currencyCode;
        SalesShippingDateRequested payLinkDocDate;        
        str strDateTimeStamp;
        str payLinkDocumentNumber;
        str originDocType, originDocId;
        str isMultipleInvoice = 'False';
        
        strDateTimeStamp = DateTimeUtil::toStr(DateTimeUtil::utcNow());
        strDateTimeStamp = strRem(strDateTimeStamp, '-T:/');

        switch (payLinkCallerRecord.TableId)
        {
            case tableNum(SalesTable):
                payLinkSalesTableCaller = payLinkCallerRecord;
                currencyCode = payLinkSalesTableCaller.CurrencyCode;
                
                if (payLinkSalesTableCaller.CustomerRef && !sKS_PP_Setup.CCPLDisableCustRefOnPayLinkDocNbr)
                {
                    payLinkDocumentNumber = strFmt('%1_%2', payLinkSalesTableCaller.SalesId, payLinkSalesTableCaller.CustomerRef);
                }
                else
                {
                    payLinkDocumentNumber = payLinkSalesTableCaller.SalesId;
                }
                payLinkDocumentNumber = strFmt('%1_%2', payLinkDocumentNumber, strDateTimeStamp);
                payLinkDocDate = payLinkSalesTableCaller.ShippingDateRequested;
                originDocType = fieldid2pname(tableNum(SalesTable), fieldNum(SalesTable, SalesId));
                originDocId = payLinkSalesTableCaller.SalesId;
                break;
            case tableNum(SMAServiceOrderTable):
                payLinkServiceOrderCaller = payLinkCallerRecord;
                ProjTable projTableCaller = ProjTable::find(payLinkServiceOrderCaller.ProjId);
                currencyCode = projTableCaller.projInvoice().CurrencyId;
                payLinkDocumentNumber = strFmt('%1_%2', payLinkServiceOrderCaller.ServiceOrderId, strDateTimeStamp);
                payLinkDocDate = DateTimeUtil::date(payLinkServiceOrderCaller.ServiceDateTime);
                originDocType = fieldid2pname(tableNum(SMAServiceOrderTable), fieldNum(SMAServiceOrderTable, ServiceOrderId));
                originDocId = payLinkServiceOrderCaller.ServiceOrderId;
                break;
            case tableNum(LedgerJournalTrans):
                payLinkJournalTransCaller = payLinkCallerRecord;
                currencyCode = payLinkJournalTransCaller.CurrencyCode;

                if (payLinkJournalTransCaller.MarkedInvoiceRecId && payLinkJournalTransCaller.MarkedInvoice)
                {
                    payLinkDocumentNumber = strFmt('%1_%2', payLinkJournalTransCaller.MarkedInvoice, strDateTimeStamp);
                }
                else
                {
                    payLinkDocumentNumber = strFmt('%1_%2_%3', payLinkJournalTransCaller.JournalNum, payLinkJournalTransCaller.Voucher, strDateTimeStamp);
                }
                
                payLinkDocDate = payLinkJournalTransCaller.TransDate;
                originDocType = fieldid2pname(tableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, JournalNum));
                originDocId = strFmt('%1_%2', payLinkJournalTransCaller.JournalNum, payLinkJournalTransCaller.Voucher);
                break;
        }

        const str constSendPayLink = 'SendPayLink';
        const str constTransactionType = 'TransactionType';
        const str constCurrencyId = 'CurrencyId';
        const str constAmount = 'Amount';
        const str constDocumentAmount = 'DocumentAmount';
        const str constDocumentNumber = 'DocumentNumber';
        const str constDocDate = 'DocDate';
        const str constTaxAmount = 'TaxAmount';
        const str constIsMultipleInvoice = 'IsMultipleInvoice';

        str nsPaymCard = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, PayFabricOperation, constSendPayLink));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPLWebServiceLoc, PLWebSvcLoc));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, CustomerId, payFabricCustomerNbr ? payFabricCustomerNbr : custAccount));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constCustomerName, customerName));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constNotificationEmail, _sendToEmail));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constNotificationPhone, _sendToSMS));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constAmount, _linkAmount));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constDocumentAmount, _documentAmount));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constTaxAmount, _taxAmount));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constCustomerMessage, _customerMessage));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constTransactionType, PFTransType));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constCurrencyId, currencyCode));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constDocumentNumber, payLinkDocumentNumber));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constDocDate, payLinkDocDate));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constIsMultipleInvoice, isMultipleInvoice));
        
        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());
        
        utcdatetime sendDateTime = DateTimeUtil::utcNow();
        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());
        
        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileSendingPayLink", custAccount, originDocType, originDocId,
                _sendToEmail ? constEmail : constSMS, _sendToEmail ? _sendToEmail : _sendToSMS,
                strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            pfSendWalletLinkResponseXmlString = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
        }

        if (!pfSendWalletLinkResponseXmlString)
        {
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileSendingPayLink", custAccount, originDocType, originDocId,
                _sendToEmail ? constEmail : constSMS, _sendToEmail ? _sendToEmail : _sendToSMS,
                strReplace(errors.toString(), '\n', '; ')));
        }
        
        const str constPFPayLinkResponseLink = 'PFPayLinkResponseLink';
        const str constPFPayLinkResponseID = 'PFPayLinkResponseID';
        CreditCardPaymentProperties responseProperties = CreditCardPaymentProperties::fromXmlString(pfSendWalletLinkResponseXmlString);
        CreditCardPaymentProperty responseProperty;
        SKS_CC_PayLinkQueue payLinkQueue;

        responseProperty = responseProperties.find(nsPaymCard, constPFPayLinkResponseID);
        str PayLinkID = responseProperty ? responseProperty.parmStringValue() : '';

        if (!PayLinkID)
        {
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileReceivingPayLink", custAccount, originDocType, originDocId,
                "@SKS:SKGCCIdMissingFromPaylinkResponse"));
        }

        responseProperty = responseProperties.find(nsPaymCard, constPFPayLinkResponseLink);
        str PayLinkURL = responseProperty ? responseProperty.parmStringValue() : '';
        
        if (!PayLinkURL)
        {
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileReceivingPayLink", custAccount, originDocType, originDocId,
                "@SKS:SKGCCURLMissingFromPaylinkResponse"));
        }

        info(strFmt("@SKS:SKGCCPayLinkSentSuccessMsg", custAccount, originDocType, originDocId, _sendToEmail ? _sendToEmail : _sendToSMS));

        try
        {
            ttsbegin;
            payLinkQueue.clear();
            payLinkQueue.PayLinkRequest = requestProperties.toXmlString();
            payLinkQueue.PayLinkResponse = responseProperties.toXmlString();
            payLinkQueue.PayLinkId = PayLinkID;
            payLinkQueue.PayLinkURL = PayLinkURL;
            payLinkQueue.AccountNum = custAccount;
            payLinkQueue.AccountName = customerName;
            payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Pending;
            payLinkQueue.TransType = SKS_CC_PayLinkTransactionType::PayLink;            
            payLinkQueue.Amount = _linkAmount;
            payLinkQueue.CurrencyCode = currencyCode;
            
            switch (payLinkCallerRecord.TableId)
            {
                case tableNum(SalesTable):
                    payLinkQueue.EntityReference = payLinkSalesTableCaller.SalesId;
                    payLinkQueue.SalesOrderId = payLinkQueue.EntityReference;
                    if (_isPreAuth)
                    {
                        payLinkQueue.Entity = SKS_CC_PayLinkEntityType::SalesOrderPreAuth;
                    }
                    else
                    {
                        payLinkQueue.Entity = SKS_CC_PayLinkEntityType::SalesOrderPrePayment;
                    }
                    payLinkQueue.IsCallCenterSalesOrder = payLinkSalesTableCaller.mcrIsCallCenter();
                    break;
                case tableNum(SMAServiceOrderTable):
                    payLinkQueue.EntityReference = payLinkServiceOrderCaller.ServiceOrderId;
                    payLinkQueue.SMAServiceOrderId = payLinkQueue.EntityReference;
                    payLinkQueue.Entity = SKS_CC_PayLinkEntityType::ProjServiceOrderPreAuth;
                    break;
                case tableNum(LedgerJournalTrans):
                    payLinkQueue.EntityReference = payLinkJournalTransCaller.JournalNum;
                    payLinkQueue.JournalNum = payLinkQueue.EntityReference;
                    payLinkQueue.JournalLineVoucher = payLinkJournalTransCaller.Voucher;
                    payLinkQueue.JournalLineNum = payLinkJournalTransCaller.LineNum;
                    payLinkQueue.Entity = SKS_CC_PayLinkEntityType::PaymentJournalCapture;
                    break;
            }            
            
            payLinkQueue.PFCustomerNbr = payFabricCustomerNbr;
            payLinkQueue.Email = _sendToEmail;
            payLinkQueue.SMS = _sendToSMS;            
            payLinkQueue.SentDateTime = sendDateTime;
            payLinkQueue.RefTableId = payLinkCallerRecord.TableId;
            payLinkQueue.RefRecId = payLinkCallerRecord.RecId;

            if (oneTimeCustRefTableId && oneTimeCustRefRecId)
            {
                payLinkQueue.IsOneTimeCust = NoYes::Yes;
            }

            payLinkQueue.insert();
            ttscommit;
        }
        catch(Exception::Error)
        {
            ttsabort;
            throw error(strFmt("@SKS:SKGCCErrorMsgWhileRecordingPayLink", custAccount, originDocType, originDocId));
        }

        info(strFmt("@SKS:SKGCCPayLinkRecordSuccessMsg", custAccount, originDocType, originDocId, PayLinkID));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPayLinkCallerRecord</Name>
				<Source><![CDATA[
    public Common parmPayLinkCallerRecord(Common _payLinkCallerRecord = payLinkCallerRecord)
    {
        payLinkCallerRecord = _payLinkCallerRecord;
        return payLinkCallerRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshCreditCardsFromPayFabric</Name>
				<Source><![CDATA[
    public boolean refreshCreditCardsFromPayFabric(str                      _pfCardTokens,
                                                   CreditCardProcessorsId   _processorId,
                                                   str                      _cardLast4Digits,
                                                   boolean                  _isCreateOnly = true,
                                                   boolean                  _isSilent = true)
    {        
        CreditCardCust              creditCardCust;        
        str                         curCardToken;
        str                         curReadWalletResponseXmlString;
        str                         lastCLRExceptionMsg;
        container                   conCardToken;
        Map                         pfCardMapInAX;
        MapEnumerator               meCardMap;
        RecId                       curCreditCardCustRecId;
        boolean                     retVal;
        int                         j, nbrOfCardsCreated, nbrOfCardsUpdated, nbrOfCardsDeleted;

        if (!custAccount || !_processorId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        pfCardMapInAX = SKS_CC_PayFabricWalletHandler::getPayFabricCreditCardsMap(custAccount, oneTimeCustRefTableId, oneTimeCustRefRecId);

        if (_pfCardTokens)
        {
            conCardToken = str2con(_pfCardTokens, '|');
            if (!conCardToken)
            {
                return false;
            }

            for (j=1;j<=conLen(conCardToken);j++)
            {
                curCardToken = conPeek(conCardToken, j);
                if (!curCardToken)
                {
                    continue;
                }

                curReadWalletResponseXmlString = this.readPayFabricWallet(curCardToken, _cardLast4Digits);
                if (!curReadWalletResponseXmlString)
                {
                    continue;
                }

                if (pfCardMapInAX != null && pfCardMapInAX.elements() && pfCardMapInAX.exists(curCardToken))
                {
                    if (_isCreateOnly)
                    {
                        continue;
                    }
                    else
                    {
                        // It is an existing PayFabric wallet. Update CreditCardCust record in AX.
                        curCreditCardCustRecId = pfCardMapInAX.lookup(curCardToken);
                        select firstOnly1 RecId from creditCardCust
                            where creditCardCust.RecId == curCreditCardCustRecId;

                        if (!creditCardCust.RecId)
                        {
                            continue;
                        }

                        try
                        {
                            ttsBegin;
                            SKS_CC_PayFabricWalletHandler::updateCreditCardFromPayFabricResponse(curReadWalletResponseXmlString, curCreditCardCustRecId, creditCardCust.CardNumber);
                            ttsCommit;
                            nbrOfCardsUpdated++;
                        }
                        catch (Exception::CLRError)
                        {
                            ttsAbort;
                            lastCLRExceptionMsg = this.getClrExceptionMessage();
                            error(strFmt("@SKS6065", curCardToken, lastCLRExceptionMsg));
                            continue;
                        }
                        catch (Exception::Error)
                        {
                            ttsAbort;
                            error(strFmt("@SKS6066", curCardToken));
                            continue;
                        }
                    }
                }
                else
                {
                    // It is a new PayFabric wallet. Create a new CreditCardCust record in AX.
                    CreditCardCust creditCardCustNew;
                    try
                    {                        
                        ttsBegin;
                        creditCardCustNew = CreditCard::addCreditCard(curReadWalletResponseXmlString, custAccount, _processorId);
                        ttsCommit;
                        nbrOfCardsCreated++;                        
                    }
                    catch (Exception::CLRError)
                    {
                        ttsAbort;
                        lastCLRExceptionMsg = this.getClrExceptionMessage();
                        error(strFmt("@SKS6067", curCardToken, lastCLRExceptionMsg));
                        continue;
                    }
                    catch (Exception::Error)
                    {
                        ttsAbort;
                        error(strFmt("@SKS6068", curCardToken));
                        continue;
                    }

                    if (creditCardCustNew && oneTimeCustRefTableId && oneTimeCustRefRecId)
                    {
                        try
                        {
                            ttsbegin;
                            creditCardCustNew.selectForUpdate(true);
                            creditCardCustNew.SKS_CC_OneTimeCustRefTableId = oneTimeCustRefTableId;
                            creditCardCustNew.SKS_CC_OneTimeCustRefRecId = oneTimeCustRefRecId;
                            creditCardCustNew.doUpdate();
                            ttsCommit;
                        }
                        catch (Exception::Error)
                        {
                            ttsAbort;
                            error(strFmt("@SKS6066", curCardToken));
                            continue;
                        }
                    }
                }
            }
        }

        // Search to see if any cards have been deleted from PayFabric and need to be removed in Ax.
        if (!_isCreateOnly && pfCardMapInAX != null && pfCardMapInAX.elements())
        {
            meCardMap = new MapEnumerator(pfCardMapInAX);
            while (meCardMap.moveNext())
            {
                curCardToken = meCardMap.currentKey();

                if (!curCardToken)
                {
                    continue;
                }

                if (conFind(conCardToken, curCardToken))
                {
                    continue;
                }

                curCreditCardCustRecId = meCardMap.currentValue();

                select firstOnly1 forUpdate creditCardCust
                    where creditCardCust.RecId == curCreditCardCustRecId;

                if (!creditCardCust.RecId)
                {
                    continue;
                }

                if (!SKS_CC_PayFabricWalletHandler::validateDeleteForOpenAuth(creditCardCust.RecId, true))
                {
                    if (!_isSilent)
                    {
                        checkFailed(strFmt("@SKS6069", creditCardCust.CardNumber));                        
                    }
                    continue;
                }

                try
                {
                    ttsBegin;
                    creditCardCust.delete();
                    ttsCommit;
                    nbrOfCardsDeleted++;
                }
                catch (Exception::Error)
                {
                    ttsAbort;
                    error(strFmt("@SKS6071", curCardToken));
                    continue;
                }
            }
        }

        if (!_isSilent)
        {
            str resultMsg = strFmt("@SKS:SKGCCSyncResultsMsg", nbrOfCardsCreated, nbrOfCardsUpdated, nbrOfCardsDeleted);
            info(resultMsg);
        }

        if (nbrOfCardsCreated || nbrOfCardsUpdated || nbrOfCardsDeleted)
        {
            retVal = true;
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePayFabricWallet</Name>
				<Source><![CDATA[
    public boolean removePayFabricWallet(str _pfCardId, str _cardLast4Digits)
    {
        const str DeleteCreditCard = 'DeleteCreditCard';
        const str PayFabricCardId = 'PayFabricCardId';
        const str PFRemoveCardResult = 'PFRemoveCardResult';

        CreditCardProcessors                                    activeCreditCardProcessors;        
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;        
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;
        Retail.PaymentSDK.Portable.PaymentProperty              property;
        str                                                     removeCreditCardResultStr;
        boolean                                                 removeCreditCardResult;
        str                                                     readCreditCardResultStr;

        if (!_pfCardId)
        {
            throw error(strFmt("@SKS6060", error::wrongUseOfFunction(funcName())));
        }

        readCreditCardResultStr = this.readPayFabricWallet(_pfCardId, _cardLast4Digits);
        if (!readCreditCardResultStr)
        {
            error(strFmt("@SKS6076", _cardLast4Digits));
            return false;
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
                  creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);        
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricOperation, CreditCardPropertySecurityLevel::None,
                                                                    PayFabric_Operation, PayFabric_Operation, DeleteCreditCard));

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricCardId, CreditCardPropertySecurityLevel::PII,
                                                                    PayFabric_Card_Id, PayFabric_Card_Id, _pfCardId));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());

        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS6077", _cardLast4Digits, strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            property = CreditCardConnectorSetup::findPropertyByName(paymentCardProperties,
                                                                    Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PFRemoveCardResult);

            if(property)
            {
                removeCreditCardResultStr = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
            }
            else
            {
                throw error("@SKS6063");
            }
        }

        const str trueResultStr = 'True';
        if (removeCreditCardResultStr == trueResultStr)
        {
            removeCreditCardResult = true;
        }

        return removeCreditCardResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeCreditCardsFromPayFabric</Name>
				<Source><![CDATA[
    public boolean synchronizeCreditCardsFromPayFabric(CreditCardPaymentProperties  _allPaymentProperties,
                                                       CreditCardProcessorsId       _processorId,
                                                       str                          _cardLast4Digits,
                                                       boolean                      _isCreateOnly = true,
                                                       boolean                      _isSilent = true)
    {
        CreditCardPaymentProperty                               property, curPaymProperty;
        CreditCardPaymentProperties                             curPaymProperties;        
        CreditCardCust                                          creditCardCust;
        str                                                     ns = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        str                                                     curCardToken;
        str                                                     curReadWalletResponseXmlString;
        str                                                     lastCLRExceptionMsg;
        str                                                     curPropertyName;
        str                                                     curStringValue;
        real                                                    curRealValue;
        utcDateTime                                             curDateTimeValue;
        container                                               conCardToken;
        Map                                                     pfCardMapInAX;
        MapEnumerator                                           meCardMap;
        RecId                                                   curCreditCardCustRecId;
        boolean                                                 retVal;
        int                                                     j, nbrOfPFCards;
        int                                                     nbrOfCardsCreated, nbrOfCardsUpdated, nbrOfCardsDeleted;

        void getAndTransferCurPaymentProperty(str _curPropName)
        {
            property = _allPaymentProperties.find(ns, _curPropName + '_' + int2str(j));
            if (property)
            {
                if (property.parmValueType() == CreditCardPropertyDataType::String)
                {
                    curStringValue = property.parmStringValue();
                    curPaymProperty = CreditCardPaymentProperty::newValue(ns, _curPropName, curStringValue);
                }
                else if (property.parmValueType() == CreditCardPropertyDataType::Decimal)
                {
                    curRealValue = property.parmDecimalValue();
                    curPaymProperty = CreditCardPaymentProperty::newValue(ns, _curPropName, curRealValue);
                }
                else if (property.parmValueType() == CreditCardPropertyDataType::DateTime)
                {
                    curDateTimeValue = property.parmDateTimeValue();
                    curPaymProperty = CreditCardPaymentProperty::newValue(ns, _curPropName, curDateTimeValue);
                }
                else
                {
                    return;
                }

                if (curPaymProperty)
                {
                    curPaymProperty.parmSecurityLevel(property.parmSecurityLevel());
                    curPaymProperty.parmIsEncrypted(property.parmIsEncrypted());
                    curPaymProperty.parmIsPassword(property.parmIsPassword());
                    curPaymProperty.parmIsReadonly(property.parmIsReadonly());
                    curPaymProperties.add(curPaymProperty);
                }
            }
        }

        void setNewPaymentProperty()
        {
            if (curPaymProperty)
            {
                curPaymProperty.parmSecurityLevel(property.parmSecurityLevel());
                curPaymProperty.parmIsEncrypted(property.parmIsEncrypted());
                curPaymProperty.parmIsPassword(property.parmIsPassword());
                curPaymProperty.parmIsReadonly(property.parmIsReadonly());
                curPaymProperties.add(curPaymProperty);
            }
        }

        int startTime, endTime, procTime;
        startTime = WinAPIServer::getTickCount();
        const str PFCardCount = 'PFCardCount';        

        if (!custAccount || !_processorId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        pfCardMapInAX = SKS_CC_PayFabricWalletHandler::getPayFabricCreditCardsMap(custAccount, oneTimeCustRefTableId, oneTimeCustRefRecId);

        if (_allPaymentProperties)
        {
            property = _allPaymentProperties.find(ns, PFCardCount);

            if(property)
            {
                nbrOfPFCards = str2int(property.parmStringValue());
            }

            if (nbrOfPFCards)
            {
                for (j = 1;j <= nbrOfPFCards;j++)
                {
                    curStringValue = '';
                    curPaymProperties = null;
                    curPaymProperties = CreditCardPaymentProperties::construct();

                    curPropertyName = CustomerId;
                    property = _allPaymentProperties.find(ns, curPropertyName);
                    if (property)
                    {
                        curPaymProperty = CreditCardPaymentProperty::newValue(property.parmNamespace(), property.parmName(), property.parmStringValue());
                        setNewPaymentProperty();
                    }

                    curPropertyName = CreditCardPaymentCardPropertyName_Company;
                    property = _allPaymentProperties.find(ns, curPropertyName);
                    if (property)
                    {
                        curPaymProperty = CreditCardPaymentProperty::newValue(property.parmNamespace(), property.parmName(), property.parmStringValue());
                        setNewPaymentProperty();
                    }

                    curPropertyName = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.MerchantAccountProperties::get_ServiceAccountId());
                    property = _allPaymentProperties.find(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_MerchantAccount(), curPropertyName);
                    if (property)
                    {
                        curPaymProperty = CreditCardPaymentProperty::newValue(property.parmNamespace(), property.parmName(), property.parmStringValue());
                        setNewPaymentProperty();
                    }

                    curPropertyName = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.ConnectorProperties::get_ConnectorName());
                    property = _allPaymentProperties.find(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_Connector(), curPropertyName);
                    if (property)
                    {
                        curPaymProperty = CreditCardPaymentProperty::newValue(property.parmNamespace(), property.parmName(), property.parmStringValue());
                        setNewPaymentProperty();
                    }

                    curPropertyName = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_CardToken());
                    property = _allPaymentProperties.find(ns, curPropertyName + '_' + int2str(j));
                    if (property)
                    {
                        curCardToken = property.parmStringValue();
                        conCardToken += curCardToken;
                        curPaymProperty = CreditCardPaymentProperty::newValue(property.parmNamespace(), curPropertyName, property.parmStringValue());
                        setNewPaymentProperty();
                    }

                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_Last4Digits()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_CardType()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_Name()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_ExpirationMonth()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_ExpirationYear()));
                    getAndTransferCurPaymentProperty(IsDefaultCard);
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_StreetAddress()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_StreetAddress2()));
                    getAndTransferCurPaymentProperty(StreetAddress3);
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_City()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_State()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_PostalCode()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_Country()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_Phone()));
                    getAndTransferCurPaymentProperty(CreditCardPaymentCardPropertyName_EMail);
                    getAndTransferCurPaymentProperty(CreditCardPaymentCardPropertyName_Note);

                    if (pfCardMapInAX != null && pfCardMapInAX.elements() && pfCardMapInAX.exists(curCardToken))
                    {
                        if (_isCreateOnly)
                        {
                            continue;
                        }
                        else
                        {
                            // It is an existing PayFabric wallet. Update CreditCardCust record in AX.
                            curCreditCardCustRecId = pfCardMapInAX.lookup(curCardToken);

                            select firstOnly1 RecId from creditCardCust
                                where creditCardCust.RecId == curCreditCardCustRecId;

                            if (!creditCardCust.RecId)
                            {
                                continue;
                            }

                            curPropertyName = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId());
                            property = _allPaymentProperties.find(ns, curPropertyName + '_' + int2str(j));
                            if (property)
                            {
                                curPaymProperty = CreditCardPaymentProperty::newValue(property.parmNamespace(), curPropertyName, creditCardCust.UniqueCardId);
                                setNewPaymentProperty();
                            }

                            curReadWalletResponseXmlString = curPaymProperties.toXmlString();
                            try
                            {
                                ttsBegin;
                                SKS_CC_PayFabricWalletHandler::updateCreditCardFromPayFabricResponse(curReadWalletResponseXmlString, curCreditCardCustRecId, creditCardCust.CardNumber);
                                ttsCommit;
                                nbrOfCardsUpdated++;
                            }
                            catch (Exception::CLRError)
                            {
                                ttsAbort;
                                lastCLRExceptionMsg = this.getClrExceptionMessage();
                                error(strFmt("@SKS6078", _cardLast4Digits ? _cardLast4Digits : curCardToken, lastCLRExceptionMsg));
                                continue;
                            }
                            catch (Exception::Error)
                            {
                                ttsAbort;
                                error(strFmt("@SKS6079", _cardLast4Digits ? _cardLast4Digits : curCardToken));
                                continue;
                            }
                        }
                    }
                    else
                    {
                        // It is a new PayFabric wallet. Create a new CreditCardCust record in AX.
                        getAndTransferCurPaymentProperty(CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId()));
                        curReadWalletResponseXmlString = curPaymProperties.toXmlString();

                        CreditCardCust creditCardCustNewLoc;
                        try
                        {
                            ttsBegin;
                            creditCardCustNewLoc = CreditCard::addCreditCard(curReadWalletResponseXmlString, custAccount, _processorId);
                            ttsCommit;
                            nbrOfCardsCreated++;
                        }
                        catch (Exception::CLRError)
                        {
                            ttsAbort;
                            lastCLRExceptionMsg = this.getClrExceptionMessage();
                            error(strFmt("@SKS6080", _cardLast4Digits ? _cardLast4Digits : curCardToken, lastCLRExceptionMsg));
                            continue;
                        }
                        catch (Exception::Error)
                        {
                            ttsAbort;
                            error(strFmt("@SKS6082", _cardLast4Digits ? _cardLast4Digits : curCardToken));
                            continue;
                        }

                        if (creditCardCustNewLoc && oneTimeCustRefTableId && oneTimeCustRefRecId)
                        {
                            try
                            {
                                creditCardCustNewLoc.selectForUpdate(true);
                                ttsbegin;
                                creditCardCustNewLoc.SKS_CC_OneTimeCustRefTableId = oneTimeCustRefTableId;
                                creditCardCustNewLoc.SKS_CC_OneTimeCustRefRecId = oneTimeCustRefRecId;
                                creditCardCustNewLoc.doUpdate();
                                ttscommit;
                            }
                            catch (Exception::Error)
                            {
                                ttsAbort;
                                error(strFmt("@SKS6082", _cardLast4Digits ? _cardLast4Digits : curCardToken));
                                continue;
                            }
                        }
                    }
                }
            }
        }

        // Search to see if any cards have been deleted from PayFabric and need to be removed in AX.
        if (!_isCreateOnly && pfCardMapInAX != null && pfCardMapInAX.elements())
        {
            meCardMap = new MapEnumerator(pfCardMapInAX);
            while (meCardMap.moveNext())
            {
                curCardToken = meCardMap.currentKey();
                if (!curCardToken)
                {
                    continue;
                }

                if (conFind(conCardToken, curCardToken))
                {
                    continue;
                }

                curCreditCardCustRecId = meCardMap.currentValue();

                select firstOnly1 forUpdate creditCardCust
                    where creditCardCust.RecId == curCreditCardCustRecId;

                if (!creditCardCust.RecId)
                {
                    continue;
                }

                if (!SKS_CC_PayFabricWalletHandler::validateDeleteForOpenAuth(creditCardCust.RecId, true))
                {
                    if (!_isSilent)
                    {
                        checkFailed(strFmt("@SKS6083", creditCardCust.CardNumber));
                    }
                    continue;
                }

                try
                {
                    ttsBegin;
                    creditCardCust.delete();
                    ttsCommit;
                    nbrOfCardsDeleted++;
                }
                catch (Exception::Error)
                {
                    ttsAbort;
                    error(strFmt("@SKS6084", _cardLast4Digits ? _cardLast4Digits : curCardToken));
                    continue;
                }
            }
        }

        if (!_isSilent)
        {
            endTime = WinAPIServer::getTickCount();
            procTime = (endTime-startTime) div 1000;
            str resultMsg = strFmt("@SKS:SKGCCSyncResultsMsg", nbrOfCardsCreated, nbrOfCardsUpdated, nbrOfCardsDeleted);
            if (procTime)
            {
                resultMsg += strFmt("@SKS:SKGCCSyncElapsedTime", procTime);
            }

            info(resultMsg);            
        }

        if (nbrOfCardsCreated || nbrOfCardsUpdated || nbrOfCardsDeleted)
        {
            retVal = true;
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricCreditCardsMap</Name>
				<Source><![CDATA[
    public static Map getPayFabricCreditCardsMap(
        custAccount _custAccount,
        RefTableId _oneTimeCustRefTableId = 0,
        RefRecId _oneTimeCustRefRecId = 0
        )        
    {
        Map                                                     pfCardMap;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        CreditCardCust                                          creditCardCust;
        Retail.PaymentSDK.Portable.PaymentProperty[]            paymentCardProperties;
        Retail.PaymentSDK.Portable.PaymentProperty              property;
        str                                                     pfCardId;        

        select firstOnly1 creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors
               && creditCardProcessors.Active == NoYes::Yes
               && creditCardAccountSetup.ConnectorName == SKS_CC_PayFabricWalletHandler::getPayFabricConnectorName();

        if (!creditCardAccountSetup.CreditCardProcessors)
        {
            throw error("@SKS6085");
        }

        pfCardMap = new Map(Types::String, Types::Int64);

        if (_oneTimeCustRefTableId && _oneTimeCustRefRecId)
        {
            select creditCardCust
                where creditCardCust.SKS_CC_OneTimeCustRefTableId == _oneTimeCustRefTableId
                   && creditCardCust.SKS_CC_OneTimeCustRefRecId == _oneTimeCustRefRecId
                   && creditCardCust.CustAccount == _custAccount;
        }
        else
        {
            select creditCardCust
                where creditCardCust.CustAccount == _custAccount;
        }

        while (creditCardCust.RecId != 0)
        {
            if (creditCardCust.CreditCardProcessors)
            {
                paymentCardProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(creditCardCust.CardToken);

                if (paymentCardProperties != null)
                {
                    property = CreditCardConnectorSetup::findPropertyByName(paymentCardProperties,
                                                                            Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                            Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_CardToken());

                    if (property)
                    {
                        pfCardId = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
                    }

                    if (pfCardId)
                    {
                        pfCardMap.insert(pfCardId, creditCardCust.RecId);
                    }
                }
            }

            next creditCardCust;
        }        

        return pfCardMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addNewPayFabricCardFromMCR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new PayFabric credit card from MCR
    /// </summary>
    /// <returns>
    /// New CreditCardCust record created.
    /// </returns>
    static client CreditCardCust addNewPayFabricCardFromMCR(
        custAccount _custAccount,
        RefTableId  _oneTimeCustRefTableId = 0,
        RefRecId    _oneTimeCustRefRecId = 0)
    {
        CreditCardPaymentCardTokenize   cardTokenize;
        CreditCardProcessors            activeCreditCardProcessors;
        CustTable                       custTable;
        CreditCardCust                  newCreditCardCust;
        SKS_CC_PayFabricWalletHandler   pfWalletHandler;
        str                             pfUrl;
        Args                            args = new Args();        

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        cardTokenize = CreditCardPaymentCardTokenize::construct();

        cardTokenize.init(activeCreditCardProcessors.Name);
        cardTokenize.parmCustAccount(_custAccount);

        pfWalletHandler = SKS_CC_PayFabricWalletHandler::construct();
        pfWalletHandler.parmCustAccount(_custAccount);
        if (_oneTimeCustRefTableId && _oneTimeCustRefRecId)
        {
            pfWalletHandler.parmOneTimeCustRefTableId(_oneTimeCustRefTableId);
            pfWalletHandler.parmOneTimeCustRefRecId(_oneTimeCustRefRecId);
        }
        pfWalletHandler.setPayFabricCustomerNbr();
        pfUrl = pfWalletHandler.getPayFabricCreateWalletUrl();
        custTable = CustTable::find(_custAccount);       

        args.record(custTable);
        args.parm(pfUrl);
        args.parmEnumType(enumnum(NoYesCombo));
        args.parmEnum(NoYesCombo::Yes);

        MenuFunction menuFunction;
        menuFunction = new MenuFunction(menuitemDisplayStr(SKS_CC_PayFabricWalletMaintain), MenuItemType::Display);
        menuFunction.run(args);        

        return newCreditCardCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPayFabricProcessorSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets whether PayFabric has been setup in Payment services form
    /// </summary>
    /// <returns>
    /// true if PayFabric has been setup in Payment services form; otherwise, false.
    /// </returns>
    static server boolean hasPayFabricProcessorSetup()
    {
        CreditCardAccountSetup          creditCardAccountSetup;
        CreditCardProcessors            creditCardProcessors;
        boolean                         ret;

        select firstOnly1 creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors
               && creditCardAccountSetup.ConnectorName == SKS_CC_PayFabricWalletHandler::getPayFabricConnectorName();

        if (creditCardAccountSetup)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPayFabricActiveProcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets whether PayFabric is the active payment connector processor
    /// </summary>
    /// <returns>
    /// true if active payment connector processor is PayFabric; otherwise, false.
    /// </returns>
    static server boolean isPayFabricActiveProcessor()
    {
        CreditCardAccountSetup          creditCardAccountSetup;
        CreditCardProcessors            creditCardProcessors;
        CreditCardProcessors            activeCreditCardProcessors;
        boolean                         ret;

        select firstonly activeCreditCardProcessors
            where activeCreditCardProcessors.Active;
        
        if (activeCreditCardProcessors)
        {
            select firstOnly1 creditCardAccountSetup
            exists join creditCardProcessors
                where creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors
                   && creditCardProcessors.Name  == activeCreditCardProcessors.Name;

            if (creditCardAccountSetup.RecId &&
                creditCardAccountSetup.ConnectorName == SKS_CC_PayFabricWalletHandler::getPayFabricConnectorName())
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPayFabricProcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets whether a processor is a PayFabric payment connector
    /// </summary>
    /// <returns>
    /// true if processor is PayFabric payment connector; otherwise, false.
    /// </returns>
    static server boolean isPayFabricProcessor(RecId _processorRecId)
    {
        CreditCardAccountSetup          creditCardAccountSetup;
        boolean                         ret;

        select firstOnly1 creditCardAccountSetup
        where creditCardAccountSetup.CreditCardProcessors == _processorRecId
           && creditCardAccountSetup.ConnectorName == SKS_CC_PayFabricWalletHandler::getPayFabricConnectorName();

        if (creditCardAccountSetup)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPayFabricProcessorOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets whether PayFabric is the only processor that has been setup in Payment services form
    /// </summary>
    /// <returns>
    /// true if PayFabric is the only processor setup in Payment services form; otherwise, false.
    /// </returns>
    static server boolean isPayFabricProcessorOnly()
    {
        CreditCardAccountSetup          creditCardAccountSetup;
        CreditCardProcessors            creditCardProcessors;
        boolean                         ret;

        select firstOnly1 creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors
               && creditCardAccountSetup.ConnectorName != SKS_CC_PayFabricWalletHandler::getPayFabricConnectorName();

        if (!creditCardAccountSetup)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreditCardFromPayFabricResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a PayFabric credit card in the <c>CreditCardCust</c> table.
    /// </summary>
    /// <param name="_xmlString">
    /// A string containing the XML for the properties of the updated record.
    /// </param>
    /// <param name="_creditCardCustRecId">
    /// The Record Id for the <c>CreditCardCust</c> record to be updated.
    /// </param>
    /// <returns>
    /// The updated record.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Indicates the record was not found.
    /// </exception>
    public static CreditCardCust updateCreditCardFromPayFabricResponse(str _xmlString, RecId _creditCardCustRecId, str _cardLast4Digits)
    {
        CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_xmlString);
        CreditCardCust creditCardCust;
        CreditCardPaymentProperty property;
        str isSKSDefaultCardStr;
        NoYes isSKSDefaultCard;

        str ns = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();

        if (!_xmlString || !_creditCardCustRecId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        select firstOnly1 forUpdate creditCardCust
            where creditCardCust.RecId == _creditCardCustRecId;

        if (!creditCardCust)
        {
            throw error(strFmt("@SKS6087", _cardLast4Digits, _creditCardCustRecId));
        }

        ttsbegin;
        creditCardCust.CardToken = properties.toXmlString();
        property = properties.find(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(), Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_Name());
        creditCardCust.Name = property ? property.parmStringValue() : '';
        creditCardCust.ExpiryDate = strFmt('%1/%2',
            any2int(properties.find(ns, Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_ExpirationMonth()).parmDecimalValue()),
            any2int(properties.find(ns, Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_ExpirationYear()).parmDecimalValue()));

        property = properties.find(ns, CreditCardPaymentCardPropertyName_Note);
        creditCardCust.Notes = property ? property.parmStringValue() : '';

        property = properties.find(ns, IsDefaultCard);
        isSKSDefaultCardStr = property ? property.parmStringValue() : '';
        if (isSKSDefaultCardStr == YesDfltCard)
        {
            isSKSDefaultCard = NoYes::Yes;
            creditCardCust.SKS_CC_CardPriority = SKS_CC_CardPriority::One;
        }
        else
        {
            if (creditCardCust.SKS_CC_CardPriority == SKS_CC_CardPriority::One)
            {
                creditCardCust.SKS_CC_CardPriority = SKS_CC_CardPriority::None;
            }
        }
        creditCardCust.SKS_CC_DefaultCard = isSKSDefaultCard;

        creditCardCust.update();
        ttscommit;

        if (isSKSDefaultCard && creditCardCust)
        {
            SKS_CC_PayFabricSetCardPriority::removeDefaultFromAnyOtherCard(creditCardCust);
        }

        return creditCardCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteForOpenAuth</Name>
				<Source><![CDATA[
    public static boolean validateDeleteForOpenAuth(RecId _creditCardCustRecId, boolean _isSilent = false)
    {
        CreditCardAuthTrans     creditCardAuthTransCheck;
        SalesTable              salesTableCheck;
        boolean                 ret = true;

        if (_creditCardCustRecId)
        {
            select firstonly1 SalesId from salesTableCheck
                where salesTableCheck.CreditCardCustRefId == _creditCardCustRecId
            exists join creditCardAuthTransCheck
                where creditCardAuthTransCheck.SalesId == salesTableCheck.SalesId
                   && creditCardAuthTransCheck.ApprovalType == CreditCardOperation::Authorize
                   && !creditCardAuthTransCheck.ApprovalExpired
                   && !creditCardAuthTransCheck.ApprovalVoid
                   && creditCardAuthTransCheck.ProcessorStatus == CreditCardProcessorStatus::Approved;

            if (salesTableCheck.SalesId)
            {
                if (_isSilent)
                {
                    ret = false;
                }
                else
                {
                    ret = checkFailed(strFmt("@SKS6086", salesTableCheck.SalesId));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricConnectorName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the PayFabric processor connector name
    /// </summary>
    /// <returns>
    /// PayFabric connector name.
    /// </returns>
    static server CreditCardConnectorName getPayFabricConnectorName()
    {
        const str PFConnectorName = 'SK Global PayFabric Connector';
        return PFConnectorName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClrExceptionMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exception message of the last exception thrown.
    /// </summary>
    /// <returns>
    /// The text of the last thrown exception.
    /// </returns>
    str getClrExceptionMessage()
    {
        str                 exceptionMessage;
        System.Exception    exception;
        System.Exception    innerException;
        InteropPermission   perm = new InteropPermission(InteropKind::ClrInterop);

        perm.assert();

        //BP Deviation Documented
        exception = CLRInterop::getLastException();
        if (exception)
        {
            exceptionMessage = exception.get_Message();

            innerException = exception.get_InnerException();
            if (innerException)
            {
                exceptionMessage = innerException.get_Message();
            }
        }

        CodeAccessPermission::revertAssert();

        return exceptionMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGatewayProfileName</Name>
				<Source><![CDATA[
    public static server boolean validateGatewayProfileName(CreditCardConnectorName _curConnectorName)
    {        
        CreditCardProcessors                                                activeCreditCardProcessors;
        CreditCardAccountSetup                                              creditCardAccountSetup;
        CreditCardProcessors                                                creditCardProcessors;
        Microsoft.Dynamics.Retail.PaymentSDK.Portable.IPaymentProcessor     processor;
        Microsoft.Dynamics.Retail.PaymentSDK.Portable.PaymentProperty[]     processorProperties;
        Microsoft.Dynamics.Retail.PaymentSDK.Portable.PaymentProperty[]     paymentCardProperties;
        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Request               request = new Microsoft.Dynamics.Retail.PaymentSDK.Portable.Request();
        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Response              response;
        CreditCardPaymentProperties                                         interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                                         requestProperties;
        CreditCardPaymentErrors                                             errors;
        Microsoft.Dynamics.Retail.PaymentSDK.Portable.PaymentProperty       property;
        str                                                                 gatewayProfileNameToCheck;

        const str RetrievePaymentGatewayProfiles = 'RetrievePaymentGatewayProfiles';
        const str GatewayProfileName = 'GatewayProfileName';

        if (!_curConnectorName)
        {
            throw error(strFmt("@SKS6189", error::wrongUseOfFunction(funcName())));
        }

        select creditCardAccountSetup
            exists join creditCardProcessors
            where creditCardProcessors.Name  == _curConnectorName &&
                  creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);        

        property = CreditCardConnectorSetup::findPropertyByName(processorProperties,
                                                                Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_MerchantAccount(),
                                                                GatewayProfileName);

        if (property)
        {
            gatewayProfileNameToCheck = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
        }

        if (!gatewayProfileNameToCheck)
        {
            throw error("@SKS6187");
        }

        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        SKS_CC_PayFabricWalletHandler pfWalletHandlerProc = new SKS_CC_PayFabricWalletHandler();

        processor = pfWalletHandlerProc.getProcessor(creditCardAccountSetup.ConnectorName);        

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricOperation, CreditCardPropertySecurityLevel::None,
                                                                    'PayFabric Operation', 'PayFabric Operation',
                                                                    RetrievePaymentGatewayProfiles));

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    GatewayProfileName, CreditCardPropertySecurityLevel::PII,
                                                                    'Gateway Profile Name', 'Gateway Profile Name',
                                                                    gatewayProfileNameToCheck));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());

        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS6188", gatewayProfileNameToCheck, '\n', strReplace(errors.toString(), '\n', '; ')));            
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetInProcessStatusForLink</Name>
				<Source><![CDATA[
    public void resetInProcessStatusForLink(SKS_CC_PayLinkQueue _payLinkQueue,
        str _curErrorMsg = '',
        boolean _calledFromCancel = false)
    {
        _payLinkQueue.reread();

        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::No;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::minValue();
            _payLinkQueue.InProcessResetStatusLastMsg = '';
            if (_curErrorMsg)
            {
                _payLinkQueue.ErrorWarning = _curErrorMsg;
                _payLinkQueue.PayLinkErrorCount += 1;
                if (_payLinkQueue.Status == SKS_CC_PayLinkProcessStatus::Error &&
                    _calledFromCancel)
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Canceled;
                    info(strFmt("@SKS:SKGCCPayLinkQueueRecordUpdatedToCanceledStatus",
                        enum2Str(SKS_CC_PayLinkProcessStatus::Error),
                        enum2Str(SKS_CC_PayLinkProcessStatus::Canceled)));
                }
                else
                {                    
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Error;
                }                
            }            
            _payLinkQueue.update();            
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            error("@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate");
        }
        catch (Exception::Error)
        {
            ttsabort;
            error(strFmt("@SKS:SKGCCErrorMsgWhileInProcessStatusUpdate", _payLinkQueue.RecId));            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshWalletLink</Name>
				<Source><![CDATA[
    public SKS_CC_PayLinkProcessStatus refreshWalletLink(SKS_CC_PayLinkQueue _payLinkQueue, boolean _isSingleRecordRefresh = false)
    {
        SKS_CC_PayLinkProcessStatus retStatus;
        const str constRefreshWalletLink = 'RefreshWalletLink';
        const str constPayLinkId = 'PayLinkId';
        
        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;
        str                                                     pfSendWalletLinkResponseXmlString, curErrorMsg;

        SKS_PP_Setup sksParmsLoc = SKS_PP_Setup::find();
        URL PLWebSvcLoc = sksParmsLoc.CCPLWebServLoc;
        if (!PLWebSvcLoc)
        {
            throw error("@SKS:SKGCCPLWebSvcLocMustBeSpecified");
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
        where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
              creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);      

        _payLinkQueue.reread();
        if (_payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Pending &&
            _payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Error)
        {
            return SKS_CC_PayLinkProcessStatus::All;
        }

        if (_payLinkQueue.InProcess)
        {
            // If record is flagged as in-process, check to see if it has been set for more than 30 minutes.
            // If so, then allow the record to be processed again making sure to reset in-process date/time.
            // This is used to automatically reset the in-process status.
            utcdatetime inProcessLeaseExpireDate = DateTimeUtil::addMinutes(DateTimeUtil::utcNow(), -30);
            if (_payLinkQueue.InProcessDateTime && _payLinkQueue.InProcessDateTime < inProcessLeaseExpireDate)
            {
                _payLinkQueue.InProcess = NoYes::Yes;
            }
            else
            {
                if (_isSingleRecordRefresh)
                {
                    warning(strFmt("@SKS:SKGCCQueueRecordMarkedAsInProcess",
                        datetime2Str(DateTimeUtil::applyTimeZoneOffset(_payLinkQueue.InProcessDateTime, DateTimeUtil::getUserPreferredTimeZone()))));
                }

                return SKS_CC_PayLinkProcessStatus::All;
            }
        }

        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::Yes;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::utcNow();
            _payLinkQueue.update();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            error("@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate");
            return SKS_CC_PayLinkProcessStatus::All;
        }
        catch (Exception::Error)
        {
            ttsabort;
            error(strFmt("@SKS:SKGCCErrorMsgWhileInProcessStatusUpdate", _payLinkQueue.RecId));
            return SKS_CC_PayLinkProcessStatus::All;
        }        

        str nsPaymCard = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, PayFabricOperation, constRefreshWalletLink));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPLWebServiceLoc, PLWebSvcLoc));        
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPayLinkId, _payLinkQueue.PayLinkId));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());        
        
        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileRefreshingWalletLink", _payLinkQueue.AccountNum, _payLinkQueue.PayLinkId,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg);

            return SKS_CC_PayLinkProcessStatus::Error;
        }

        if (paymentCardProperties != null)
        {
            pfSendWalletLinkResponseXmlString = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
        }

        if (!pfSendWalletLinkResponseXmlString)
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileRefreshingWalletLink", _payLinkQueue.AccountNum, _payLinkQueue.PayLinkId,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg);

            return SKS_CC_PayLinkProcessStatus::Error;
        }

        const str constPFWalletResponseStatus = 'PFWalletResponseStatus';
        const str constPFResponseWalletId = 'PFResponseWalletId';
        const str constPFCompletedOn = 'PFCompletedOn';
        const str constPFTenderType = 'PFTenderType';
        
        CreditCardPaymentProperties responseProperties = CreditCardPaymentProperties::fromXmlString(pfSendWalletLinkResponseXmlString);
        CreditCardPaymentProperty responseProperty;        

        responseProperty = responseProperties.find(nsPaymCard, constPayLinkId);
        str PayLinkID = responseProperty ? responseProperty.parmStringValue() : '';
        
        boolean isExpiredQueueRecord;
        if (!PayLinkID)
        {           
            _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Error;
            _payLinkQueue.ErrorWarning = "@SKS:SKGCCErrorDueToMissingPayLinkId";
        }
        else
        {
            responseProperty = responseProperties.find(nsPaymCard, constPFWalletResponseStatus);
            str walletLinkStatus = responseProperty ? responseProperty.parmStringValue() : '';
       
            if (walletLinkStatus == '0') 
            {
                // Incomplete status. No change needed. Determine if link should be expired; otherwise, skip any updates.
                if (!sksParmsLoc.CCPLWalletLinkLastNoOfDays)
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Pending;
                }
                else
                {
                    utcdatetime linkExpiredDate = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -sksParmsLoc.CCPLWalletLinkLastNoOfDays);
                    if (_payLinkQueue.SentDateTime && _payLinkQueue.SentDateTime < linkExpiredDate)
                    {
                        isExpiredQueueRecord = true;
                    }

                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Pending;
                }
            }
            else if (walletLinkStatus == '1')
            {
                // Complete status. Validate tender type. If valid, update Walletlink to completed status and create Wallet as needed.
                responseProperty = responseProperties.find(nsPaymCard, constPFTenderType);
                str tenderType = responseProperty ? responseProperty.parmStringValue() : '';
                if (tenderType != '1')
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Error;
                    _payLinkQueue.ErrorWarning = "@SKS:SKGCCErrorDueToUnsupportedTenderType";
                }
                else
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Completed;

                    responseProperty = responseProperties.find(nsPaymCard, constPFResponseWalletId);
                    _payLinkQueue.CreatedWalletId = responseProperty ? responseProperty.parmStringValue() : '';

                    responseProperty = responseProperties.find(nsPaymCard, constPFCompletedOn);
                    _payLinkQueue.PFCompletedDateTime = responseProperty ? responseProperty.parmDateTimeValue() : DateTimeUtil::minValue();
                    if (_payLinkQueue.PFCompletedDateTime)
                    {
                        // Remove PST/PDT timezone from PayFabric completed date/time. That's the timezone for PayFabric.
                        utcdatetime tmpDateTime = DateTimeUtil::removeTimeZoneOffset(_payLinkQueue.PFCompletedDateTime, Timezone::GMTMINUS0800PACIFICTIME);
                        _payLinkQueue.PFCompletedDateTime = tmpDateTime;                        
                    }
                    _payLinkQueue.CompletedDateTime = DateTimeUtil::utcNow();
                    _payLinkQueue.ErrorWarning = '';
                }                
            }
            else if (walletLinkStatus == '2')
            {
                // Cancelled status. Update link.
                _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Canceled;
            }
            else
            {
                // Unknown status. Update link to error status.
                _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Error;
                _payLinkQueue.ErrorWarning = "@SKS:SKGCCErrorDueToUnknownStatus";
            }
        }       
        
        LogText logText;
        Counter origInfologNum = infologLine();

        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::No;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::minValue();        
            _payLinkQueue.update();            

            if (_payLinkQueue.Status == SKS_CC_PayLinkProcessStatus::Completed &&
                _payLinkQueue.CreatedWalletId)
            {
                CreditCardCust creditCardCustLoc = creditCardCust::findByUniqueCardId(_payLinkQueue.CreatedWalletId);
                if (!creditCardCustLoc)
                {
                    SKS_CC_eCommIntegrationHandler::SKS_CC_eCommInteg_CardSynch(_payLinkQueue.DataAreaId,
                    _payLinkQueue.AccountNum,
                    _payLinkQueue.CreatedWalletId,
                    oneTimeCustRefTableId,
                    oneTimeCustRefRecId);
                }
            }            
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            ttsabort;
            curErrorMsg = "@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate";
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;            
        }
        catch (Exception::CLRError)
        {
            ttsabort;            
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileUpdatingRecordFromWalletLink", _payLinkQueue.RecId);
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;
        }
        catch (Exception::Error)
        {
            ttsabort;            
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileUpdatingRecordFromWalletLink", _payLinkQueue.RecId);
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;            
        }

        if (isExpiredQueueRecord)
        {
            this.cancelWalletLink(_payLinkQueue, !_isSingleRecordRefresh, true);
            _payLinkQueue.reread();
        }

        retStatus = _payLinkQueue.Status;

        return retStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePayLinkSourceRecord</Name>
				<Source><![CDATA[
    public static void updatePayLinkSourceRecord(SKS_CC_PayLinkQueue _payLinkQueue)
    {
        if (!_payLinkQueue.AccountNum && _payLinkQueue.TransType == SKS_CC_PayLinkTransactionType::WalletLink)
        {
            return;
        }

        if (!_payLinkQueue.SalesOrderId && _payLinkQueue.TransType == SKS_CC_PayLinkTransactionType::PayLink)
        {
            return;
        }

        SKS_CC_PayLinkQueue payLinkQueueRecCnt;

        if (_payLinkQueue.TransType == SKS_CC_PayLinkTransactionType::WalletLink)
        {
            select count(RecId) from payLinkQueueRecCnt
                where payLinkQueueRecCnt.AccountNum == _payLinkQueue.AccountNum                
                && payLinkQueueRecCnt.TransType == SKS_CC_PayLinkTransactionType::WalletLink;

            CustTable custTableUpd = CustTable::find(_payLinkQueue.AccountNum, true);
            if (custTableUpd)
            {
                custTableUpd.SKS_CC_WalletLinkStatus = _payLinkQueue.Status;

                if (_payLinkQueue.Status == SKS_CC_PayLinkProcessStatus::Error)
                {
                    custTableUpd.SKS_CC_WalletLinkErrorMsg = _payLinkQueue.ErrorWarning;
                }
                else
                {
                    custTableUpd.SKS_CC_WalletLinkErrorMsg = '';
                }

                custTableUpd.SKS_CC_WalletLinkCount = any2Int(payLinkQueueRecCnt.RecId);

                ttsbegin;
                custTableUpd.doUpdate();
                ttscommit;
            }
        }
        else if (_payLinkQueue.TransType == SKS_CC_PayLinkTransactionType::PayLink)
        {
            select count(RecId) from payLinkQueueRecCnt
                where payLinkQueueRecCnt.RefTableId == _payLinkQueue.RefTableId
                && payLinkQueueRecCnt.RefRecId == _payLinkQueue.RefRecId
                && payLinkQueueRecCnt.TransType == SKS_CC_PayLinkTransactionType::PayLink
                && (payLinkQueueRecCnt.Entity == SKS_CC_PayLinkEntityType::SalesOrderPrePayment ||
                    payLinkQueueRecCnt.Entity == SKS_CC_PayLinkEntityType::SalesOrderPreAuth);

            SalesTable salesTableUpd = SalesTable::find(_payLinkQueue.SalesOrderId, true);            
            if (salesTableUpd)
            {
                salesTableUpd.SKS_CC_PayLinkStatus = _payLinkQueue.Status;

                if (_payLinkQueue.Status == SKS_CC_PayLinkProcessStatus::Error)
                {
                    salesTableUpd.SKS_CC_PayLinkErrorMsg = _payLinkQueue.ErrorWarning;
                }
                else
                {
                    salesTableUpd.SKS_CC_PayLinkErrorMsg = '';
                }

                salesTableUpd.SKS_CC_PayLinkCount = any2Int(payLinkQueueRecCnt.RecId);

                ttsbegin;
                salesTableUpd.doUpdate();
                ttscommit;
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshPayLink</Name>
				<Source><![CDATA[
    public SKS_CC_PayLinkProcessStatus refreshPayLink(SKS_CC_PayLinkQueue _payLinkQueue, boolean _isSingleRecordRefresh = false)
    {
        SKS_CC_PayLinkProcessStatus retStatus;
        const str constRefreshPayLink = 'RefreshPayLink';
        const str constPayLinkId = 'PayLinkId';
        
        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;        
        str                                                     pfSendPayLinkResponseXmlString, curErrorMsg;

        SKS_PP_Setup sksParmsLoc = SKS_PP_Setup::find();
        URL PLWebSvcLoc = sksParmsLoc.CCPLWebServLoc;
        if (!PLWebSvcLoc)
        {
            throw error("@SKS:SKGCCPLWebSvcLocMustBeSpecified");
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
        where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
              creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        _payLinkQueue.reread();
        if (_payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Pending &&
            _payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Error)
        {
            return SKS_CC_PayLinkProcessStatus::All;
        }

        if (_payLinkQueue.InProcess)
        {
            // If record is flagged as in-process, check to see if it has been set for more than 30 minutes.
            // If so, then allow the record to be processed again making sure to reset in-process date/time.
            // This is used to automatically reset the in-process status.
            utcdatetime inProcessLeaseExpireDate = DateTimeUtil::addMinutes(DateTimeUtil::utcNow(), -30);
            if (_payLinkQueue.InProcessDateTime && _payLinkQueue.InProcessDateTime < inProcessLeaseExpireDate)
            {
                _payLinkQueue.InProcess = NoYes::Yes;
            }
            else
            {
                if (_isSingleRecordRefresh)
                {
                    warning(strFmt("@SKS:SKGCCQueueRecordMarkedAsInProcess",
                        datetime2Str(DateTimeUtil::applyTimeZoneOffset(_payLinkQueue.InProcessDateTime, DateTimeUtil::getUserPreferredTimeZone()))));
                }

                return SKS_CC_PayLinkProcessStatus::All;
            }
        }

        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::Yes;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::utcNow();
            _payLinkQueue.update();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            error("@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate");
            return SKS_CC_PayLinkProcessStatus::All;
        }
        catch (Exception::Error)
        {
            ttsabort;
            error(strFmt("@SKS:SKGCCErrorMsgWhileInProcessStatusUpdate", _payLinkQueue.RecId));
            return SKS_CC_PayLinkProcessStatus::All;
        }

        str nsPaymCard = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, PayFabricOperation, constRefreshPayLink));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPLWebServiceLoc, PLWebSvcLoc));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPayLinkId, _payLinkQueue.PayLinkId));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());
        
        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileRefreshingPayLink", enum2Str(_payLinkQueue.Entity), _payLinkQueue.EntityReference,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg);

            return SKS_CC_PayLinkProcessStatus::Error;
        }

        if (paymentCardProperties != null)
        {
            pfSendPayLinkResponseXmlString = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
        }

        if (!pfSendPayLinkResponseXmlString)
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileRefreshingPayLink", enum2Str(_payLinkQueue.Entity), _payLinkQueue.EntityReference,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg);

            return SKS_CC_PayLinkProcessStatus::Error;
        }

        const str constPFResponseStatus = 'PFResponseStatus';
        const str constPFResponseTransKey = 'PFResponseTransKey';
        const str constPFPaidOn = 'PFPaidOn';        
        
        CreditCardPaymentProperties responseProperties = CreditCardPaymentProperties::fromXmlString(pfSendPayLinkResponseXmlString);
        CreditCardPaymentProperty responseProperty;

        responseProperty = responseProperties.find(nsPaymCard, constPayLinkId);
        str PayLinkID = responseProperty ? responseProperty.parmStringValue() : '';
        
        boolean isExpiredQueueRecord;
        if (!PayLinkID)
        {
            _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Error;
            _payLinkQueue.ErrorWarning = "@SKS:SKGCCErrorDueToMissingPayLinkId";
        }
        else
        {
            responseProperty = responseProperties.find(nsPaymCard, constPFResponseStatus);
            str payLinkStatus = responseProperty ? responseProperty.parmStringValue() : '';
       
            if (payLinkStatus == '0' || payLinkStatus == '1')
            {
                // 0 = draft, 1 = waiting for payment. Incomplete status.
                // No change needed. Determine if link should be expired; otherwise, skip any updates.
                if (!sksParmsLoc.CCPLPayLinkLastNoOfDays)
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Pending;
                }
                else
                {
                    utcdatetime linkExpiredDate = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -sksParmsLoc.CCPLPayLinkLastNoOfDays);
                    if (_payLinkQueue.SentDateTime && _payLinkQueue.SentDateTime < linkExpiredDate)
                    {
                        isExpiredQueueRecord = true;
                    }

                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Pending;
                }
            }
            else if (payLinkStatus == '2')
            {
                // Cancelled status. Update link.
                _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Canceled;
            }
            else if (payLinkStatus == '3')
            {
                _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Completed;

                responseProperty = responseProperties.find(nsPaymCard, constPFResponseTransKey);
                _payLinkQueue.CreatedPFTransKey = responseProperty ? responseProperty.parmStringValue() : '';

                responseProperty = responseProperties.find(nsPaymCard, constPFPaidOn);
                _payLinkQueue.PFCompletedDateTime = responseProperty ? responseProperty.parmDateTimeValue() : DateTimeUtil::minValue();
                if (_payLinkQueue.PFCompletedDateTime)
                {
                    // Remove PST/PDT timezone from PayFabric completed date/time. That's the timezone for PayFabric.
                    utcdatetime tmpDateTime = DateTimeUtil::removeTimeZoneOffset(_payLinkQueue.PFCompletedDateTime, Timezone::GMTMINUS0800PACIFICTIME);
                    _payLinkQueue.PFCompletedDateTime = tmpDateTime;
                }
                _payLinkQueue.CompletedDateTime = DateTimeUtil::utcNow();
                _payLinkQueue.ErrorWarning = '';
            }           
            else
            {
                // Unknown status. Update link to error status.
                _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Error;
                _payLinkQueue.ErrorWarning = "@SKS:SKGCCErrorDueToUnknownStatus";
            }
        }
       
        LogText logText;
        Counter origInfologNum = infologLine();

        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::No;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::minValue();
            _payLinkQueue.update();
            ttscommit;         
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            ttsabort;            
            curErrorMsg = "@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate";
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;
        }
        catch (Exception::CLRError)
        {
            ttsabort;            
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileUpdatingRecordFromPayLink", _payLinkQueue.RecId);
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;
        }
        catch (Exception::Error)
        {
            ttsabort;            
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileUpdatingRecordFromPayLink", _payLinkQueue.RecId);
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;
        }

        try
        { 
            if (_payLinkQueue.Status == SKS_CC_PayLinkProcessStatus::Completed &&
                _payLinkQueue.CreatedPFTransKey)
            {
                ttsbegin;

                const str constAuthTxnType = 'Auth';
                const str constSaleTxnType = 'Sale';
                CreditCardOperation ccOperation;

                switch (_payLinkQueue.Entity)
                {
                    case SKS_CC_PayLinkEntityType::SalesOrderPreAuth:
                    case SKS_CC_PayLinkEntityType::ProjServiceOrderPreAuth:
                        ccOperation = CreditCardOperation::Authorize;
                        break;
                    case SKS_CC_PayLinkEntityType::SalesOrderPrePayment:
                    case SKS_CC_PayLinkEntityType::PaymentJournalCapture:
                        ccOperation = CreditCardOperation::AuthorizeAndCapture;
                        break;
                    default:
                        break;
                }

                if (_payLinkQueue.SalesOrderId &&
                    _payLinkQueue.RefTableId == tableNum(SalesTable) &&
                    (_payLinkQueue.Entity == SKS_CC_PayLinkEntityType::SalesOrderPreAuth ||
                        _payLinkQueue.Entity == SKS_CC_PayLinkEntityType::SalesOrderPrePayment))
                {
                    SKS_CC_eCommIntegrationHandler::SKS_CC_PayLink_SalesOrderTxnSynch(_payLinkQueue.DataAreaId,
                        _payLinkQueue.AccountNum,
                        _payLinkQueue.SalesOrderId,
                        _payLinkQueue.CreatedPFTransKey,
                        ccOperation == CreditCardOperation::Authorize ? constAuthTxnType : constSaleTxnType);
                }
                else if (_payLinkQueue.JournalNum &&
                            _payLinkQueue.RefTableId == tableNum(LedgerJournalTrans) &&
                            _payLinkQueue.Entity == SKS_CC_PayLinkEntityType::PaymentJournalCapture)
                {
                    SKS_CC_eCommIntegrationHandler::SKS_CC_PayLink_JournalLineTxnSynch(_payLinkQueue.DataAreaId,
                        _payLinkQueue.AccountNum,
                        _payLinkQueue.RefRecId,
                        _payLinkQueue.CreatedPFTransKey,
                        _isSingleRecordRefresh);
                }

                ttscommit;
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            ttsabort;
            curErrorMsg = "@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate";
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;
        }
        catch (Exception::CLRError)
        {
            ttsabort;
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileUpdatingRecordFromPayLink", _payLinkQueue.RecId);
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;
        }
        catch (Exception::Error)
        {
            ttsabort;
            // Error encountered after refreshing Paylink after processing paylink record with recid %1 
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileUpdatingRecordFromPayLink", _payLinkQueue.RecId);
            error(curErrorMsg);
            logText = Info::infoCon2Str(infolog.copy(origInfologNum + 1, infologLine()));

            this.resetInProcessStatusForLink(_payLinkQueue, logText);

            return SKS_CC_PayLinkProcessStatus::Error;
        }



        if (isExpiredQueueRecord)
        {
            this.cancelPayLink(_payLinkQueue, !_isSingleRecordRefresh, true);
            _payLinkQueue.reread();
        }

        retStatus = _payLinkQueue.Status;

        return retStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelWalletLink</Name>
				<Source><![CDATA[
    public boolean cancelWalletLink(
        SKS_CC_PayLinkQueue _payLinkQueue,
        boolean _isSilent = true,
        boolean _calledFromExpired = false)
    {
        boolean retStatus;
        const str constCancelWalletLink = 'CancelWalletLink';
        const str constPayLinkId = 'PayLinkId';
        
        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;        
        str                                                     pfSendWalletLinkResponseXmlString, curErrorMsg;

        SKS_PP_Setup sksParmsLoc = SKS_PP_Setup::find();
        URL PLWebSvcLoc = sksParmsLoc.CCPLWebServLoc;
        if (!PLWebSvcLoc)
        {
            throw error("@SKS:SKGCCPLWebSvcLocMustBeSpecified");
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
        where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
              creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        _payLinkQueue.reread();
        if (_payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Pending &&
            _payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Error)
        {
            return false;
        }

        if (_payLinkQueue.InProcess)
        {
            // If record is flagged as in-process, check to see if it has been set for more than 30 minutes.
            // If so, then allow the record to be processed again making sure to reset in-process date/time.
            // This is used to automatically reset the in-process status.
            utcdatetime inProcessLeaseExpireDate = DateTimeUtil::addMinutes(DateTimeUtil::utcNow(), -30);
            if (_payLinkQueue.InProcessDateTime && _payLinkQueue.InProcessDateTime < inProcessLeaseExpireDate)
            {
                _payLinkQueue.InProcess = NoYes::Yes;
            }
            else
            {
                if (!_isSilent)
                {
                    warning(strFmt("@SKS:SKGCCQueueRecordMarkedAsInProcess", 
                        datetime2Str(DateTimeUtil::applyTimeZoneOffset(_payLinkQueue.InProcessDateTime, DateTimeUtil::getUserPreferredTimeZone()))));
                }

                return false;
            }
        }

        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::Yes;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::utcNow();
            _payLinkQueue.update();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            error("@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate");
            return false;
        }
        catch (Exception::Error)
        {
            ttsabort;
            error(strFmt("@SKS:SKGCCErrorMsgWhileInProcessStatusUpdate", _payLinkQueue.RecId));
            return false;
        }

        str nsPaymCard = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, PayFabricOperation, constCancelWalletLink));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPLWebServiceLoc, PLWebSvcLoc));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPayLinkId, _payLinkQueue.PayLinkId));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());
        
        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileCancelingWalletLink", _payLinkQueue.AccountNum, _payLinkQueue.PayLinkId,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg, true);

            return false;
        }

        if (paymentCardProperties != null)
        {
            pfSendWalletLinkResponseXmlString = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
        }

        if (!pfSendWalletLinkResponseXmlString)
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileCancelingWalletLink", _payLinkQueue.AccountNum, _payLinkQueue.PayLinkId,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg, true);

            return false;
        }

        const str constPFWalletResponseStatus = 'PFWalletResponseStatus';        
        
        CreditCardPaymentProperties responseProperties = CreditCardPaymentProperties::fromXmlString(pfSendWalletLinkResponseXmlString);
        CreditCardPaymentProperty responseProperty;

        responseProperty = responseProperties.find(nsPaymCard, constPayLinkId);
        str PayLinkID = responseProperty ? responseProperty.parmStringValue() : '';
        
        if (!PayLinkID)
        {
            _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Error;
            _payLinkQueue.ErrorWarning = "@SKS:SKGCCErrorDueToMissingPayLinkId";
        }
        else
        {
            responseProperty = responseProperties.find(nsPaymCard, constPFWalletResponseStatus);
            str walletLinkStatus = responseProperty ? responseProperty.parmStringValue() : '';       
            
            if (walletLinkStatus == '2')
            {
                // Cancelled status. Update link.
                if (_calledFromExpired)
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Expired;
                }
                else
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Canceled;
                }

                retStatus = true;
            }
            else
            {
                this.resetInProcessStatusForLink(_payLinkQueue, '', true);
                return false;
            }            
        }
       
        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::No;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::minValue();
            _payLinkQueue.update();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            curErrorMsg = "@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate";
            error(curErrorMsg);

            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg, true);

            return false;
        }
        catch (Exception::Error)
        {
            ttsabort;
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileCancelingRecordFromWalletLink", _payLinkQueue.RecId);
            error(curErrorMsg);

            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg, true);

            return false;
        }        

        return retStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelPayLink</Name>
				<Source><![CDATA[
    public boolean cancelPayLink(
        SKS_CC_PayLinkQueue _payLinkQueue,
        boolean _isSilent = true,
        boolean _calledFromExpired = false)
    {
        boolean retStatus;
        const str constCancelPayLink = 'CancelPayLink';
        const str constPayLinkId = 'PayLinkId';
        
        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;        
        str                                                     pfSendWalletLinkResponseXmlString, curErrorMsg;

        SKS_PP_Setup sksParmsLoc = SKS_PP_Setup::find();
        URL PLWebSvcLoc = sksParmsLoc.CCPLWebServLoc;
        if (!PLWebSvcLoc)
        {
            throw error("@SKS:SKGCCPLWebSvcLocMustBeSpecified");
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
        where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
              creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        _payLinkQueue.reread();
        if (_payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Pending &&
            _payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Error)
        {
            return false;
        }

        if (_payLinkQueue.InProcess)
        {
            // If record is flagged as in-process, check to see if it has been set for more than 30 minutes.
            // If so, then allow the record to be processed again making sure to reset in-process date/time.
            // This is used to automatically reset the in-process status.
            utcdatetime inProcessLeaseExpireDate = DateTimeUtil::addMinutes(DateTimeUtil::utcNow(), -30);
            if (_payLinkQueue.InProcessDateTime && _payLinkQueue.InProcessDateTime < inProcessLeaseExpireDate)
            {
                _payLinkQueue.InProcess = NoYes::Yes;
            }
            else
            {
                if (!_isSilent)
                {
                    warning(strFmt("@SKS:SKGCCQueueRecordMarkedAsInProcess",
                        datetime2Str(DateTimeUtil::applyTimeZoneOffset(_payLinkQueue.InProcessDateTime, DateTimeUtil::getUserPreferredTimeZone()))));
                }

                return false;
            }
        }

        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::Yes;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::utcNow();
            _payLinkQueue.update();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            error("@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate");
            return false;
        }
        catch (Exception::Error)
        {
            ttsabort;
            error(strFmt("@SKS:SKGCCErrorMsgWhileInProcessStatusUpdate", _payLinkQueue.RecId));
            return false;
        }

        str nsPaymCard = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, PayFabricOperation, constCancelPayLink));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPLWebServiceLoc, PLWebSvcLoc));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPayLinkId, _payLinkQueue.PayLinkId));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());
        
        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileCancelingWalletLink", _payLinkQueue.AccountNum, _payLinkQueue.PayLinkId,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg, true);

            return false;
        }

        if (paymentCardProperties != null)
        {
            pfSendWalletLinkResponseXmlString = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
        }

        if (!pfSendWalletLinkResponseXmlString)
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileCancelingWalletLink", _payLinkQueue.AccountNum, _payLinkQueue.PayLinkId,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg, true);

            return false;
        }

        const str constPFPayLinkResponseStatus = 'PFPayLinkResponseStatus';        
        
        CreditCardPaymentProperties responseProperties = CreditCardPaymentProperties::fromXmlString(pfSendWalletLinkResponseXmlString);
        CreditCardPaymentProperty responseProperty;

        responseProperty = responseProperties.find(nsPaymCard, constPayLinkId);
        str PayLinkID = responseProperty ? responseProperty.parmStringValue() : '';
        
        if (!PayLinkID)
        {
            _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Error;
            _payLinkQueue.ErrorWarning = "@SKS:SKGCCErrorDueToMissingPayLinkId";
        }
        else
        {
            responseProperty = responseProperties.find(nsPaymCard, constPFPayLinkResponseStatus);
            str payLinkStatus = responseProperty ? responseProperty.parmStringValue() : '';
            
            if (payLinkStatus == '2')
            {
                // Cancelled status. Update link.
                if (_calledFromExpired)
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Expired;
                }
                else
                {
                    _payLinkQueue.Status = SKS_CC_PayLinkProcessStatus::Canceled;
                }

                retStatus = true;
            }
            else
            {
                this.resetInProcessStatusForLink(_payLinkQueue, '', true);
                return false;
            }
        }
       
        try
        {
            ttsbegin;
            _payLinkQueue.selectForUpdate(true);
            _payLinkQueue.InProcess = NoYes::No;
            _payLinkQueue.InProcessDateTime = DateTimeUtil::minValue();
            _payLinkQueue.update();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            curErrorMsg = "@SKS:SKGCCDuplicateKeyErrorOccurredDuringUpdate";
            error(curErrorMsg);

            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg, true);

            return false;
        }
        catch (Exception::Error)
        {
            ttsabort;
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileCancelingRecordFromWalletLink", _payLinkQueue.RecId);
            error(curErrorMsg);

            this.resetInProcessStatusForLink(_payLinkQueue, curErrorMsg, true);

            return false;
        }

        return retStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ResendLinkNotification</Name>
				<Source><![CDATA[
    public boolean ResendLinkNotification(SKS_CC_PayLinkQueue _payLinkQueue, boolean _isSilent = true)
    {
        boolean retStatus;
        const str constResendNotification = 'ResendNotification';
        const str constPayLinkId = 'PayLinkId';
        const str constNotificationMethod = 'NotificationMethod';
        
        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardProcessorsName                                currentProcessorName;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties, paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;        
        str                                                     pfSendWalletLinkResponseXmlString, curErrorMsg;

        SKS_PP_Setup sksParmsLoc = SKS_PP_Setup::find();
        URL PLWebSvcLoc = sksParmsLoc.CCPLWebServLoc;
        if (!PLWebSvcLoc)
        {
            throw error("@SKS:SKGCCPLWebSvcLocMustBeSpecified");
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
        where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
              creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        currentProcessorName = activeCreditCardProcessors.Name;
        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        _payLinkQueue.reread();
        if (_payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Pending &&
            _payLinkQueue.Status != SKS_CC_PayLinkProcessStatus::Error)
        {
            return false;
        }

        if (_payLinkQueue.InProcess)
        {
            // If record is flagged as in-process, check to see if it has been set for more than 30 minutes.
            // If so, then allow the record to be processed again making sure to reset in-process date/time.
            // This is used to automatically reset the in-process status.
            utcdatetime inProcessLeaseExpireDate = DateTimeUtil::addMinutes(DateTimeUtil::utcNow(), -30);
            if (_payLinkQueue.InProcessDateTime && _payLinkQueue.InProcessDateTime < inProcessLeaseExpireDate)
            {
                this.resetInProcessStatusForLink(_payLinkQueue);
            }
            else
            {
                if (!_isSilent)
                {
                    warning(strFmt("@SKS:SKGCCQueueRecordMarkedAsInProcess",
                        datetime2Str(DateTimeUtil::applyTimeZoneOffset(_payLinkQueue.InProcessDateTime, DateTimeUtil::getUserPreferredTimeZone()))));
                }

                return false;
            }
        }

        str nsPaymCard = Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, PayFabricOperation, constResendNotification));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPLWebServiceLoc, PLWebSvcLoc));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constPayLinkId, _payLinkQueue.PayLinkId));
        requestProperties.add(CreditCardPaymentProperty::newValue(nsPaymCard, constNotificationMethod, _payLinkQueue.Email ? constEmail : constSMS));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());
        
        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileResendLinkNotification", _payLinkQueue.AccountNum, _payLinkQueue.PayLinkId,
                _payLinkQueue.Email ? constEmail : constSMS,
                _payLinkQueue.Email ? _payLinkQueue.Email : _payLinkQueue.SMS,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            return false;
        }

        if (paymentCardProperties != null)
        {
            pfSendWalletLinkResponseXmlString = CreditCardPaymentProperty::clrString2Str(Retail.PaymentSDK.Portable.PaymentProperty::ConvertPropertyArrayToXML(paymentCardProperties));
        }

        if (!pfSendWalletLinkResponseXmlString)
        {
            curErrorMsg = strFmt("@SKS:SKGCCErrorMsgWhileResendLinkNotification", _payLinkQueue.AccountNum, _payLinkQueue.PayLinkId,
                _payLinkQueue.Email ? constEmail : constSMS,
                _payLinkQueue.Email ? _payLinkQueue.Email : _payLinkQueue.SMS,
                strReplace(errors.toString(), '\n', '; '));

            error(curErrorMsg);
            return false;
        }

        const str constPFResendNotificationStatus = 'PFResendNotificationStatus';        
        
        CreditCardPaymentProperties responseProperties = CreditCardPaymentProperties::fromXmlString(pfSendWalletLinkResponseXmlString);
        CreditCardPaymentProperty responseProperty;

        responseProperty = responseProperties.find(nsPaymCard, constPFResendNotificationStatus);
        str resendNotificationStatus = responseProperty ? responseProperty.parmStringValue() : '';
        if (resendNotificationStatus == '1')
        {
            retStatus = true;
        }

        return retStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        try
        {
            Retail.SDKManager.Portable.PaymentProcessorManager::LoadAllAssemblies(CreditCardConnectorSetup::getConnectorsDirectories());
        }
        catch (Exception::CLRError)
        {
            throw error("@SYP4910242" + ' ' + this.getClrExceptionMessage());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static SKS_CC_PayFabricWalletHandler construct()
    {
        return new SKS_CC_PayFabricWalletHandler();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustAccount</Name>
				<Source><![CDATA[
    public CustAccount parmCustAccount(CustAccount _custAccount = custAccount)
    {
        custAccount = _custAccount;
        return custAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOneTimeCustRefTableId</Name>
				<Source><![CDATA[
    public RefTableId parmOneTimeCustRefTableId(RefTableId _oneTimeCustRefTableId = oneTimeCustRefTableId)
    {
        oneTimeCustRefTableId = _oneTimeCustRefTableId;
        return oneTimeCustRefTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOneTimeCustRefRecId</Name>
				<Source><![CDATA[
    public RefRecId parmOneTimeCustRefRecId(RefRecId _oneTimeCustRefRecId = oneTimeCustRefRecId)
    {
        oneTimeCustRefRecId = _oneTimeCustRefRecId;
        return oneTimeCustRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        SKS_CC_PayFabricWalletHandler pfWalletHandler;
        pfWalletHandler = new SKS_CC_PayFabricWalletHandler();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDefaultCardInPayFabricWallet</Name>
				<Source><![CDATA[
    public boolean updateDefaultCardInPayFabricWallet(str _pfCardId, str _cardLast4Digits, NoYes _isDefaultCard)
    {
        const str UpdateDefaultCreditCard = 'UpdateDefaultCreditCard';
        const str PayFabricCardId = 'PayFabricCardId';
        const str PFUpdateDefaultCardResult = 'PFUpdateDefaultCardResult';
        const str NoDfltCard = 'No';
        const str TrueDfltCard = 'True';
        
        CreditCardProcessors                                    activeCreditCardProcessors;        
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties;
        Retail.PaymentSDK.Portable.PaymentProperty[]            paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        Retail.PaymentSDK.Portable.PaymentProperty              property;        
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;        
        str                                                     updateCreditCardResultStr;
        boolean                                                 updateCreditCardResult;
        str                                                     readCreditCardResultStr;
        str                                                     isDefaultCardStr;        

        if (!_pfCardId)
        {
            throw error(strFmt("@SKS6060", error::wrongUseOfFunction(funcName())));
        }

        readCreditCardResultStr = this.readPayFabricWallet(_pfCardId, _cardLast4Digits);
        if (!readCreditCardResultStr)
        {
            error(strFmt("@SKS6076", _cardLast4Digits));
            return false;
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
            creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);        

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricOperation, CreditCardPropertySecurityLevel::None,
                                                                    PayFabric_Operation, PayFabric_Operation, UpdateDefaultCreditCard));        

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricCardId, CreditCardPropertySecurityLevel::PII,
                                                                    PayFabric_Card_Id, PayFabric_Card_Id, _pfCardId));

        if (_isDefaultCard == NoYes::Yes)
        {
            // It is the current default credit card so user must want to remove as default (i.e. Remove as default).
            isDefaultCardStr = NoDfltCard;
        }
        else
        {
            // It is NOT the current default credit card so user must want to set as default (i.e. Make default).
            isDefaultCardStr = YesDfltCard;
        }

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    IsDefaultCard, CreditCardPropertySecurityLevel::None,
                                                                    IsDefaultCard, IsDefaultCard, isDefaultCardStr));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());

        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS6077", _cardLast4Digits, strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            property = CreditCardConnectorSetup::findPropertyByName(paymentCardProperties,
                                                                    Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PFUpdateDefaultCardResult);

            if(property)
            {
                updateCreditCardResultStr = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
            }
            else
            {
                throw error("@SKS6063");
            }
        }

        if (updateCreditCardResultStr == TrueDfltCard)
        {
            updateCreditCardResult = true;
        }

        return updateCreditCardResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerNumberInPayFabricWallet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to update the customer number in an existing PayFabric wallet
    /// </summary>
    /// <param name = "_pfCardId">The card token for the PayFabric Wallet to update</param>
    /// <returns>A boolean value to indicate if customer number was updated in PayFabric wallet</returns>
    public boolean updateCustomerNumberInPayFabricWallet(str _pfCardId)
    {
        const str UpdateCustomerNumber = 'UpdateCustomerNumber';
        const str PayFabricCardId = 'PayFabricCardId';
        const str PFNewCustomerNumber = 'pfNewCustomerNumber';
        const str PFUpdateCustomerNumberResult = 'PFUpdateCustomerNumberResult';
        const str TrueResponse = 'True';
       
        CreditCardProcessors                                    activeCreditCardProcessors;
        CreditCardAccountSetup                                  creditCardAccountSetup;
        CreditCardProcessors                                    creditCardProcessors;
        Retail.PaymentSDK.Portable.IPaymentProcessor            processor;
        Retail.PaymentSDK.Portable.PaymentProperty[]            processorProperties;
        Retail.PaymentSDK.Portable.PaymentProperty[]            paymentCardProperties;
        Retail.PaymentSDK.Portable.Request                      request = new Retail.PaymentSDK.Portable.Request();
        Retail.PaymentSDK.Portable.Response                     response;
        Retail.PaymentSDK.Portable.PaymentProperty              property;
        CreditCardPaymentProperties                             interactionProperties = CreditCardPaymentProperties::construct();
        CreditCardPaymentProperties                             requestProperties;
        CreditCardPaymentErrors                                 errors;
        str                                                     updateCreditCardResultStr;
        boolean                                                 updateCreditCardResult;

        if (!_pfCardId)
        {
            throw error(strFmt("@SKS6060", error::wrongUseOfFunction(funcName())));
        }

        activeCreditCardProcessors = CreditCardProcessors::findActiveProcessor();

        select firstonly creditCardAccountSetup
        exists join creditCardProcessors
            where creditCardProcessors.Name == activeCreditCardProcessors.Name &&
            creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

        if (!creditCardAccountSetup)
        {
            throw error(strFmt("@SYS4040016", activeCreditCardProcessors.Name));
        }

        var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
        processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);
        requestProperties = CreditCardPaymentProperties::fromProperties(processorProperties);

        processor = this.getProcessor(creditCardAccountSetup.ConnectorName);

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricOperation, CreditCardPropertySecurityLevel::None,
                                                                    PayFabric_Operation, PayFabric_Operation, UpdateCustomerNumber));

        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PayFabricCardId, CreditCardPropertySecurityLevel::PII,
                                                                    PayFabric_Card_Id, PayFabric_Card_Id, _pfCardId));
        
        requestProperties.add(CreditCardPaymentProperty::newDisplay(Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PFNewCustomerNumber, CreditCardPropertySecurityLevel::None,
                                                                    PFNewCustomerNumber, PFNewCustomerNumber, payFabricCustomerNbr));

        request.set_Locale(currentUserLanguage());
        request.set_Properties(requestProperties.toArray());

        response = processor.GenerateCardToken(request, interactionProperties.toArray());
        errors = CreditCardPaymentErrors::fromPaymentErrors(response.get_Errors());

        if (errors.count() == 0)
        {
            paymentCardProperties = response.get_Properties();
        }
        else
        {
            throw error(strFmt("@SKS:SKGCCErrorFoundWhileUpdateCustNbr", strReplace(errors.toString(), '\n', '; ')));
        }

        if (paymentCardProperties != null)
        {
            property = CreditCardConnectorSetup::findPropertyByName(paymentCardProperties,
                                                                    Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                                                                    PFUpdateCustomerNumberResult);

            if(property)
            {
                updateCreditCardResultStr = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
            }
            else
            {
                throw error("@SKS6063");
            }
        }

        if (updateCreditCardResultStr == TrueResponse)
        {
            updateCreditCardResult = true;
        }

        return updateCreditCardResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricCustomerNbr</Name>
				<Source><![CDATA[
    public str getPayFabricCustomerNbr()
    {        
        return payFabricCustomerNbr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPayFabricCustomerNbr</Name>
				<Source><![CDATA[
    public void setPayFabricCustomerNbr()
    {
        if (oneTimeCustRefTableId && oneTimeCustRefRecId)
        {
            payFabricCustomerNbr = SKS_CC_PayFabricWalletHandler::getPayFabricCustomerNbrForOneTimeCust(
                oneTimeCustRefTableId,
                oneTimeCustRefRecId,
                custAccount);
        }
        else
        {
            payFabricCustomerNbr = custAccount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricCustomerNbrForOneTimeCust</Name>
				<Source><![CDATA[
    public static str getPayFabricCustomerNbrForOneTimeCust(
        RefTableId _oneTimeCustRefTableId,
        RefRecId _oneTimeCustRefRecId,
        CustAccount _custAccount)
    {
        str pfCustAccount;

        if (_oneTimeCustRefTableId && _oneTimeCustRefRecId && _custAccount)
        {
            pfCustAccount = strFmt('%1_%2_%3', int2Str(_oneTimeCustRefTableId), int642Str(_oneTimeCustRefRecId), _custAccount);
        }

        return pfCustAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessor</Name>
				<Source><![CDATA[
    protected Retail.PaymentSDK.Portable.IPaymentProcessor getProcessor(CreditCardConnectorName _connectorName)
    {
        InteropPermission perm = new InteropPermission(InteropKind::ClrInterop);

        perm.assert();

        Retail.PaymentSDK.Portable.IPaymentProcessor processor;

        try
        {
            processor = new CreditCardPaymentProcessorFactory().getProcessor(_connectorName);
        }
        catch (Exception::CLRError)
        {
            throw error("@SYS4040006" + ' ' + this.getClrExceptionMessage());
        }
        catch
        {
            throw error("@SYS4040006");
        }

        CodeAccessPermission::revertAssert();

        return processor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayFabricURL</Name>
				<Source><![CDATA[
    public str getPayFabricURL(CreditCardProcessorsName _processorName)
    {
        str pfURL = '';

        if (_processorName)
        {
            CreditCardAccountSetup creditCardAccountSetup;
            CreditCardProcessors creditCardProcessors;
            Retail.PaymentSDK.Portable.PaymentProperty property;
            Retail.PaymentSDK.Portable.PaymentProperty[] processorProperties;
            InteropPermission perm = new InteropPermission(InteropKind::ClrInterop);

            perm.assert();

            select creditCardAccountSetup
            exists join creditCardProcessors
                where creditCardProcessors.Name == _processorName
                && creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors;

            if (creditCardAccountSetup)
            {                
                var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(Decrypt, '');
                processorProperties = Retail.PaymentSDK.Portable.PaymentProperty::ConvertXMLToPropertyArray(merchant);

                property = CreditCardConnectorSetup::findPropertyByName(processorProperties,
                    Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_MerchantAccount(),
                    PFWebServLoc);

                pfURL = CreditCardPaymentProperty::clrString2Str(property.get_StringValue());
            }

            CodeAccessPermission::revertAssert();
        }

        return pfURL;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>